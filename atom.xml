<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>希文的个人博客</title>
  
  <subtitle>白日依山尽，黄河入海流。欲穷千里目，更上一层楼。</subtitle>
  <link href="https://yangmour.github.io/atom.xml" rel="self"/>
  
  <link href="https://yangmour.github.io/"/>
  <updated>2022-11-01T13:59:58.925Z</updated>
  <id>https://yangmour.github.io/</id>
  
  <author>
    <name>希文</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习路线</title>
    <link href="https://yangmour.github.io/2022/11/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E8%B7%AF%E7%BA%BF/%E8%B7%AF%E7%BA%BF/"/>
    <id>https://yangmour.github.io/2022/11/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E8%B7%AF%E7%BA%BF/%E8%B7%AF%E7%BA%BF/</id>
    <published>2022-11-03T02:40:17.000Z</published>
    <updated>2022-11-01T13:59:58.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路线图（持续更新）"><a href="#路线图（持续更新）" class="headerlink" title="路线图（持续更新）"></a>路线图（持续更新）</h2><p><img src="https://image.3001.net/images/20221101/16673111878038.png" alt="图片"></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;路线图（持续更新）&quot;&gt;&lt;a href=&quot;#路线图（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;路线图（持续更新）&quot;&gt;&lt;/a&gt;路线图（持续更新）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20221101/16673111878038.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="路线" scheme="https://yangmour.github.io/tags/%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="https://yangmour.github.io/2022/11/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/zookeeper/zookeeper-3.5.7/"/>
    <id>https://yangmour.github.io/2022/11/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/zookeeper/zookeeper-3.5.7/</id>
    <published>2022-11-02T15:06:17.000Z</published>
    <updated>2022-11-02T15:24:30.057Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>尚硅谷技术之 Zookeeper  </p><p>（作者：尚硅谷研究院） </p><p>版本：V3.3 </p><h1 id="第-1-章-Zookeeper-入门"><a href="#第-1-章-Zookeeper-入门" class="headerlink" title="第 1 章 Zookeeper 入门"></a>第 <strong>1</strong> 章 <strong>Zookeeper</strong> 入门</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。 </p><p><img src="https://image.3001.net/images/20221102/16673997206641.png" alt="image-20221102223508155"></p><span id="more"></span><p><img src="https://image.3001.net/images/20221102/16673997427193.png" alt="image-20221102223530801"></p><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><p><img src="https://image.3001.net/images/20221102/16673997603200.png" alt="image-20221102223548537"></p><p>1）Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。 </p><p>2）集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所 以Zookeeper适合安装奇数台服务器。 </p><p>3）全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</p><p>4）更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。</p><p>5）数据更新原子性，一次数据更新要么成功，要么失败。 6）实时性，在一定时间范围内，Client能读到最新数据。</p><h2 id="1-3-数据结构"><a href="#1-3-数据结构" class="headerlink" title="1.3 数据结构"></a><strong>1.3</strong> 数据结构</h2><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过其路径唯一标识。 </p><p><img src="https://image.3001.net/images/20221102/1667399826709.png" alt="image-20221102223654582"></p><h2 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h2><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下</p><p>线、软负载均衡等。</p><p><img src="https://image.3001.net/images/20221101/16673103336222.gif" alt="img"></p><p><img src="https://image.3001.net/images/20221101/16673103336273.gif" alt="img"></p><h2 id="1-5-下载地址"><a href="#1-5-下载地址" class="headerlink" title="1.5 下载地址"></a><strong>1.5</strong> 下载地址</h2><p><strong>1</strong>）官网首页：</p><p><a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a> </p><p>2）下载截图1</p><p><img src="https://image.3001.net/images/20221102/1667400006134.png" alt="image-20221102223954512"></p><p><img src="https://image.3001.net/images/20221102/16674000294293.png" alt="image-20221102224017707"></p><p><img src="https://image.3001.net/images/20221102/16674000421122.png" alt="image-20221102224031118"></p><p>3）下载 Linux 环境安装的 tar 包</p><p><img src="https://image.3001.net/images/20221102/16674001078374.png" alt="image-20221102224136026"></p><h1 id="第-2-章-Zookeeper-本地安装"><a href="#第-2-章-Zookeeper-本地安装" class="headerlink" title="第 2 章 Zookeeper 本地安装"></a>第 2 章 Zookeeper 本地安装</h1><h2 id="2-1-本地模式安装"><a href="#2-1-本地模式安装" class="headerlink" title="2.1 本地模式安装"></a><strong>2.1</strong> 本地模式安装</h2><p>1）安装前准备</p><p>（1）安装 JDK</p><p>（2）拷贝 apache-zookeeper-3.5.7-bin.tar.gz 安装包到 Linux 系统下</p><p>（3）解压到指定目录 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 software]$ tar -zxvf apache-zookeeper-3.5.7bin.tar.gz -C /opt/module/ </span><br></pre></td></tr></table></figure><p>（4）修改名称 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 module]$ mv apache-zookeeper-3.5.7 -bin/ zookeeper-3.5.7 </span><br></pre></td></tr></table></figure><p><strong>2）</strong>配置修改 </p><p>（1）将/opt/module/zookeeper-3.5.7/conf 这个路径下的 zoo_sample.cfg 修改为 zoo.cfg； </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 conf]$ mv zoo_sample.cfg zoo.cfg </span><br></pre></td></tr></table></figure><p>（2）打开 zoo.cfg 文件，修改 dataDir 路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ vim zoo.cfg </span><br></pre></td></tr></table></figure><p>修改如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/opt/module/zookeeper-3.5.7/zkData</span><br></pre></td></tr></table></figure><p>（3）在/opt/module/zookeeper-3.5.7/这个目录上创建 zkData 文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ mkdir zkData </span><br></pre></td></tr></table></figure><p><strong>3）</strong>操作 <strong>Zookeeper</strong> </p><p>（1）启动 Zookeeper </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ bin/zkServer.sh start </span><br></pre></td></tr></table></figure><p>（2）查看进程是否启动 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ jps </span><br><span class="line">4020 Jps </span><br><span class="line">4001 QuorumPeerMain </span><br></pre></td></tr></table></figure><p>（3）查看状态 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ bin/zkServer.sh status </span><br><span class="line">ZooKeeper JMX enabled by default </span><br><span class="line">Using config: /opt/module/zookeeper-3.5.7/bin/../conf/zoo.cfg</span><br><span class="line">Mode: standalone </span><br></pre></td></tr></table></figure><p>（4）启动客户端 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ bin/zkCli.sh </span><br></pre></td></tr></table></figure><p>（5）退出客户端： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] quit </span><br></pre></td></tr></table></figure><p>（6）停止 Zookeeper </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ bin/zkServer.sh stop </span><br></pre></td></tr></table></figure><h2 id="2-2-配置参数解读"><a href="#2-2-配置参数解读" class="headerlink" title="2.2 配置参数解读"></a><strong>2.2</strong> 配置参数解读</h2><p>​    Zookeeper中的配置文件zoo.cfg中参数含义解读如下：</p><p><strong>1</strong>）<strong>tickTime = 2000</strong>：通信心跳时间，<strong>Zookeeper</strong>服务器与客户端心跳时间，单位毫秒 </p><p><img src="https://image.3001.net/images/20221102/16674002559289.png" alt="image-20221102224404090"></p><p>2）initLimit = 10：LF初始通信时限</p><p><img src="https://image.3001.net/images/20221101/16673103336664.jpg" alt="img"> </p><p>Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量）</p><p><strong>3）</strong> <strong>syncLimit = 5</strong>：<strong>LF</strong>同步通信时限 </p><p><img src="https://image.3001.net/images/20221101/16673103339937.jpg" alt="img"> </p><p>​    Leader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follwer死</p><p>掉，从服务器列表中删除Follwer。 </p><p><strong>4）</strong> <strong>dataDir</strong>：保存Zookeeper中的数据</p><p>​    注意：默认的tmp目录，容易被Linux系统定期删除，所以一般不用默认的tmp目录。 </p><p><strong>5）</strong> <strong>clientPort = 2181</strong>：客户端连接端口，通常不做修改。</p><h1 id="第-3-章-Zookeeper-集群操作"><a href="#第-3-章-Zookeeper-集群操作" class="headerlink" title="第 3 章 Zookeeper 集群操作"></a>第 <strong>3</strong> 章 <strong>Zookeeper</strong> 集群操作</h1><h2 id="3-1-集群操作"><a href="#3-1-集群操作" class="headerlink" title="3.1 集群操作"></a><strong>3.1</strong> 集群操作</h2><h3 id="3-1-1-集群安装"><a href="#3-1-1-集群安装" class="headerlink" title="3.1.1 集群安装"></a><strong>3.1.1</strong> 集群安装</h3><p><strong>1）</strong>集群规划 </p><p>​    在 hadoop102、hadoop103 和 hadoop104 三个节点上都部署 Zookeeper。 </p><p>​    思考：如果是<em>10</em> 台服务器，需要部署多少台<em>Zookeeper</em>？ </p><p><strong>2）</strong>解压安装 </p><p>（1）在 hadoop102 解压 Zookeeper 安装包到/opt/module/目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 software]$ tar -zxvf apache-zookeeper-3.5.7bin.tar.gz -C /opt/module/ </span><br></pre></td></tr></table></figure><p>（2）修改 apache-zookeeper-3.5.7-bin 名称为 zookeeper-3.5.7 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 module]$ mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7 </span><br></pre></td></tr></table></figure><p><strong>3）</strong>配置服务器编号 </p><p>（1）在/opt/module/zookeeper-3.5.7/这个目录下创建 zkData</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ mkdir zkData </span><br></pre></td></tr></table></figure><p>（2）在/opt/module/zookeeper-3.5.7/zkData 目录下创建一个 myid 的文件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zkData]$ vi myid</span><br></pre></td></tr></table></figure><p>在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br></pre></td></tr></table></figure><p>注意：添加 myid 文件，一定要在 Linux 里面创建，在 notepad++里面很可能乱码 </p><p>（3）拷贝配置好的 zookeeper 到其他机器上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 module ]$ xsync zookeeper-3.5.7 </span><br></pre></td></tr></table></figure><p>并分别在 hadoop103、hadoop104 上修改 myid 文件中内容为 3、4 </p><p><strong>4）</strong>配置<strong>zoo.cfg</strong>文件 （我用的cp 复制）</p><p>（1）重命名/opt/module/zookeeper-3.5.7/conf 这个目录下的 zoo_sample.cfg 为 zoo.cfg </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 conf]$ mv zoo_sample.cfg zoo.cfg </span><br></pre></td></tr></table></figure><p>（2）打开 zoo.cfg 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 conf]$ vim zoo.cfg</span><br></pre></td></tr></table></figure><p>#修改数据存储路径配置 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/opt/module/zookeeper-3.5.7/zkData</span><br></pre></td></tr></table></figure><p>#增加如下配置 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#######################cluster########################## server.2=hadoop102:2888:3888 server.3=hadoop103:2888:3888 server.4=hadoop104:2888:3888 </span><br></pre></td></tr></table></figure><p>（3）配置参数解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.A=B:C:D。 </span><br></pre></td></tr></table></figure><p><strong>A</strong>    是一个数字，表示这个是第几号服务器；集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。 </p><p><strong>B</strong>    是这个服务器的地址； </p><p><strong>C</strong>    是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口；</p><p><strong>D</strong>    是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。 </p><p>（4）同步 zoo.cfg 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 conf]$ xsync zoo.cfg </span><br></pre></td></tr></table></figure><p><strong>5）</strong>集群操作 </p><p>（1）分别启动 Zookeeper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ bin/zkServer.sh start </span><br><span class="line">[atguigu@hadoop103 zookeeper-3.5.7]$ bin/zkServer.sh start </span><br><span class="line">[atguigu@hadoop104 zookeeper-3.5.7]$ bin/zkServer.sh start </span><br></pre></td></tr></table></figure><p>（2）查看状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]# bin/zkServer.sh status </span><br><span class="line">JMX enabled by default </span><br><span class="line">Using config: /opt/module/zookeeper-3.5.7/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop103 zookeeper-3.5.7]# bin/zkServer.sh status </span><br><span class="line">JMX enabled by default </span><br><span class="line">Using config: /opt/module/zookeeper-3.5.7/bin/../conf/zoo.cfg </span><br><span class="line">Mode: leader </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop104 zookeeper-3.4.5]# bin/zkServer.sh status </span><br><span class="line">JMX enabled by default </span><br><span class="line">Using config: /opt/module/zookeeper-3.5.7/bin/../conf/zoo.cfg Mode: follower </span><br></pre></td></tr></table></figure><h3 id="3-1-2-选举机制（面试重点）"><a href="#3-1-2-选举机制（面试重点）" class="headerlink" title="3.1.2 选举机制（面试重点）"></a><strong>3.1.2</strong> 选举机制（面试重点）</h3><p><img src="https://image.3001.net/images/20221101/16673103337865.gif" alt="img"></p><h3 id="3-1-3-ZK-集群启动停止脚本"><a href="#3-1-3-ZK-集群启动停止脚本" class="headerlink" title="3.1.3 ZK 集群启动停止脚本"></a><strong>3.1.3 ZK</strong> 集群启动停止脚本</h3><p>1）在 hadoop102 的/home/atguigu/bin 目录下创建脚本 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 bin]$ vim zk.sh</span><br></pre></td></tr></table></figure><p> 在脚本中编写如下内容 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line">for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line"> echo ---------- zookeeper $i 启动 ------------</span><br><span class="line">ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh start&quot;</span><br><span class="line">done</span><br><span class="line">&#125;;;</span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line"> echo ---------- zookeeper $i 停止 ------------</span><br><span class="line">ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh stop&quot;</span><br><span class="line">done</span><br><span class="line">&#125;;;</span><br><span class="line">&quot;status&quot;)&#123;</span><br><span class="line">for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line"> echo ---------- zookeeper $i 状态 ------------</span><br><span class="line">ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh status&quot;</span><br><span class="line">done</span><br><span class="line">&#125;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>2）增加脚本执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 bin]$ chmod u+x zk.sh </span><br></pre></td></tr></table></figure><p>3）Zookeeper 集群启动脚本 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 module]$ zk.sh start </span><br></pre></td></tr></table></figure><p>4）Zookeeper 集群停止脚本 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 module]$ zk.sh stop </span><br></pre></td></tr></table></figure><h2 id="3-2-客户端命令行操作"><a href="#3-2-客户端命令行操作" class="headerlink" title="3.2 客户端命令行操作"></a><strong>3.2</strong> 客户端命令行操作</h2><h3 id="3-2-1-命令行语法"><a href="#3-2-1-命令行语法" class="headerlink" title="3.2.1 命令行语法"></a><strong>3.2.1</strong> 命令行语法</h3><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls path</td><td>使用 ls 命令来查看当前 znode 的子节点 [可监听]   -w 监听子节点变化   -s  附加次级信息</td></tr><tr><td>create</td><td>普通创建   -s 含有序列   -e 临时（重启或者超时消失）</td></tr><tr><td>get path</td><td>获得节点的值 [可监听]   -w 监听节点内容变化   -s  附加次级信息</td></tr><tr><td>set</td><td>设置节点的具体值</td></tr><tr><td>stat</td><td>查看节点状态</td></tr><tr><td>delete</td><td>删除节点</td></tr><tr><td>deleteall</td><td>递归删除节点</td></tr></tbody></table><p><strong>1）</strong>启动客户端 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 zookeeper-3.5.7]$ bin/zkCli.sh -server hadoop102:2181</span><br></pre></td></tr></table></figure><p><strong>2）</strong>显示所有操作命令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: hadoop102:2181(CONNECTED) 1] help </span><br></pre></td></tr></table></figure><h3 id="3-2-2-znode-节点数据信息"><a href="#3-2-2-znode-节点数据信息" class="headerlink" title="3.2.2 znode 节点数据信息"></a><strong>3.2.2 znode</strong> 节点数据信息</h3><p><strong>1）</strong>查看当前<strong>znode</strong>中所包含的内容 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: hadoop102:2181(CONNECTED) 0] ls / </span><br><span class="line">[zookeeper] </span><br></pre></td></tr></table></figure><p><strong>2）</strong>查看当前节点详细数据 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: hadoop102:2181(CONNECTED) 5] ls -s /</span><br><span class="line">[zookeeper]cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure><p>（1）   czxid：创建节点的事务 zxid 每次修改 ZooKeeper 状态都会产生一个 ZooKeeper 事务 ID。事务 ID 是 ZooKeeper 中所有修改总的次序。每次修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。 </p><p>（2）   ctime：znode 被创建的毫秒数（从 1970 年开始）</p><p>（3）   mzxid：znode 最后更新的事务 zxid </p><p>（4）   mtime：znode 最后修改的毫秒数（从 1970 年开始）</p><p>（5）   pZxid：znode 最后更新的子节点 zxid </p><p>（6）   cversion：znode 子节点变化号，znode 子节点修改次数</p><p>（7）   dataversion：znode 数据变化号 </p><p>（8）   aclVersion：znode 访问控制列表的变化号 </p><p>（9）   ephemeralOwner：如果是临时节点，这个是 znode 拥有者的 session id。如果不是临时节点则是 0。 </p><p>（10）  dataLength：znode 的数据长度 </p><p>（11）  numChildren：znode 子节点数量 </p><h3 id="3-2-3-节点类型（持久-短暂-有序号-无序号）"><a href="#3-2-3-节点类型（持久-短暂-有序号-无序号）" class="headerlink" title="3.2.3 节点类型（持久**/短暂/有序号/**无序号）"></a><strong>3.2.3</strong> 节点类型（持久**/<strong>短暂</strong>/<strong>有序号</strong>/**无序号）</h3><p><img src="https://image.3001.net/images/20221102/16674007565616.png" alt="image-20221102225224799"></p><p><strong>1）</strong>分别创建<strong>2</strong>个普通节点（永久节点 <strong>+</strong> 不带序号） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] create /sanguo &quot;diaochan&quot; </span><br><span class="line">Created /sanguo </span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create /sanguo/shuguo &quot;liubei&quot; </span><br><span class="line">Created /sanguo/shuguo </span><br></pre></td></tr></table></figure><p> 注意：创建节点时，要赋值 </p><p><strong>2）</strong>获得节点的值 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] get -s /sanguo</span><br><span class="line">diaochan</span><br><span class="line">cZxid = 0x100000003</span><br><span class="line">ctime = Wed Aug 29 00:03:23 CST 2018</span><br><span class="line">mZxid = 0x100000003</span><br><span class="line">mtime = Wed Aug 29 00:03:23 CST 2018</span><br><span class="line">pZxid = 0x100000004</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 7</span><br><span class="line">numChildren = 1</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] get -s /sanguo/shuguo</span><br><span class="line">liubei</span><br><span class="line">cZxid = 0x100000004</span><br><span class="line">ctime = Wed Aug 29 00:04:35 CST 2018</span><br><span class="line">mZxid = 0x100000004</span><br><span class="line">mtime = Wed Aug 29 00:04:35 CST 2018</span><br><span class="line">pZxid = 0x100000004</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3）</strong>创建带序号的节点（永久节点 <strong>+</strong> 带序号） </p><p>（1）先创建一个普通的根节点/sanguo/weiguo </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /sanguo/weiguo &quot;caocao&quot; </span><br><span class="line">Created /sanguo/weiguo </span><br></pre></td></tr></table></figure><p>（2）创建带序号的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -s /sanguo/weiguo/zhangliao &quot;zhangliao&quot;</span><br><span class="line">Created /sanguo/weiguo/zhangliao0000000000</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create -s /sanguo/weiguo/zhangliao &quot;zhangliao&quot;</span><br><span class="line">Created /sanguo/weiguo/zhangliao0000000001</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create -s /sanguo/weiguo/xuchu &quot;xuchu&quot;</span><br><span class="line">Created /sanguo/weiguo/xuchu0000000002</span><br></pre></td></tr></table></figure><p>如果原来没有序号节点，序号从 0 开始依次递增。如果原节点下已有 2 个节点，则再排序时从 2 开始，以此类推。</p><p><strong>4）</strong>创建短暂节点（短暂节点 <strong>+</strong> 不带序号 <strong>or</strong> 带序号） </p><p>（1）创建短暂的不带序号的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] create -e /sanguo/wuguo &quot;zhouyu&quot; </span><br><span class="line">Created /sanguo/wuguo </span><br></pre></td></tr></table></figure><p>（2）创建短暂的带序号的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e -s /sanguo/wuguo &quot;zhouyu&quot; </span><br><span class="line">Created /sanguo/wuguo0000000001 </span><br></pre></td></tr></table></figure><p>（3）在当前客户端是能查看到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /sanguo</span><br><span class="line">[wuguo, wuguo0000000001, shuguo] </span><br></pre></td></tr></table></figure><p>（4）退出当前客户端然后再重启客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] quit </span><br><span class="line">[atguigu@hadoop104 zookeeper-3.5.7]$ bin/zkCli.sh </span><br></pre></td></tr></table></figure><p>（5）再次查看根目录下短暂节点已经删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /sanguo </span><br><span class="line">[shuguo] </span><br></pre></td></tr></table></figure><p><strong>5）</strong>修改节点数据值 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] set /sanguo/weiguo &quot;simayi&quot; </span><br></pre></td></tr></table></figure><h3 id="3-2-4-监听器原理"><a href="#3-2-4-监听器原理" class="headerlink" title="3.2.4 监听器原理"></a><strong>3.2.4</strong> 监听器原理</h3><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增加删除）时，ZooKeeper 会通知客户端。监听机制保证 ZooKeeper 保存的任何的数</p><p>据的任何改变都能快速的响应到监听了该节点的应用程序。</p><p><img src="https://image.3001.net/images/20221102/16674009868131.png" alt="image-20221102225614958"></p><p><strong>1）</strong>节点的值变化监听 </p><p>（1）在 hadoop104 主机上注册监听/sanguo 节点数据变化 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 26] get -w /sanguo </span><br></pre></td></tr></table></figure><p>（2）在 hadoop103 主机上修改/sanguo 节点的数据 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] set /sanguo &quot;xisi&quot; </span><br></pre></td></tr></table></figure><p>（3）观察 hadoop104 主机收到数据变化的监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/sanguo</span><br></pre></td></tr></table></figure><p> 注意：在hadoop103再多次修改/sanguo的值，hadoop104上不会再收到监听。因为注册</p><p>一次，只能监听一次。想再次监听，需要再次注册。 </p><p><strong>2）</strong>节点的子节点变化监听（路径变化） </p><p>（1）在 hadoop104 主机上注册监听/sanguo 节点的子节点变化 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls -w /sanguo </span><br><span class="line">[shuguo, weiguo] </span><br></pre></td></tr></table></figure><p>（2）在 hadoop103 主机/sanguo 节点上创建子节点 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create /sanguo/jin &quot;simayi&quot; </span><br><span class="line">Created /sanguo/jin </span><br></pre></td></tr></table></figure><p>（3）观察 hadoop104 主机收到子节点变化的监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WATCHER:: </span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/sanguo </span><br></pre></td></tr></table></figure><p>注意：节点的路径变化，也是注册一次，生效一次。想多次生效，就需要多次注册。 </p><h3 id="3-2-5-节点删除与查看"><a href="#3-2-5-节点删除与查看" class="headerlink" title="3.2.5 节点删除与查看"></a><strong>3.2.5</strong> 节点删除与查看</h3><p><strong>1）</strong>删除节点 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] delete /sanguo/jin </span><br></pre></td></tr></table></figure><p><strong>2）</strong>递归删除节点 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 15] deleteall /sanguo/shuguo </span><br></pre></td></tr></table></figure><p><strong>3）</strong>查看节点状态 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 17] stat /sanguo</span><br><span class="line">cZxid = 0x100000003</span><br><span class="line">ctime = Wed Aug 29 00:03:23 CST 2018</span><br><span class="line">mZxid = 0x100000011</span><br><span class="line">mtime = Wed Aug 29 00:21:23 CST 2018</span><br><span class="line">pZxid = 0x100000014</span><br><span class="line">cversion = 9</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure><h2 id="3-3-客户端-API-操作"><a href="#3-3-客户端-API-操作" class="headerlink" title="3.3 客户端 API 操作"></a>3.3 客户端 API 操作</h2><p>前提：保证 hadoop102、hadoop103、hadoop104 服务器上 Zookeeper 集群服务端启动。 </p><h3 id="3-3-1-IDEA-环境搭建"><a href="#3-3-1-IDEA-环境搭建" class="headerlink" title="3.3.1 IDEA 环境搭建"></a><strong>3.3.1 IDEA</strong> 环境搭建</h3><p><strong>1）</strong>创建一个工程：<strong>zookeeper</strong> </p><p><strong>2）</strong>添加<strong>pom</strong>文件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.8.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>3）</strong>拷贝<strong>log4j.properties</strong>文件到项目根目录需要在项目的 src/main/resources 目录下，新建一个文件，命名为“log4j.properties”，在</p><p>文件中填入。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO, stdout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n</span></span><br><span class="line"><span class="meta">log4j.appender.logfile</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.File</span>=<span class="string">target/spring.log</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n </span></span><br></pre></td></tr></table></figure><p><strong>4）</strong>创建包名<strong>com.atguigu.zk</strong> </p><p><strong>5）</strong>创建类名称<strong>zkClient</strong> </p><h3 id="3-3-2-创建-ZooKeeper-客户端"><a href="#3-3-2-创建-ZooKeeper-客户端" class="headerlink" title="3.3.2 创建 ZooKeeper 客户端"></a><strong>3.3.2</strong> 创建 <strong>ZooKeeper</strong> 客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 注意：逗号前后不能有空格 </span><br><span class="line">    private static String connectString =</span><br><span class="line">            &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;</span><br><span class="line"></span><br><span class="line">    private static int sessionTimeout = 2000;</span><br><span class="line">    private ZooKeeper zkClient = null;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                // 收到事件通知后的回调函数（用户的业务逻辑） </span><br><span class="line">                System.out.println(watchedEvent.getType() + &quot;--&quot; + watchedEvent.getPath());</span><br><span class="line"></span><br><span class="line">                // 再次启动监听 </span><br><span class="line">                try &#123;</span><br><span class="line">                    List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;, true);</span><br><span class="line">                    for (String child : children) &#123;</span><br><span class="line">                        System.out.println(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-创建子节点"><a href="#3-3-3-创建子节点" class="headerlink" title="3.3.3 创建子节点"></a><strong>3.3.3</strong> 创建子节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建子节点</span><br><span class="line">@Test</span><br><span class="line">public void create() throws Exception &#123;</span><br><span class="line">    // 参数 1：要创建的节点的路径； 参数 2：节点数据 ； 参数 3：节点权限 ；</span><br><span class="line">    参数 4：节点的类型</span><br><span class="line">    String nodeCreated = zkClient.create(&quot;/atguigu&quot;,</span><br><span class="line">    &quot;shuaige&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">    CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：在 hadoop102 的 zk 客户端上查看创建节点情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 16] get -s /atguigu</span><br><span class="line">shuaige</span><br></pre></td></tr></table></figure><h3 id="3-3-4-获取子节点并监听节点变化"><a href="#3-3-4-获取子节点并监听节点变化" class="headerlink" title="3.3.4 获取子节点并监听节点变化"></a><strong>3.3.4</strong> 获取子节点并监听节点变化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取子节点</span><br><span class="line">@Test</span><br><span class="line">public void getChildren() throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;, true);</span><br><span class="line">    for (String child : children) &#123;</span><br><span class="line">        System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    // 延时阻塞</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）在 IDEA 控制台上看到如下节点： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zookeeper </span><br><span class="line">sanguo </span><br><span class="line">atguigu </span><br></pre></td></tr></table></figure><p>（2）在 hadoop102 的客户端上创建再创建一个节点/atguigu1，观察 IDEA 控制台 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] create /atguigu1 &quot;atguigu1&quot; </span><br></pre></td></tr></table></figure><p>（3）在 hadoop102 的客户端上删除节点/atguigu1，观察 IDEA 控制台 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] delete /atguigu1  </span><br></pre></td></tr></table></figure><h3 id="3-3-5-判断-Znode-是否存在"><a href="#3-3-5-判断-Znode-是否存在" class="headerlink" title="3.3.5 判断 Znode 是否存在"></a><strong>3.3.5</strong> 判断 <strong>Znode</strong> 是否存在</h3><p>// 判断znode是否存在 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取子节点</span><br><span class="line">@Test</span><br><span class="line">public void getChildren() throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;, true);</span><br><span class="line">    for (String child : children) &#123;</span><br><span class="line">    System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    // 延时阻塞</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-4-客户端向服务端写数据流程"><a href="#3-4-客户端向服务端写数据流程" class="headerlink" title="3.4 客户端向服务端写数据流程"></a><strong>3.4</strong> 客户端向服务端写数据流程</h2><p><img src="https://image.3001.net/images/20221102/16674014294385.png" alt="image-20221102230338175"></p><p><img src="https://image.3001.net/images/20221102/16674014464410.png" alt="image-20221102230354944"></p><h1 id="第-4-章-服务器动态上下线监听案例"><a href="#第-4-章-服务器动态上下线监听案例" class="headerlink" title="第 4 章 服务器动态上下线监听案例"></a>第 4 章 服务器动态上下线监听案例</h1><h2 id="4-1-需求"><a href="#4-1-需求" class="headerlink" title="4.1 需求"></a><strong>4.1</strong> 需求</h2><p>某分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知</p><p>到主节点服务器的上下线。</p><h2 id="4-2-需求分析"><a href="#4-2-需求分析" class="headerlink" title="4.2 需求分析"></a><strong>4.2</strong> 需求分析</h2><p><img src="https://image.3001.net/images/20221102/16674014814601.png" alt="image-20221102230430332"></p><h2 id="4-3-具体实现"><a href="#4-3-具体实现" class="headerlink" title="4.3 具体实现"></a><strong>4.3</strong> 具体实现</h2><p>（1）先在集群上创建/servers 节点 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] create /servers &quot;servers&quot;</span><br><span class="line">Created /servers </span><br></pre></td></tr></table></figure><p>（2）在 Idea 中创建包名：com.atguigu.zkcase1</p><p>（3）服务器端向 Zookeeper 注册代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.zkcase1;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.apache.zookeeper.CreateMode;</span><br><span class="line">import org.apache.zookeeper.WatchedEvent;</span><br><span class="line">import org.apache.zookeeper.Watcher;</span><br><span class="line">import org.apache.zookeeper.ZooKeeper;</span><br><span class="line">import org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"></span><br><span class="line">public class DistributeServer &#123;</span><br><span class="line">    private static String connectString =</span><br><span class="line">            &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;</span><br><span class="line">    private static int sessionTimeout = 2000;</span><br><span class="line">    private ZooKeeper zk = null;</span><br><span class="line">    private String parentNode = &quot;/servers&quot;;</span><br><span class="line"></span><br><span class="line">    // 创建到 zk 的客户端连接</span><br><span class="line">    public void getConnect() throws IOException &#123;</span><br><span class="line">        zk = new ZooKeeper(connectString, sessionTimeout, new</span><br><span class="line">                Watcher() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void process(WatchedEvent event) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 注册服务器</span><br><span class="line">    public void registServer(String hostname) throws Exception &#123;</span><br><span class="line">        String create = zk.create(parentNode + &quot;/server&quot;,</span><br><span class="line">                hostname.getBytes(), Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(hostname + &quot; is online &quot; + create);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 业务功能</span><br><span class="line">    public void business(String hostname) throws Exception &#123;</span><br><span class="line">        System.out.println(hostname + &quot; is working ...&quot;);</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">// 1 获取 zk 连接</span><br><span class="line">        DistributeServer server = new DistributeServer();</span><br><span class="line">        server.getConnect();</span><br><span class="line">// 2 利用 zk 连接注册服务器信息</span><br><span class="line">        server.registServer(args[0]);</span><br><span class="line">// 3 启动业务功能</span><br><span class="line">        server.business(args[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）客户端代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.zkcase1;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.zookeeper.WatchedEvent;</span><br><span class="line">import org.apache.zookeeper.Watcher;</span><br><span class="line">import org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line">public class DistributeClient &#123;</span><br><span class="line">    private static String connectString =</span><br><span class="line">            &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;</span><br><span class="line">    private static int sessionTimeout = 2000;</span><br><span class="line">    private ZooKeeper zk = null;</span><br><span class="line">    private String parentNode = &quot;/servers&quot;;</span><br><span class="line"></span><br><span class="line">    // 创建到 zk 的客户端连接</span><br><span class="line">    public void getConnect() throws IOException &#123;</span><br><span class="line">        zk = new ZooKeeper(connectString, sessionTimeout, new</span><br><span class="line">                Watcher() &#123;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void process(WatchedEvent event) &#123;</span><br><span class="line">// 再次启动监听</span><br><span class="line">                        try &#123;</span><br><span class="line">                            getServerList();</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取服务器列表信息</span><br><span class="line">    public void getServerList() throws Exception &#123;</span><br><span class="line">        // 1 获取服务器子节点信息，并且对父节点进行监听</span><br><span class="line">        List&lt;String&gt; children = zk.getChildren(parentNode, true);</span><br><span class="line">        // 2 存储服务器信息列表</span><br><span class="line">        ArrayList&lt;String&gt; servers = new ArrayList&lt;&gt;();</span><br><span class="line">        // 3 遍历所有节点，获取节点中的主机名称信息</span><br><span class="line">        for (String child : children) &#123;</span><br><span class="line">            byte[] data = zk.getData(parentNode + &quot;/&quot; + child,</span><br><span class="line">                    false, null);</span><br><span class="line">            servers.add(new String(data));</span><br><span class="line">        &#125;</span><br><span class="line">        // 4 打印服务器列表信息</span><br><span class="line">        System.out.println(servers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 业务功能</span><br><span class="line">    public void business() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;client is working ...&quot;);</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">// 1 获取 zk 连接</span><br><span class="line">        DistributeClient client = new DistributeClient();</span><br><span class="line">        client.getConnect();</span><br><span class="line">// 2 获取 servers 的子节点信息，从中获取服务器信息列表</span><br><span class="line">        client.getServerList();</span><br><span class="line">// 3 业务进程启动</span><br><span class="line">        client.business();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a><strong>4.4</strong> 测试</h2><p>1）在 Linux 命令行上操作增加减少服务器</p><p>（1）启动 DistributeClient 客户端</p><p>（2）在 hadoop102 上 zk 的客户端/servers 目录上创建临时带序号节点 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create -e -s /servers/hadoop102 &quot;hadoop102&quot;</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e -s /servers/hadoop103 &quot;hadoop103&quot;</span><br></pre></td></tr></table></figure><p>（3）观察 Idea 控制台变化 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop102, hadoop103] </span><br></pre></td></tr></table></figure><p>（4）执行删除操作 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] delete /servers/hadoop1020000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（5）观察 Idea 控制台变化 </p><p>[hadoop103] </p><p>2）在 Idea 上操作增加减少服务器</p><p>（1）启动 DistributeClient 客户端（如果已经启动过，不需要重启）</p><p>（2）启动 DistributeServer 服务 </p><p>①点击 Edit Configurations…</p><p><img src="https://image.3001.net/images/20221102/1667401661884.png" alt="image-20221102230729779"></p><p> ②在弹出的窗口中（Program arguments）输入想启动的主机，例如，hadoop102 </p><p><img src="https://image.3001.net/images/20221102/16674016864274.png" alt="image-20221102230754787"></p><p> ③回到 DistributeServer 的 main 方法，右键，在弹出的窗口中点击 Run </p><p>“DistributeServer.main()”</p><p><img src="https://image.3001.net/images/20221102/16674017002867.png" alt="image-20221102230809606"></p><p> ④观察 DistributeServer 控制台，提示 hadoop102 is working </p><p> ⑤观察 DistributeClient 控制台，提示 hadoop102 已经上线</p><h1 id="第-5-章-ZooKeeper-分布式锁案例"><a href="#第-5-章-ZooKeeper-分布式锁案例" class="headerlink" title="第 5 章 ZooKeeper 分布式锁案例"></a>第 <strong>5</strong> 章 <strong>ZooKeeper</strong> 分布式锁案例</h1><p>​    什么叫做分布式锁呢？</p><p>​    比如说”进程 1”在使用该资源的时候，会先去获得锁，”进程 1”获得锁以后会对该资源保持独占，这样其他进程就无法访问该资源，”进程 1”用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作分布式锁。</p><p><img src="https://image.3001.net/images/20221102/16674017343277.png" alt="image-20221102230842689"></p><h2 id="5-1-原生-Zookeeper-实现分布式锁案例"><a href="#5-1-原生-Zookeeper-实现分布式锁案例" class="headerlink" title="5.1 原生 Zookeeper 实现分布式锁案例"></a><strong>5.1</strong> 原生 <strong>Zookeeper</strong> 实现分布式锁案例</h2><p><strong>1）</strong>分布式锁实现 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.lock2;</span><br><span class="line"></span><br><span class="line">import org.apache.zookeeper.*;</span><br><span class="line">import org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class DistributedLock &#123;</span><br><span class="line">    // zookeeper server 列表</span><br><span class="line">    private String connectString =</span><br><span class="line">            &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;</span><br><span class="line">    // 超时时间</span><br><span class="line">    private int sessionTimeout = 2000;</span><br><span class="line">    private ZooKeeper zk;</span><br><span class="line">    private String rootNode = &quot;locks&quot;;</span><br><span class="line">    private String subNode = &quot;seq-&quot;;</span><br><span class="line">    // 当前 client 等待的子节点</span><br><span class="line">    private String waitPath;</span><br><span class="line">    //ZooKeeper 连接</span><br><span class="line">    private CountDownLatch connectLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    //ZooKeeper 节点等待</span><br><span class="line">    private CountDownLatch waitLatch = new CountDownLatch(1);</span><br><span class="line">    // 当前 client 创建的子节点</span><br><span class="line">    private String currentNode;</span><br><span class="line"></span><br><span class="line">    // 和 zk 服务建立连接，并创建根节点</span><br><span class="line">    public DistributedLock() throws IOException,</span><br><span class="line">            InterruptedException, KeeperException &#123;</span><br><span class="line">        zk = new ZooKeeper(connectString, sessionTimeout, new</span><br><span class="line">                Watcher() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void process(WatchedEvent event) &#123;</span><br><span class="line">                        // 连接建立时, 打开 latch, 唤醒 wait 在该 latch 上的线程</span><br><span class="line">                        if (event.getState() ==</span><br><span class="line">                                Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                            connectLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 发生了 waitPath 的删除事件</span><br><span class="line">                        if (event.getType() ==</span><br><span class="line">                                Event.EventType.NodeDeleted &amp;&amp; event.getPath().equals(waitPath)) &#123;</span><br><span class="line">                            waitLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        // 等待连接建立</span><br><span class="line">        connectLatch.await();</span><br><span class="line">        //获取根节点状态</span><br><span class="line">        Stat stat = zk.exists(&quot;/&quot; + rootNode, false);</span><br><span class="line">        //如果根节点不存在，则创建根节点，根节点类型为永久节点</span><br><span class="line">        if (stat == null) &#123;</span><br><span class="line">            System.out.println(&quot;根节点不存在&quot;);</span><br><span class="line">            zk.create(&quot;/&quot; + rootNode, new byte[0],</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加锁方法</span><br><span class="line">    public void zkLock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //在根节点下创建临时顺序节点，返回值为创建的节点路径</span><br><span class="line">            currentNode = zk.create(&quot;/&quot; + rootNode + &quot;/&quot; + subNode,</span><br><span class="line">                    null, ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                    CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            // wait 一小会, 让结果更清晰一些</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">            // 注意, 没有必要监听&quot;/locks&quot;的子节点的变化情况</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; childrenNodes = zk.getChildren(&quot;/&quot; +</span><br><span class="line">                    rootNode, false);</span><br><span class="line">            // 列表中只有一个子节点, 那肯定就是 currentNode , 说明</span><br><span class="line">            client 获得锁</span><br><span class="line">            if (childrenNodes.size() == 1) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //对根节点下的所有临时顺序节点进行从小到大排序</span><br><span class="line">                Collections.sort(childrenNodes);</span><br><span class="line">                //当前节点名称</span><br><span class="line">                String thisNode = currentNode.substring((&quot;/&quot; +</span><br><span class="line">                        rootNode + &quot;/&quot;).length());</span><br><span class="line">                //获取当前节点的位置</span><br><span class="line">                int index = childrenNodes.indexOf(thisNode);</span><br><span class="line">                if (index == -1) &#123;</span><br><span class="line">                    System.out.println(&quot;数据异常&quot;);</span><br><span class="line">                &#125; else if (index == 0) &#123;</span><br><span class="line">                    // index == 0, 说明 thisNode 在列表中最小, 当前</span><br><span class="line">                    client 获得锁</span><br><span class="line">                    return;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 获得排名比 currentNode 前 1 位的节点</span><br><span class="line">                    this.waitPath = &quot;/&quot; + rootNode + &quot;/&quot; +</span><br><span class="line">                            childrenNodes.get(index - 1);</span><br><span class="line">                    // 在 waitPath 上注册监听器, 当 waitPath 被删除时,</span><br><span class="line">                    zookeeper 会回调监听器的 process 方法</span><br><span class="line">                    zk.getData(waitPath, true, new Stat());</span><br><span class="line">                    //进入等待锁状态</span><br><span class="line">                    waitLatch.await();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解锁方法</span><br><span class="line">    public void zkUnlock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            zk.delete(this.currentNode, -1);</span><br><span class="line">        &#125; catch (InterruptedException | KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）</strong>分布式锁测试  （</p><p>1）创建两个线程 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.lock2;</span><br><span class="line"></span><br><span class="line">import org.apache.zookeeper.KeeperException;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class DistributedLockTest &#123;</span><br><span class="line">    public static void main(String[] args) throws</span><br><span class="line">            InterruptedException, IOException, KeeperException &#123;</span><br><span class="line">        // 创建分布式锁 1</span><br><span class="line">        final DistributedLock lock1 = new DistributedLock();</span><br><span class="line">        // 创建分布式锁 2</span><br><span class="line">        final DistributedLock lock2 = new DistributedLock();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // 获取锁对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.zkLock();</span><br><span class="line">                    System.out.println(&quot;线程 1 获取锁&quot;);</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    lock1.zkUnlock();</span><br><span class="line">                    System.out.println(&quot;线程 1 释放锁&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // 获取锁对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.zkLock();</span><br><span class="line">                    System.out.println(&quot;线程 2 获取锁&quot;);</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    lock2.zkUnlock();</span><br><span class="line">                    System.out.println(&quot;线程 2 释放锁&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> （2）观察控制台变化：</p><p>线程 1 获取锁</p><p>线程 1 释放锁线程 2 获取锁线程 2 释放锁 </p><h2 id="5-2-Curator-框架实现分布式锁案例"><a href="#5-2-Curator-框架实现分布式锁案例" class="headerlink" title="5.2 Curator 框架实现分布式锁案例"></a><strong>5.2 Curator</strong> 框架实现分布式锁案例</h2><p><strong>1）</strong>原生的 <strong>Java API</strong> 开发存在的问题</p><p>（1）会话连接是异步的，需要自己去处理。比如使用 CountDownLatch</p><p>（2）Watch 需要重复注册，不然就不能生效</p><p>（3）开发的复杂性还是比较高的 </p><p>（4）不支持多节点删除和创建。需要自己去递归 </p><p><strong>2）****Curator</strong>是一个专门解决分布式锁的框架，解决了原生 <strong>Java API</strong>开发分布式遇到的问题。 </p><p>详情请查看官方文档：<a href="https://curator.apache.org/index.html[">https://curator.apache.org/index.html[</a> ](<a href="https://curator.apache.org/index.html">https://curator.apache.org/index.html</a>)</p><p><strong>3）****Curator</strong> 案例实操 </p><p>（1）添加依赖 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;4.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;4.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;curator-client&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;4.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>（2）代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.lock;</span><br><span class="line"></span><br><span class="line">import org.apache.curator.RetryPolicy;</span><br><span class="line">import org.apache.curator.framework.CuratorFramework;</span><br><span class="line">import org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line">import</span><br><span class="line">        org.apache.curator.framework.recipes.locks.InterProcessLock;</span><br><span class="line">import</span><br><span class="line">        org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line">import org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line">public class CuratorLockTest &#123;</span><br><span class="line">    private String rootNode = &quot;/locks&quot;;</span><br><span class="line"></span><br><span class="line">    // zookeeper server 列表</span><br><span class="line">    private String connectString =</span><br><span class="line">            &quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;;</span><br><span class="line">    // connection 超时时间</span><br><span class="line">    private int connectionTimeout = 2000;</span><br><span class="line">    // session 超时时间</span><br><span class="line">    private int sessionTimeout = 2000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new CuratorLockTest().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试</span><br><span class="line">    private void test() &#123;</span><br><span class="line">        // 创建分布式锁 1</span><br><span class="line">        final InterProcessLock lock1 = new</span><br><span class="line">                InterProcessMutex(getCuratorFramework(), rootNode);</span><br><span class="line">        // 创建分布式锁 2</span><br><span class="line">        final InterProcessLock lock2 = new</span><br><span class="line">                InterProcessMutex(getCuratorFramework(), rootNode);</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // 获取锁对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(&quot;线程 1 获取锁&quot;);</span><br><span class="line">                    // 测试锁重入</span><br><span class="line">                    lock1.acquire();</span><br><span class="line">                    System.out.println(&quot;线程 1 再次获取锁&quot;);</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(&quot;线程 1 释放锁&quot;);</span><br><span class="line">                    lock1.release();</span><br><span class="line">                    System.out.println(&quot;线程 1 再次释放锁&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // 获取锁对象</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.acquire();</span><br><span class="line">                    System.out.println(&quot;线程 2 获取锁&quot;);</span><br><span class="line">                    // 测试锁重入</span><br><span class="line">                    lock2.acquire();</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;线程 2 再次获取锁&quot;);</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    lock2.release();</span><br><span class="line">                    System.out.println(&quot;线程 2 释放锁&quot;);</span><br><span class="line">                    lock2.release();</span><br><span class="line">                    System.out.println(&quot;线程 2 再次释放锁&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 分布式锁初始化</span><br><span class="line">    public CuratorFramework getCuratorFramework() &#123;</span><br><span class="line">        //重试策略，初试时间 3 秒，重试 3 次</span><br><span class="line">        RetryPolicy policy = new ExponentialBackoffRetry(3000, 3);</span><br><span class="line">        //通过工厂创建 Curator</span><br><span class="line">        CuratorFramework client =</span><br><span class="line">                CuratorFrameworkFactory.builder()</span><br><span class="line">                        .connectString(connectString)</span><br><span class="line">                        .connectionTimeoutMs(connectionTimeout)</span><br><span class="line">                        .sessionTimeoutMs(sessionTimeout)</span><br><span class="line">                        .retryPolicy(policy).build();</span><br><span class="line">        //开启连接</span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(&quot;zookeeper 初始化完成...&quot;);</span><br><span class="line">        return client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> （2）观察控制台变化：</p><p>线程 1 获取锁 </p><p>线程 1 再次获取锁 </p><p>线程 1 释放锁 </p><p>线程 1 再次释放锁 </p><p>线程 2 获取锁 </p><p>线程 2 再次获取锁</p><p> 线程 2 释放锁 </p><p>线程 2 再次释放锁</p><h1 id="第-6-章-企业面试真题（面试重点）"><a href="#第-6-章-企业面试真题（面试重点）" class="headerlink" title="第 6 章 企业面试真题（面试重点）"></a>第 <strong>6</strong> 章 企业面试真题（面试重点）</h1><h2 id="6-1-选举机制"><a href="#6-1-选举机制" class="headerlink" title="6.1 选举机制"></a><strong>6.1</strong> 选举机制</h2><p> 半数机制，超过半数的投票通过，即通过。</p><p>（1）第一次启动选举规则： </p><p>​        投票过半数时，服务器 id 大的胜出 </p><p>（2）第二次启动选举规则： </p><p>​        ①EPOCH 大的直接胜出 </p><p>​        ②EPOCH 相同，事务 id 大的胜出 </p><p>​        ③事务 id 相同，服务器 id 大的胜出 </p><h2 id="6-2-生产集群安装多少-zk-合适？"><a href="#6-2-生产集群安装多少-zk-合适？" class="headerlink" title="6.2 生产集群安装多少 zk 合适？"></a><strong>6.2</strong> 生产集群安装多少 <strong>zk</strong> 合适？</h2><p>安装奇数台。</p><p>生产经验： </p><ul><li><p>  10 台服务器：3 台 zk； </p></li><li><p>  20 台服务器：5 台 zk； </p></li><li><p>  100 台服务器：11 台 zk； </p></li><li><p>  200 台服务器：11 台 zk </p></li></ul><p>服务器台数多：好处，提高可靠性；坏处：提高通信延时 </p><h2 id="6-3-常用命令"><a href="#6-3-常用命令" class="headerlink" title="6.3 常用命令"></a><strong>6.3</strong> 常用命令</h2><p>​    ls、get、create、delete</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;尚硅谷技术之 Zookeeper  &lt;/p&gt;
&lt;p&gt;（作者：尚硅谷研究院） &lt;/p&gt;
&lt;p&gt;版本：V3.3 &lt;/p&gt;
&lt;h1 id=&quot;第-1-章-Zookeeper-入门&quot;&gt;&lt;a href=&quot;#第-1-章-Zookeeper-入门&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 Zookeeper 入门&quot;&gt;&lt;/a&gt;第 &lt;strong&gt;1&lt;/strong&gt; 章 &lt;strong&gt;Zookeeper&lt;/strong&gt; 入门&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概述&quot;&gt;&lt;/a&gt;1.1 概述&lt;/h2&gt;&lt;p&gt;Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20221102/16673997206641.png&quot; alt=&quot;image-20221102223508155&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="hadoop" scheme="https://yangmour.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="https://yangmour.github.io/2022/10/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/linux+shell/shell/"/>
    <id>https://yangmour.github.io/2022/10/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/linux+shell/shell/</id>
    <published>2022-10-10T05:06:17.000Z</published>
    <updated>2022-10-09T04:45:06.764Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>尚硅谷高级技术之 Shell</p><h1 id="第-1-章-Shell-概述"><a href="#第-1-章-Shell-概述" class="headerlink" title="第 1 章 Shell 概述"></a>第 <strong>1</strong> 章 <strong>Shell</strong> 概述</h1><p><img src="https://image.3001.net/images/20221008/16652213272320.gif" alt="img"></p><span id="more"></span><h2 id="1）-Linux-提供的-Shell-解析器有"><a href="#1）-Linux-提供的-Shell-解析器有" class="headerlink" title="1）  Linux 提供的 Shell 解析器有"></a><strong>1）</strong>  <strong>Linux</strong> 提供的 <strong>Shell</strong> 解析器有</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ cat /etc/shells</span><br><span class="line"></span><br><span class="line">/bin/sh</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">/usr/bin/sh</span><br><span class="line"></span><br><span class="line">/usr/bin/bash</span><br><span class="line"></span><br><span class="line">/bin/tcsh</span><br><span class="line"></span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure><h2 id="2）-bash-和-sh-的关系"><a href="#2）-bash-和-sh-的关系" class="headerlink" title="2）  bash 和 sh 的关系"></a><strong>2）</strong>  <strong>bash</strong> 和 <strong>sh</strong> 的关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 bin]$ ll | grep bash -rwxr-xr-x. 1 root root 941880 5月 11 2016 bash lrwxrwxrwx. 1 root root  4 5月 27 2017 sh -&gt; bash</span><br></pre></td></tr></table></figure><h2 id="3）-Centos-默认的解析器是-bash"><a href="#3）-Centos-默认的解析器是-bash" class="headerlink" title="3）  Centos 默认的解析器是 bash"></a><strong>3）</strong>  <strong>Centos</strong> 默认的解析器是 <strong>bash</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 bin]$ echo $SHELL</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h1 id="第-2-章-Shell-脚本入门"><a href="#第-2-章-Shell-脚本入门" class="headerlink" title="第 2 章 Shell 脚本入门"></a>第 <strong>2</strong> 章 <strong>Shell</strong> 脚本入门</h1><h2 id="1）-脚本格式"><a href="#1）-脚本格式" class="headerlink" title="1）  脚本格式"></a><strong>1）</strong>  脚本格式</h2><p>脚本以#!/bin/bash 开头（指定解析器）</p><h2 id="2）-第一个-Shell-脚本：helloworld-sh"><a href="#2）-第一个-Shell-脚本：helloworld-sh" class="headerlink" title="2）  第一个 Shell 脚本：helloworld.sh"></a><strong>2）</strong>  第一个 <strong>Shell</strong> 脚本：<strong>helloworld.sh</strong></h2><p>（1）需求：创建一个 Shell 脚本，输出 helloworld</p><p>（2）案例实操：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch helloworld.sh  </span><br><span class="line">[atguigu@hadoop101 shells]$ vim helloworld.sh</span><br><span class="line"></span><br><span class="line">在helloworld.sh中输入如下内容 </span><br><span class="line">#!/bin/bash </span><br><span class="line">echo &quot;helloworld&quot;  </span><br></pre></td></tr></table></figure><h2 id="3）脚本的常用执行方式第一种：采用-bash-或-sh-脚本的相对路径或绝对路径（不用赋予脚本-x-权限）-sh-脚本的相对路径"><a href="#3）脚本的常用执行方式第一种：采用-bash-或-sh-脚本的相对路径或绝对路径（不用赋予脚本-x-权限）-sh-脚本的相对路径" class="headerlink" title="3）脚本的常用执行方式第一种：采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限） sh+脚本的相对路径"></a>3）脚本的常用执行方式第一种：采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限） sh+脚本的相对路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sh ./helloworld.sh Helloworld</span><br></pre></td></tr></table></figure><p>sh+脚本的绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sh /home/atguigu/shells/helloworld.sh </span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>bash+脚本的相对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>bash+脚本的绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash /home/atguigu/shells/helloworld.sh Helloworld</span><br></pre></td></tr></table></figure><p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p><p>①首先要赋予 helloworld.sh 脚本的+x 权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ chmod +x helloworld.sh</span><br></pre></td></tr></table></figure><p>②执行脚本相对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh Helloworld</span><br></pre></td></tr></table></figure><p>绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ /home/atguigu/shells/helloworld.sh Helloworld</span><br></pre></td></tr></table></figure><p>注意：第一种执行方法，本质是 bash 解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p><p>【了解】第三种：在脚本的路径前加上“.”或者 source</p><p>①有以下脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101  shells]$ cat test.sh  #!/bin/bash  A=5 echo $A  </span><br></pre></td></tr></table></figure><p>②分别使用 sh，bash，./ 和 . 的方式来执行，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash test.sh [atguigu@hadoop101 shells]$ echo $A</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ sh test.sh [atguigu@hadoop101 shells]$ echo $A</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ ./test.sh [atguigu@hadoop101 shells]$ echo $A</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ . test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A 5</span><br></pre></td></tr></table></figure><p>原因：前两种方式都是在当前 shell 中打开一个子 shell 来执行脚本内容，当脚本内容结束，则子 shell 关闭，回到父 shell 中。</p><p>第三种，也就是使用在脚本路径前加“.”或者 source 的方式，可以使脚本内容在当前</p><p>shell 里执行，而无需打开子 shell！这也是为什么我们每次要修改完/etc/profile 文件以后，需要 source 一下的原因。</p><p>开子 shell 与不开子 shell 的区别就在于，环境变量的继承关系，如在子 shell 中设置的当前变量，父 shell 是不可见的。第 <strong>3</strong> 章变量</p><h3 id="3-1-系统预定义变量"><a href="#3-1-系统预定义变量" class="headerlink" title="3.1 系统预定义变量"></a><strong>3.1</strong> 系统预定义变量</h3><p><strong>1）</strong>常用系统变量</p><p>$HOME、$PWD、$SHELL、$USER 等</p><p><strong>2）</strong>案例实操</p><p>（1）查看系统变量的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ echo $HOME</span><br><span class="line"></span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure><p>（2）显示当前 Shell 中所有变量：set</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ set</span><br><span class="line"></span><br><span class="line">BASH=/bin/bash</span><br><span class="line"></span><br><span class="line">BASH_ALIASES=()</span><br><span class="line"></span><br><span class="line">BASH_ARGC=()</span><br><span class="line"></span><br><span class="line">BASH_ARGV=()</span><br></pre></td></tr></table></figure><h3 id="3-2-自定义变量"><a href="#3-2-自定义变量" class="headerlink" title="3.2 自定义变量"></a><strong>3.2</strong> 自定义变量</h3><p><strong>1）</strong>  基本语法</p><p>（1）   定义变量：变量名=变量值，注意，=号前后不能有空格</p><p>（2）   撤销变量：unset 变量名</p><p>（3）   声明比那里变量：readonly 变量，注意：不能 unset</p><p><strong>2）</strong>  变量定义规则</p><p>（1）   变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。</p><p>（2）   等号两侧不能有空格</p><p>（3）   在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算。</p><p>（4）   变量的值如果有空格，需要使用双引号或单引号括起来。</p><p><strong>3）</strong>  案例实操</p><p>（1）   定义变量 A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ A=5</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line"></span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>（2）   给变量 A 重新赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ A=8</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line"></span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>（3）   撤销变量 A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ unset A</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br></pre></td></tr></table></figure><p>（4）   声明静态的变量 B=2，不能 unset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ readonly B=2</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ echo $B</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ B=9</span><br><span class="line"></span><br><span class="line">-bash: B: readonly variable</span><br></pre></td></tr></table></figure><p>（5）   在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 ~]$ C=1+2</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 ~]$ echo $C</span><br><span class="line"></span><br><span class="line">1+2</span><br></pre></td></tr></table></figure><p>（6）   变量的值如果有空格，需要使用双引号或单引号括起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 ~]$ D=I love banzhang</span><br><span class="line"></span><br><span class="line">-bash: world: command not found</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 ~]$ D=&quot;I love banzhang&quot;</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 ~]$ echo $D</span><br><span class="line"></span><br><span class="line">I love banzhang</span><br></pre></td></tr></table></figure><p>（7）可把变量提升为全局环境变量，可供其他 Shell 程序使用</p><p>export 变量名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim helloworld.</span><br><span class="line"></span><br><span class="line">在 helloworld.sh 文件中增加 echo $B</span><br><span class="line"></span><br><span class="line">\#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;helloworld&quot; echo $B [atguigu@hadoop101 shells]$ ./helloworld.sh Helloworld</span><br></pre></td></tr></table></figure><p>发现并没有打印输出变量 B 的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ export B</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line"></span><br><span class="line">helloworld 2</span><br></pre></td></tr></table></figure><h3 id="3-3-特殊变量"><a href="#3-3-特殊变量" class="headerlink" title="3.3 特殊变量"></a><strong>3.3</strong> 特殊变量</h3><h4 id="3-3-1-n"><a href="#3-3-1-n" class="headerlink" title="3.3.1 $n"></a>3.3.1 $n</h4><p><strong>1）</strong>  基本语法</p><p>$n （功能描述：n 为数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）</p><p><strong>2）</strong>  案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0 echo $1 echo $2</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh cls xz</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">cls xz</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-2"><a href="#3-3-2" class="headerlink" title="3.3.2 $#"></a>3.3.2 $#</h4><p><strong>1</strong>）基本语法</p><p>$# （功能描述：获取所有输入参数个数，常用于循环,判断参数的个数是否正确以及加强脚本的健壮性）。 <strong>2</strong>）案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0 echo $1 echo $2</span><br><span class="line">echo &#x27;==========$#==========&#x27; echo $#</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh cls xz</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">cls</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-3-、"><a href="#3-3-3-、" class="headerlink" title="3.3.3 $*、$@"></a>3.3.3 $*、$@</h4><p><strong>1）</strong>  基本语法</p><p>$* （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>$@ （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</p><p><strong>2）</strong>  案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0 echo $1 echo $2</span><br><span class="line">echo &#x27;==========$#==========&#x27; echo $#</span><br><span class="line">echo &#x27;==========$*==========&#x27; echo $*</span><br><span class="line">echo &#x27;==========$@==========&#x27;</span><br><span class="line">echo $@</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh a b c d e f g</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">a b</span><br><span class="line">==========$#==========</span><br><span class="line">7</span><br><span class="line">==========$*==========</span><br><span class="line">a b c d e f g</span><br><span class="line">==========$@==========</span><br><span class="line">a b c d e f g</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-4-？"><a href="#3-3-4-？" class="headerlink" title="3.3.4 $？"></a>3.3.4 $？</h4><p><strong>1）</strong>  基本语法</p><p>$？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</p><p><strong>2）</strong>  案例实操</p><p>判断 helloworld.sh 脚本是否正确执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh hello world</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h1 id="第-4-章运算符"><a href="#第-4-章运算符" class="headerlink" title="第 4 章运算符"></a>第 <strong>4</strong> 章运算符</h1><p><strong>1）</strong>  基本语法</p><p>“$((运算式))” 或 “$[运算式]”</p><p><strong>2）</strong>  案例实操：计算（2+3）* 4 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]# S=$[(2+3)*4]</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]# echo $S</span><br></pre></td></tr></table></figure><h1 id="第-5-章条件判断"><a href="#第-5-章条件判断" class="headerlink" title="第 5 章条件判断"></a>第 <strong>5</strong> 章条件判断</h1><p><strong>1）</strong>  基本语法</p><p>（1）test condition</p><p>（2）[ condition ]（注意 condition 前后要有空格）注意：条件非空即为 true，[ atguigu ]返回 true，[ ] 返回 false。</p><p><strong>2）</strong>  常用判断条件</p><p>（1）两个整数之间比较</p><p>​    -eq 等于（equal）   -ne 不等于（not equal）</p><p>​    -lt 小于（less than） -le 小于等于（less equal）</p><p>​    -gt 大于（greater than）  -ge 大于等于（greater equal）</p><p>注：如果是字符串之间的比较，用等号“=”判断相等；用“!=”判断不等。</p><p>（2）按照文件权限进行判断</p><p>-r 有读的权限（read）</p><p>-w  有写的权限（write）</p><p>-x  有执行的权限（execute）</p><p>（3）按照文件类型进行判断</p><p>-e  文件存在（existence）</p><p>-f  文件存在并且是一个常规的文件（file）</p><p>-d 文件存在并且是一个目录（directory）</p><p><strong>3）</strong>  案例实操</p><p>（1）23 是否大于等于 22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ 23 -ge 22 ] </span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line"></span><br><span class="line">0-</span><br></pre></td></tr></table></figure><p>（2）   helloworld.sh 是否具有写权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ -w helloworld.sh ] [atguigu@hadoop101 shells]$ echo $?</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>（3）   /home/atguigu/cls.txt 目录中的文件是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ -e /home/atguigu/cls.txt ] [atguigu@hadoop101 shells]$ echo $?</span><br><span class="line"></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>（4）   多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ [ atguigu ] &amp;&amp; echo OK || echo notOK</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ [ ] &amp;&amp; echo OK || echo notOK notOK</span><br></pre></td></tr></table></figure><h1 id="第-6-章流程控制（重点）"><a href="#第-6-章流程控制（重点）" class="headerlink" title="第 6 章流程控制（重点）"></a>第 <strong>6</strong> 章流程控制（重点）</h1><h2 id="6-1-if-判断"><a href="#6-1-if-判断" class="headerlink" title="6.1 if 判断"></a>6.1 if 判断</h2><p><strong>1）</strong>  基本语法</p><p>（1）单分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then 程序 fi</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ] then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>（2）多分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ] then</span><br><span class="line">程序</span><br><span class="line">elif [ 条件判断式 ] then</span><br><span class="line">程序 else</span><br><span class="line">程序</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项：</p><p>①[ 条件判断式 ]，中括号和条件判断式之间必须有空格</p><p>②if 后要有空格</p><p>③如果是只用一个中括号“[]”包括表达式不能写&amp;&amp;或者|| ，要写 -a 代表and或者 -o 代表or。注意看下图</p><p><img src="https://image.3001.net/images/20221008/16652213272377.jpg" alt="img"></p><p><strong>2）</strong>  案例实操</p><p>输入一个数字，如果是 1，则输出 banzhang zhen shuai，如果是 2，则输出 cls zhen mei，</p><p>如果是其它，什么也不输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch if.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim if.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">if [ $1 -eq 1 ]</span><br><span class="line">then echo &quot;banzhang zhen shuai&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then echo &quot;cls zhen mei&quot; fi</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 if.sh [atguigu@hadoop101 shells]$ ./if.sh 1 </span><br><span class="line">banzhang zhen shuai</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-2-case-语句"><a href="#6-2-case-语句" class="headerlink" title="6.2 case 语句"></a>6.2 case 语句</h2><p><strong>1）</strong>  基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;）</span><br><span class="line">如果变量的值等于值1，则执行程序1</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;）</span><br><span class="line">如果变量的值等于值2，则执行程序2</span><br><span class="line">;;</span><br><span class="line">…省略其他分支…</span><br><span class="line">*）</span><br><span class="line">如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">;; esac</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项：</p><p>（1）case 行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。</p><p>（2）双分号“**;;**”表示命令序列结束，相当于 java 中的 break。</p><p>（3）最后的“*）”表示默认模式，相当于 java 中的 default。</p><p><strong>2）</strong>  案例实操</p><p>输入一个数字，如果是 1，则输出 banzhang，如果是 2，则输出 cls，如果是其它，输出 renyao。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch case.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim case.sh</span><br><span class="line">!/bin/bash</span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;) echo &quot;banzhang&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;) echo &quot;cls&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;renyao&quot;</span><br><span class="line">;; esac</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 case.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./case.sh 1 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3-for-循环"><a href="#6-3-for-循环" class="headerlink" title="6.3 for 循环"></a>6.3 for 循环</h2><p><strong>1）</strong>  基本语法 <strong>1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 )) do</span><br><span class="line">程序 </span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2）</strong>  案例实操从 1 加到 100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for1.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for1.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">sum=0</span><br><span class="line">for((i=0;i&lt;=100;i++)) do sum=$[$sum+$i] done echo $sum</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for1.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for1.sh </span><br><span class="line">5050</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3）</strong>  基本语法 <strong>2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3… do</span><br><span class="line">程序</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4）</strong>  案例实操</p><p>（1）打印所有输入参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for2.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for2.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">打印数字</span></span><br><span class="line">for i in cls mly wls</span><br><span class="line">do echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for2.sh [atguigu@hadoop101 shells]$ ./for2.sh</span><br><span class="line">ban zhang love cls ban zhang love mly</span><br><span class="line">ban zhang love wls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）比较$*和$@区别</p><p>$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n 的形式输出所有参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for3.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for3.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &#x27;=============$*=============&#x27; for i in $*</span><br><span class="line">do echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line">echo &#x27;=============$@=============&#x27; for j in $@</span><br><span class="line">do echo &quot;ban zhang love $j&quot;</span><br><span class="line">done</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for3.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for3.sh cls mly wls</span><br><span class="line">=============$*=============</span><br><span class="line">banzhang love cls banzhang love mly banzhang love wls</span><br><span class="line">=============$@=============</span><br><span class="line">banzhang love cls banzhang love mly banzhang love wls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当它们被双引号“”包含时，$*会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输</p><p>出所有参数；$@会将各个参数分开，以“$1” “$2”…“$n”的形式输出所有参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim for4.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &#x27;=============$*=============&#x27; for i in &quot;$*&quot;</span><br><span class="line">#$*中的所有参数看成是一个整体，所以这个for循环只会循环一次 do echo &quot;ban zhang love $i&quot; done</span><br><span class="line">echo &#x27;=============$@=============&#x27; for j in &quot;$@&quot;</span><br><span class="line">#$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次 do echo &quot;ban zhang love $j&quot; done</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for4.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for4.sh cls mly wls</span><br><span class="line">=============$*============= banzhang love cls mly wls</span><br><span class="line">=============$@=============</span><br><span class="line">banzhang love cls banzhang love mly</span><br><span class="line">banzhang love wls</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-4-while-循环"><a href="#6-4-while-循环" class="headerlink" title="6.4 while 循环"></a>6.4 while 循环</h2><p><strong>1）</strong>  基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ] do</span><br><span class="line">程序</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2）</strong>  案例实操从 1 加到 100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch while.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim while.sh</span><br><span class="line">#!/bin/bash sum=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do sum=$[$sum+$i] i=$[$i+1] done echo $sum</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 while.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./while.sh 5050</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3）</strong>  shell的进阶版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim while.sh</span><br><span class="line">#!/bin/bash sum=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do </span><br><span class="line">#sum=$[$sum+$i] #i=$[$i+1] </span><br><span class="line">let sum+=$i</span><br><span class="line">let i++;</span><br><span class="line">done </span><br><span class="line">echo $sum</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 while.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./while.sh 5050</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第-7-章-read-读取控制台输入"><a href="#第-7-章-read-读取控制台输入" class="headerlink" title="第 7 章 read 读取控制台输入"></a>第 <strong>7</strong> 章 <strong>read</strong> 读取控制台输入</h1><p><strong>1）</strong>  基本语法</p><p>​    read  (选项)  (参数)</p><p>①选项：</p><p>-p：指定读取值时的提示符；</p><p>-t：指定读取值时等待的时间（秒）如果-t 不加表示一直等待</p><p>②参数变量：指定读取值的变量名</p><p><strong>2）</strong>  案例实操提示 7 秒内，读取控制台输入的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch read.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim read.sh #!/bin/bash</span><br><span class="line">read -t 7 -p &quot;Enter your name in 7 seconds :&quot; NN</span><br><span class="line">echo $NN</span><br><span class="line">[atguigu@hadoop101 shells]$ ./read.sh</span><br><span class="line">Enter your name in 7 seconds : atguigu atguigu</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第-8-章函数"><a href="#第-8-章函数" class="headerlink" title="第 8 章函数"></a>第 <strong>8</strong> 章函数</h1><h2 id="8-1-系统函数"><a href="#8-1-系统函数" class="headerlink" title="8.1 系统函数"></a>8.1 系统函数</h2><h3 id="8-1-1-basename"><a href="#8-1-1-basename" class="headerlink" title="8.1.1 basename"></a>8.1.1 basename</h3><p><strong>1）</strong>  基本语法</p><p>basename [string / pathname] [suffix] （功能描述：basename 命令会删掉所有的前</p><p>缀包括最后一个（‘/’）字符，然后将字符串显示出来。 basename 可以理解为取路径里的文件名称选项：</p><p>suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。</p><p><strong>2）</strong>  案例实操</p><p>截取该/home/atguigu/banzhang.txt 路径的文件名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ basename /home/atguigu/banzhang.txt banzhang.txt</span><br><span class="line">[atguigu@hadoop101 shells]$ basename /home/atguigu/banzhang.txt .txt banzhang</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-1-2-dirname"><a href="#8-1-2-dirname" class="headerlink" title="8.1.2 dirname"></a>8.1.2 dirname</h3><p><strong>1）</strong>  基本语法 dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名</p><p>（非目录的部分），然后返回剩下的路径（目录的部分）） dirname 可以理解为取文件路径的绝对路径名称</p><p><strong>2）</strong>  案例实操</p><p>获取 banzhang.txt 文件的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt</span><br><span class="line">/home/atguigu</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-2-自定义函数"><a href="#8-2-自定义函数" class="headerlink" title="8.2 自定义函数"></a>8.2 自定义函数</h2><p><strong>1）</strong>  基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">    Action;</span><br><span class="line">    [return int;] </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2）</strong>  经验技巧</p><p>（1）   必须在调用函数地方之前，先声明函数，shell 脚本是逐行运行。不会像其它语言一样先编译。</p><p>（2）   函数返回值，只能通过$?系统变量获得，可以显示加：return 返回，如果不加，将</p><p>以最后一条命令运行结果，作为返回值。return 后跟数值 n(0-255)</p><p><strong>3）</strong>  案例实操</p><p>计算两个输入参数的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch fun.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim fun.sh</span><br><span class="line">#!/bin/bash function sum()</span><br><span class="line">&#123; s=0 s=$[$1+$2] echo &quot;$s&quot;</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;Please input the number1: &quot; n1; read -p &quot;Please input the number2: &quot; n2; sum $n1 $n2;</span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 fun.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./fun.sh</span><br><span class="line">Please input the number1: 2</span><br><span class="line">Please input the number2: 5 </span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第-9-章正则表达式入门"><a href="#第-9-章正则表达式入门" class="headerlink" title="第 9 章正则表达式入门"></a>第 <strong>9</strong> 章正则表达式入门</h1><p>正则表达式使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。在很多文</p><p>本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。在 Linux 中，grep， sed，awk 等文本处理工具都支持通过正则表达式进行模式匹配。</p><h2 id="9-1-常规匹配"><a href="#9-1-常规匹配" class="headerlink" title="9.1 常规匹配"></a>9.1 常规匹配</h2><p>一串不包含特殊字符的正则表达式匹配它自己，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep atguigu</span><br></pre></td></tr></table></figure><p>就会匹配所有包含 atguigu 的行。</p><h2 id="9-2-常用特殊字符"><a href="#9-2-常用特殊字符" class="headerlink" title="9.2 常用特殊字符"></a>9.2 常用特殊字符</h2><p><strong>1）</strong>特殊字符：<strong>^</strong></p><p>^ 匹配一行的开头，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ^a</span><br></pre></td></tr></table></figure><p>会匹配出所有以 a 开头的行</p><p><strong>2）</strong>特殊字符：**$**</p><p>$ 匹配一行的结束，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep t$</span><br></pre></td></tr></table></figure><p>会匹配出所有以 t 结尾的行思考：<strong>^$</strong> 匹配什么？ <strong>3</strong>）特殊字符：**.**</p><p>. 匹配一个任意的字符，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep r..t</span><br></pre></td></tr></table></figure><p>会匹配包含 rabt,rbbt,rxdt,root 等的所有行</p><p><strong>4）</strong>特殊字符：*****</p><p>* 不单独使用，他和上一个字符连用，表示匹配上一个字符 0 次或多次，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ro*t</span><br></pre></td></tr></table></figure><p>会匹配 rt, rot, root, rooot, roooot 等所有行</p><p>思考：**.*** 匹配什么？</p><p><strong>5）</strong>字符区间（中括号）：**[ ]**</p><p>[ ] 表示匹配某个范围内的一个字符，例如</p><p>[6,8]——匹配 6 或者 8</p><p>[0-9]——匹配一个 0-9 的数字</p><p>[0-9]*——匹配任意长度的数字字符串</p><p>[a-z]——匹配一个 a-z 之间的字符</p><p>[a-z]* ——匹配任意长度的字母字符串</p><p>[a-c, e-f]-匹配 a-c 或者 e-f 之间的任意字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep r[a,b,c]*t</span><br></pre></td></tr></table></figure><p>会匹配 rt,rat, rbt, rabt, rbact,rabccbaaacbt 等等所有行</p><p><strong>6）</strong>特殊字符：\</p><p>\ 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要将转义字符和特殊字符连用，来表示特殊字符本身，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ‘a\$b’</span><br></pre></td></tr></table></figure><p>就会匹配所有包含 a$b 的行。注意需要使用单引号将表达式引起来。</p><p>7)正则表达式有需要在去看扩展文档，手机号匹配案例</p><p>re正则扩展写法需要加 -E，默认没有<code>&#123;&#125;</code>，有需要再去查看正则表达式文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ echo 13812345678 | grep -E ^1[34578][0-9]&#123;9&#125;$</span><br></pre></td></tr></table></figure><h1 id="第-10-章文本处理工具"><a href="#第-10-章文本处理工具" class="headerlink" title="第 10 章文本处理工具"></a>第 <strong>10</strong> 章文本处理工具</h1><h2 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h2><p>cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><p><strong>1）</strong>基本用法</p><p>​    cut  [选项参数]  filename</p><p>说明：默认分隔符是制表符</p><p><strong>2）</strong>选项参数说明</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>列号，提取第几列</td></tr><tr><td>-d</td><td>分隔符，按照指定分隔符分割列，默认是制表符“\t”</td></tr><tr><td>-c</td><td>按字符进行切割后加加 n 表示取第几列 比如 -c  1</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch cut.txt</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ vim cut.txt</span><br><span class="line"></span><br><span class="line">dong shen guan zhen wo wo lai lai le le</span><br></pre></td></tr></table></figure><p>（2）切割 cut.txt 第一列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cut -d &quot; &quot; -f 1 cut.txt</span><br><span class="line"></span><br><span class="line">dong guan wo lai le</span><br></pre></td></tr></table></figure><p>（3）切割 cut.txt 第二、三列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cut -d &quot; &quot; -f 2,3 cut.txt</span><br><span class="line"></span><br><span class="line">shen zhen wo lai le</span><br></pre></td></tr></table></figure><p>（4）在 cut.txt 文件中切割出 guan</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat cut.txt |grep guan | cut -d &quot; &quot; -f 1 guan</span><br></pre></td></tr></table></figure><p>（5）选取系统 PATH 变量值，第 2 个“：”开始后的所有路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ echo $PATH</span><br><span class="line"></span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/atguigu/.local/bin:/</span><br><span class="line"></span><br><span class="line">home/atguigu/bin</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ echo $PATH | cut -d &quot;:&quot; -f 3-</span><br><span class="line"></span><br><span class="line">/usr/local/sbin:/usr/sbin:/home/atguigu/.local/bin:/home/atguigu/bin</span><br></pre></td></tr></table></figure><p>（6）切割 ifconfig 后打印的 IP 地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig ens33 | grep netmask | cut -d &quot; &quot; -f 10</span><br><span class="line"></span><br><span class="line">192.168.111.101</span><br></pre></td></tr></table></figure><h2 id="10-2-awk"><a href="#10-2-awk" class="headerlink" title="10.2 awk"></a>10.2 awk</h2><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><p><strong>1）</strong>基本用法</p><p>​    awk   [选项参数] ‘/pattern1/{action1} /pattern2/{action2}…’ filename</p><p>pattern：表示 awk 在数据中查找的内容，就是匹配模式 action：在找到匹配内容时所执行的一系列命令</p><p><strong>2）</strong>选项参数说明</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件分隔符</td></tr><tr><td>-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）   数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sudo cp /etc/passwd ./ </span><br><span class="line"></span><br><span class="line">#passwd数据的含义</span><br><span class="line"></span><br><span class="line">#用户名:密码(加密过后的):用户id:组id:注释:用户家目录:shell解析器</span><br></pre></td></tr></table></figure><p>（2）   搜索 passwd 文件以 root 关键字开头的所有行，并输出该行的第 7 列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;/^root/&#123;print $7&#125;&#x27; passwd</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>（3）   搜索 passwd 文件以 root 关键字开头的所有行，并输出该行的第 1 列和第 7 列，中间以“，”号分割。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; passwd root,/bin/bash</span><br></pre></td></tr></table></figure><p>注意：只有匹配了 pattern 的行才会执行 action。</p><p>（4）   只显示/etc/passwd 的第一列和第七列，以逗号分割，且在所有行前面添加列名 user，</p><p>shell 在最后一行添加”dahaige，/bin/zuishuai”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101shells]$awk-F:&#x27;BEGIN&#123;print&quot;user,shell&quot;&#125;&#123;print$1&quot;,&quot;$7&#125;</span><br><span class="line">END&#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27; passwd user, shell root,/bin/bash</span><br><span class="line">bin,/sbin/nologin</span><br><span class="line">。。。</span><br><span class="line">atguigu,/bin/bash dahaige,/bin/zuishuai</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p><p>（5）   将 passwd 文件中的用户 id 增加数值 1 并输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -v i=1 -F : &#x27;&#123;print $3+i&#125;&#x27; passwd</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>4）****awk</strong> 的内置变量</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数（行号）</td></tr><tr><td>NF</td><td>浏览记录的域的个数（切割后，列的个数）</td></tr></tbody></table><p><strong>5）</strong>案例实操</p><p>（1）   统计 passwd 文件名，每行的行号，每行的列数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;&#123;print &quot;filename:&quot; FILENAME &quot;,linenum:&quot;</span><br><span class="line">NR &quot;,col:&quot;NF&#125;&#x27; passwd filename:passwd,linenum:1,col:7 filename:passwd,linenum:2,col:7 filename:passwd,linenum:3,col:7 ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）   查询 ifconfig 命令输出结果中的空行所在的行号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig | awk &#x27;/^$/&#123;print NR&#125;&#x27;</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">26</span><br></pre></td></tr></table></figure><p>（3）   切割 IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig ens33 | awk &#x27;/netmask/ &#123;print $2&#125;&#x27;</span><br><span class="line"></span><br><span class="line">192.168.6.101</span><br></pre></td></tr></table></figure><h2 id="10-3-sed"><a href="#10-3-sed" class="headerlink" title="10.3 sed"></a>10.3 sed</h2><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p><p>\1.   基本用法</p><p>sed [选项参数] ‘command’ filename</p><p>\2.   选项参数说明</p><p>表1-56</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>直接在指令列模式上进行sed的动作编辑。</td></tr></tbody></table><p>\3.   命令功能描述</p><p>表1-57</p><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td><em>a</em></td><td>新增，a的后面可以接字串，在下一行出现</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>s</td><td>查找并替换</td></tr></tbody></table><p>\4.   案例实操</p><p>（0）数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ touch sed.txt</span><br><span class="line">[atguigu@hadoop102 datas]$ vim sed.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）将“mei nv”这个单词插入到sed.txt第二行下，打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ sed &#x27;2a mei nv&#x27; sed.txt </span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">mei nv</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line">[atguigu@hadoop102 datas]$ cat sed.txt </span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：文件并没有改变</p><p>（2）删除sed.txt文件所有包含wo的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ sed &#x27;/wo/d&#x27; sed.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）将sed.txt文件中wo替换为ni</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ sed &#x27;s/wo/ni/g&#x27; sed.txt </span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">ni  ni</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：‘g’表示global，全部替换</p><p>（4）将sed.txt文件中的第二行删除并将wo替换为ni</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ sed -e &#x27;2d&#x27; -e &#x27;s/wo/ni/g&#x27; sed.txt </span><br><span class="line">dong shen</span><br><span class="line">ni  ni</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第-11-章综合应用案例"><a href="#第-11-章综合应用案例" class="headerlink" title="第 11 章综合应用案例"></a>第 <strong>11</strong> 章综合应用案例</h1><h2 id="11-1-归档文件"><a href="#11-1-归档文件" class="headerlink" title="11.1 归档文件"></a>11.1 归档文件</h2><p>实际生产应用中，往往需要对重要数据进行归档备份。</p><p>需求：实现一个每天对指定目录归档备份的脚本，输入一个目录名称（末尾不带/），将目录下所有文件按天归档保存，并将归档日期附加在归档文件名上，放在/root/archive 下。这里用到了归档命令：tar 后面可以加上-c 选项表示归档，加上-z 选项表示同时进行压缩，得到的文件后缀名为.tar.gz。</p><p>脚本实现如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先判断输入参数个数是否为1</span></span><br><span class="line">if [ $# -ne 1 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;参数个数错误！应该输入一个参数，作为归档目录名&quot; exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从参数中获取目录名称</span></span><br><span class="line">if [ -d $1 ]</span><br><span class="line">then echo else</span><br><span class="line">echo</span><br><span class="line">echo &quot;目录不存在！&quot;</span><br><span class="line">echo exit fi</span><br><span class="line">DIR_NAME=$(basename $1)</span><br><span class="line">DIR_PATH=$(cd $(dirname $1); pwd)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取当前日期</span></span><br><span class="line">DATE=$(date +%y%m%d)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义生成的归档文件名称</span></span><br><span class="line">FILE=archive_$&#123;DIR_NAME&#125;_$DATE.tar.gz</span><br><span class="line">DEST=/root/archive/$FILE</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始归档目录文件</span></span><br><span class="line">echo &quot;开始归档...&quot;</span><br><span class="line">echo tar -czf $DEST $DIR_PATH/$DIR_NAME</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then</span><br><span class="line">echo</span><br><span class="line">echo &quot;归档成功！&quot;</span><br><span class="line">echo &quot;归档文件为：$DEST&quot;</span><br><span class="line">echo</span><br><span class="line">else</span><br><span class="line">echo &quot;归档出现问题！&quot;</span><br><span class="line">echo fi exit</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-2-发送消息"><a href="#11-2-发送消息" class="headerlink" title="11.2 发送消息"></a>11.2 发送消息</h2><p>我们可以利用 Linux 自带的 mesg 和 write 工具，向其它用户发送消息。</p><p>需求：实现一个向某个用户快速发送消息的脚本，输入用户名作为第一个参数，后面直接跟要发送的消息。脚本需要检测用户是否登录在系统中、是否打开消息功能，以及当前发送消息是否为空。</p><p>脚本实现如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span> </span><br><span class="line">login_user=$(who | grep -i -m 1 $1 | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash">-z判断login_user为不为空</span></span><br><span class="line">if [ -z $login_user ] then</span><br><span class="line">echo &quot;$1 不在线！&quot;</span><br><span class="line">echo &quot;脚本退出..&quot;</span><br><span class="line">exit</span><br><span class="line">fi is_allowed=$(who -T | grep -i -m 1 $1 | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ $is_allowed != &quot;+&quot; ] then</span><br><span class="line">echo &quot;$1 没有开启消息功能&quot;</span><br><span class="line">echo &quot;脚本退出..&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line">if [ -z $2 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;没有消息发出&quot;</span><br><span class="line">echo &quot;脚本退出..&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line">whole_msg=$(echo $* | cut -d &quot; &quot; -f 2- ) user_terminal=$(who | grep -i -m 1 $1 | awk &#x27;&#123;print $2&#125;&#x27;) echo $whole_msg | write $login_user $user_terminal</span><br><span class="line">if [ $? != 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;发送失败！&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;发送成功！&quot;</span><br><span class="line">fi exit</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- more -->]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;尚硅谷高级技术之 Shell&lt;/p&gt;
&lt;h1 id=&quot;第-1-章-Shell-概述&quot;&gt;&lt;a href=&quot;#第-1-章-Shell-概述&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 Shell 概述&quot;&gt;&lt;/a&gt;第 &lt;strong&gt;1&lt;/strong&gt; 章 &lt;strong&gt;Shell&lt;/strong&gt; 概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20221008/16652213272320.gif&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux+shell" scheme="https://yangmour.github.io/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="https://yangmour.github.io/2022/10/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/linux+shell/linux/"/>
    <id>https://yangmour.github.io/2022/10/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/linux+shell/linux/</id>
    <published>2022-10-09T05:06:17.000Z</published>
    <updated>2022-10-09T04:44:59.413Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="尚硅谷高级技术之-Linux"><a href="#尚硅谷高级技术之-Linux" class="headerlink" title="尚硅谷高级技术之 Linux"></a>尚硅谷高级技术之 Linux</h1><h1 id="第-1-章-Linux-入门"><a href="#第-1-章-Linux-入门" class="headerlink" title="第 1 章 Linux 入门"></a>第 <strong>1</strong> 章 <strong>Linux</strong> 入门</h1><p><strong>1.1</strong> 概述如图 1-1 所示</p><p><img src="https://image.3001.net/images/20221009/16652816012747.jpg" alt="img"></p><span id="more"></span><p>图 1-1 Linux 概述 <strong>1.2 Linux</strong> 和 <strong>Windows</strong> 区别如图 1-2 所示</p><p><img src="https://image.3001.net/images/20221009/16652816013909.jpg" alt="img"></p><p>图 1-2 Linux 和 Windows 的区别</p><p><strong>1.3 CentOS</strong> 下载地址如图 1-3 所示</p><p><img src="https://image.3001.net/images/20221009/16652816011071.jpg" alt="img"></p><p>图 1-3 Centos 的下载地址</p><h1 id="第-2-章-VM-与-Linux-的安装"><a href="#第-2-章-VM-与-Linux-的安装" class="headerlink" title="第 2 章 VM 与 Linux 的安装"></a>第 <strong>2</strong> 章 <strong>VM</strong> 与 <strong>Linux</strong> 的安装</h1><p><strong>2.1 VMWare</strong> 安装</p><p><strong>2.2 CentOS</strong> 安装</p><p>安装 CentOS.docx</p><h1 id="第-3-章-Linux-文件与目录结构"><a href="#第-3-章-Linux-文件与目录结构" class="headerlink" title="第 3 章 Linux 文件与目录结构"></a>第 <strong>3</strong> 章 <strong>Linux</strong> 文件与目录结构</h1><h2 id="3-1-Linux-文件"><a href="#3-1-Linux-文件" class="headerlink" title="3.1 Linux 文件"></a><strong>3.1 Linux</strong> 文件</h2><p>Linux 系统中一切皆文件。</p><p> <strong>3.2 Linux</strong> 目录结构如图 3-1 所示</p><p><img src="https://image.3001.net/images/20221009/1665281602523.jpg" alt="img"></p><p>图 3-1 Linux 目录结构 Linux 目录结构简介，如图 3-2，3-3，3-4，3-5，3-6 所示</p><p><img src="https://image.3001.net/images/20221009/1665281602860.jpg" alt="img"></p><p>图 3-2 Linux 目录结构</p><p><img src="https://image.3001.net/images/20221009/16652816013051.jpg" alt="img"></p><p>图 3-3 Linux 目录结构</p><p><img src="https://image.3001.net/images/20221009/16652816026459.jpg" alt="img"></p><p>图 3-4 Linux 目录结构</p><p><img src="https://image.3001.net/images/20221009/16652816024434.jpg" alt="img"></p><p>图 3-5 Linux 目录结构</p><p><img src="https://image.3001.net/images/20221009/16652816014040.jpg" alt="img"></p><p>图 3-6 Linux 目录结构</p><h1 id="第-4-章-VI-VIM-编辑器（重要）"><a href="#第-4-章-VI-VIM-编辑器（重要）" class="headerlink" title="第 4 章 VI/VIM 编辑器（重要）"></a>第 <strong>4</strong> 章 <strong>VI/VIM</strong> 编辑器（重要）</h1><h2 id="4-1-是什么"><a href="#4-1-是什么" class="headerlink" title="4.1 是什么"></a><strong>4.1</strong> 是什么</h2><p>VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。</p><p>VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容。</p><h2 id="4-2-测试数据准备"><a href="#4-2-测试数据准备" class="headerlink" title="4.2 测试数据准备"></a><strong>4.2</strong> 测试数据准备</h2><h4 id="1）拷贝-etc-profile-数据到-root-目录下"><a href="#1）拷贝-etc-profile-数据到-root-目录下" class="headerlink" title="1）拷贝**/etc/profile** 数据到**/root** 目录下"></a><strong>1</strong>）拷贝**/etc/profile** 数据到**/root** 目录下</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# cp /etc/profile /root</span><br><span class="line"></span><br><span class="line">[root@hadoop100 桌面]# cd /root/</span><br></pre></td></tr></table></figure><h2 id="4-3-一般模式"><a href="#4-3-一般模式" class="headerlink" title="4.3 一般模式"></a><strong>4.3</strong> 一般模式</h2><p>以 vi 打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。</p><p>表 4-1常用语法</p><table><thead><tr><th>语法</th><th>功能描述</th></tr></thead><tbody><tr><td>yy</td><td>复制光标当前一行</td></tr><tr><td>y 数字 y</td><td>复制一段（从第几行到第几行）</td></tr><tr><td>p</td><td>箭头移动到目的行粘贴</td></tr><tr><td>u</td><td>撤销上一步</td></tr><tr><td>dd</td><td>删除光标当前行</td></tr><tr><td>d 数字 d</td><td>删除光标（含）后多少行</td></tr><tr><td>x</td><td>剪切一个字母，相当于 del</td></tr><tr><td>X</td><td>剪切一个字母，相当于 Backspace</td></tr><tr><td>yw</td><td>复制一个词</td></tr><tr><td>dw</td><td>删除一个词</td></tr><tr><td>shift+6（^）</td><td>移动到行头</td></tr><tr><td>shift+4 （$）</td><td>移动到行尾</td></tr><tr><td>1+shift+g</td><td>移动到页头，数字</td></tr><tr><td>shift+g</td><td>移动到页尾</td></tr><tr><td>数字+shift+g</td><td>移动到目标行</td></tr></tbody></table><p>vi/vim 键盘图，如 4-1 所示</p><p><img src="https://image.3001.net/images/20221009/16652816023087.jpg" alt="img"></p><p>图 4-1 vi/vim 键盘图</p><h2 id="4-4-编辑模式"><a href="#4-4-编辑模式" class="headerlink" title="4.4 编辑模式"></a><strong>4.4</strong> 编辑模式</h2><p>在一般模式中可以进行删除、复制、粘贴等的动作，但是却无法编辑文件内容的！要等到你按下『i, I, o, O, a, A』等任何一个字母之后才会进入编辑模式。</p><p>注意了！通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或</p><p>REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时，则必须要按下</p><p>『Esc』这个按键即可退出编辑模式。</p><p><strong>1）</strong>进入编辑模式</p><p>表4-2 常用语法</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>当前光标前</td></tr><tr><td>a</td><td>当前光标后</td></tr><tr><td>o</td><td>当前光标行的下一行</td></tr><tr><td>I</td><td>光标所在行最前</td></tr><tr><td>A</td><td>光标所在行最后</td></tr><tr><td>O</td><td>当前光标行的上一行</td></tr></tbody></table><p><strong>2）</strong>退出编辑模式</p><p>按『Esc』键退出编辑模式，之后所在的模式为一般模式。</p><h2 id="4-5-指令模式"><a href="#4-5-指令模式" class="headerlink" title="4.5 指令模式"></a><strong>4.5</strong> 指令模式</h2><p>在一般模式当中，输入『 : / ?』3个中的任何一个按钮，就可以将光标移动到最底下那一行。</p><p>在这个模式当中，可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、</p><p>离开 vi 、显示行号等动作是在此模式中达成的！</p><p><strong>1）</strong>基本语法</p><p>表4-3</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:!</td><td>强制执行</td></tr><tr><td>/要查找的词</td><td>n 查找下一个，N 往上查找</td></tr><tr><td>:noh</td><td>取消高亮显示</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>关闭行号</td></tr><tr><td>:%s/old/new/g</td><td>替换内容 /g 替换匹配到的所有内容</td></tr></tbody></table><p><strong>2）</strong>案例实操</p><p>（1）强制保存退出</p><p>:wq!</p><p><strong>4.6</strong> 模式间转换如图 4-2 所示。</p><p><img src="https://image.3001.net/images/20221009/16652816023038.jpg" alt="img"></p><p>图 4-2 模式间的转换</p><h1 id="第-5-章网络配置（重点）"><a href="#第-5-章网络配置（重点）" class="headerlink" title="第 5 章网络配置（重点）"></a>第 <strong>5</strong> 章网络配置（重点）</h1><h2 id="5-1-查看网络-IP-和网关"><a href="#5-1-查看网络-IP-和网关" class="headerlink" title="5.1 查看网络 IP 和网关"></a><strong>5.1</strong> 查看网络 <strong>IP</strong> 和网关</h2><p><strong>1）</strong>查看虚拟网络编辑器，如图 <strong>5-1</strong> 所示</p><p><img src="https://image.3001.net/images/20221009/16652816018695.jpg" alt="img"></p><p>图 5-1 查看虚拟网络编辑器</p><p><strong>2）</strong>修改虚拟网卡 <strong>Ip</strong>，如图 <strong>5-2</strong> 所示</p><p><img src="https://image.3001.net/images/20221009/16652816026312.jpg" alt="img"></p><p>图 5-2 修改虚拟网卡 ip</p><p><strong>3）</strong>查看网关，如图 <strong>5-3</strong> 所示</p><p><img src="https://image.3001.net/images/20221009/16652816011954.jpg" alt="img"></p><p>图 5-3 查看网关</p><h4 id="4）查看-windows-环境的中-VMnet8-网络配置，如图-5-4-所示"><a href="#4）查看-windows-环境的中-VMnet8-网络配置，如图-5-4-所示" class="headerlink" title="4）查看 windows 环境的中 VMnet8 网络配置，如图 5-4 所示"></a><strong>4</strong>）查看 <strong>windows</strong> 环境的中 <strong>VMnet8</strong> 网络配置，如图 <strong>5-4</strong> 所示</h4><p><img src="https://image.3001.net/images/20221009/16652816022782.jpg" alt="img"></p><p>图 5-4 windows 中 VMnet8 网络配置</p><h2 id="5-2-配置网络-ip-地址"><a href="#5-2-配置网络-ip-地址" class="headerlink" title="5.2 配置网络 ip 地址"></a><strong>5.2</strong> 配置网络 <strong>ip</strong> 地址</h2><h3 id="5-2-1-ifconfig-配置网络接口"><a href="#5-2-1-ifconfig-配置网络接口" class="headerlink" title="5.2.1 ifconfig 配置网络接口"></a><strong>5.2.1 ifconfig</strong> 配置网络接口</h3><p>ifconfig :network interfaces configuring 网络接口配置</p><p><strong>1）</strong>基本语法ifconfig  （功能描述：显示所有网络接口的配置信息）</p><p><strong>2）</strong>案例实操</p><p>（1）查看当前网络 ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# ifconfig</span><br></pre></td></tr></table></figure><h3 id="5-2-2-ping-测试主机之间网络连通性"><a href="#5-2-2-ping-测试主机之间网络连通性" class="headerlink" title="5.2.2 ping 测试主机之间网络连通性"></a><strong>5.2.2 ping</strong> 测试主机之间网络连通性</h3><p><strong>1）</strong>  基本语法 ping 目的主机  （功能描述：测试当前服务器是否可以连接目的主机）</p><p><strong>2）</strong>  案例实操</p><p>（1）测试当前服务器是否可以连接百度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# ping [www.baidu.com](http://www.baidu.com/)</span><br></pre></td></tr></table></figure><h3 id="5-2-3-修改-IP-地址"><a href="#5-2-3-修改-IP-地址" class="headerlink" title="5.2.3 修改 IP 地址"></a><strong>5.2.3</strong> 修改 <strong>IP</strong> 地址</h3><p><strong>1</strong>）查看 <strong>IP</strong> 配置文件，如图 <strong>5-5</strong> 所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20221009/16652816019998.jpg" alt="img"></p><p>图 5-5 查看 IP 配置文件</p><p>以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;#网络类型（通常是Ethemet）</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;#IP 的配置方法[none|static|bootp|dhcp]（引导时不 使用协议|静态分配IP|BOOTP协议|DHCP协议）</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;e83804c1-3257-4584-81bb-660665ac22f6&quot;#随机id</span><br><span class="line">DEVICE=&quot;ens33&quot;#接口名（设备,网卡）</span><br><span class="line">ONBOOT=&quot;yes&quot;#系统启动的时候网络接口是否有效（yes/no）</span><br><span class="line">#IP地址</span><br><span class="line">IPADDR=192.168.1.100</span><br><span class="line">#网关</span><br><span class="line">GATEWAY=192.168.1.2</span><br><span class="line">#域名解析器</span><br><span class="line">DNS1=192.168.1.2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后，如图 5-6 所示</p><p><img src="https://image.3001.net/images/20221009/16652816018800.jpg" alt="img"></p><p>图 5-6 IP 修改后</p><p>编辑完后，按键盘 esc ，然后输入 :wq 回车即可。</p><p><strong>2</strong>）执行<strong>service network restar t</strong> 重启网络,如图 5-7 所示</p><p><img src="https://image.3001.net/images/20221009/16652816021162.jpg" alt="img"></p><p>图 5-7 重启网络</p><h3 id="5-2-4-修改-IP-地址后可能会遇到的问题"><a href="#5-2-4-修改-IP-地址后可能会遇到的问题" class="headerlink" title="5.2.4 修改 IP 地址后可能会遇到的问题"></a><strong>5.2.4</strong> 修改 <strong>IP</strong> 地址后可能会遇到的问题</h3><p>（1） 物理机能ping通虚拟机，但是虚拟机ping不通物理机,一般都是因为物理机的防火墙问题,把防火墙关闭就行</p><p>（2） 虚拟机能Ping通物理机,但是虚拟机Ping不通外网,一般都是因为DNS的设置有问题</p><p>（3） 虚拟机Ping <a href="http://www.baidu.com/">www.baidu.com</a> 显示域名未知等信息,一般查看GATEWAY和DNS设</p><p>置是否正确</p><p>（4） 如果以上全部设置完还是不行，需要关闭NetworkManager服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager 关闭</span><br><span class="line"></span><br><span class="line">systemctl disable NetworkManager 禁用</span><br></pre></td></tr></table></figure><p>（5）如果检查发现 systemctl status network 有问题 需要检查ifcfg-ens33</p><h2 id="5-3-配置主机名"><a href="#5-3-配置主机名" class="headerlink" title="5.3 配置主机名"></a><strong>5.3</strong> 配置主机名</h2><h3 id="5-3-1-修改主机名称"><a href="#5-3-1-修改主机名称" class="headerlink" title="5.3.1 修改主机名称"></a><strong>5.3.1</strong> 修改主机名称</h3><p><strong>1）</strong> 基本语法 hostname    （功能描述：查看当前服务器的主机名称）</p><p><strong>2）</strong> 案例实操</p><p>（1）查看当前服务器主机名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# hostname</span><br></pre></td></tr></table></figure><p>（2）如果感觉此主机名不合适，我们可以进行修改。通过编辑/etc/hostname 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# vi /etc/hostname</span><br></pre></td></tr></table></figure><p>修改完成后重启生效。</p><p>(3).实时生效的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname hadoop100</span><br></pre></td></tr></table></figure><h3 id="5-3-2-修改-hosts-映射文件"><a href="#5-3-2-修改-hosts-映射文件" class="headerlink" title="5.3.2 修改 hosts 映射文件"></a><strong>5.3.2</strong> 修改 <strong>hosts</strong> 映射文件</h3><p><strong>1）</strong>  修改 linux 的主机映射文件（hosts 文件）后续在 hadoop 阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置，比较简单方便。不用刻意记 ip 地址。</p><p>（1）打开/etc/hosts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# vim /etc/hosts</span><br></pre></td></tr></table></figure><p>添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.100 hadoop100</span><br><span class="line">192.168.2.101 hadoop101</span><br><span class="line">192.168.2.102 hadoop102</span><br><span class="line">192.168.2.103 hadoop103</span><br><span class="line">192.168.2.104 hadoop104</span><br><span class="line">192.168.2.105 hadoop105</span><br></pre></td></tr></table></figure><p>（2）重启设备，重启后，查看主机名，已经修改成功</p><p><strong>2）</strong>  修改 windows 的主机映射文件（hosts 文件）</p><p>（1）进入 C:\Windows\System32\drivers\etc 路径</p><p>（2）打开 hosts 文件并添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.100 hadoop100</span><br><span class="line">192.168.2.101 hadoop101</span><br><span class="line">192.168.2.102 hadoop102</span><br><span class="line">192.168.2.103 hadoop103</span><br><span class="line">192.168.2.104 hadoop104</span><br><span class="line">192.168.2.105 hadoop105</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3）</strong>  修改 window10 的主机映射文件（hosts 文件）</p><p>（1）进入 C:\Windows\System32\drivers\etc 路径</p><p>（2）拷贝 hosts 文件到桌面</p><p>（3）打开桌面 hosts 文件并添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.100 hadoop100</span><br><span class="line">192.168.2.101 hadoop101</span><br><span class="line">192.168.2.102 hadoop102</span><br><span class="line">192.168.2.103 hadoop103</span><br><span class="line">192.168.2.104 hadoop104</span><br><span class="line">192.168.2.105 hadoop105</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（4）将桌面 hosts 文件覆盖 C:\Windows\System32\drivers\etc 路径 hosts 文件</p><h2 id="5-4-远程登录"><a href="#5-4-远程登录" class="headerlink" title="5.4 远程登录"></a><strong>5.4</strong> 远程登录</h2><p>通常在工作过程中，公司中使用的真实服务器或者是云服务器，都不允许除运维人员之外的员工直接接触，因此就需要通过远程登录的方式来操作。所以，远程登录工具就是</p><p>必不可缺的，目前，比较主流的有 Xshell, SSH Secure Shell, SecureCRT,FinalShell 等，同学</p><p>们可以根据自己的习惯自行选择. </p><h1 id="第-6-章系统管理"><a href="#第-6-章系统管理" class="headerlink" title="第 6 章系统管理"></a>第 <strong>6</strong> 章系统管理</h1><h2 id="6-1-Linux-中的进程和服务"><a href="#6-1-Linux-中的进程和服务" class="headerlink" title="6.1 Linux 中的进程和服务"></a><strong>6.1 Linux</strong> 中的进程和服务</h2><p>计算机中，一个正在执行的程序或命令，被叫做“进程”（process）。启动之后一只存在、常驻内存的进程，一般被称作“服务”（service）。</p><h2 id="6-2-service-服务管理（CentOS-6-版本-了解）"><a href="#6-2-service-服务管理（CentOS-6-版本-了解）" class="headerlink" title="6.2 service 服务管理（CentOS 6 版本**-**了解）"></a><strong>6.2 service</strong> 服务管理（<strong>CentOS 6</strong> 版本**-**了解）</h2><p><strong>1）</strong> 基本语法</p><p>service 服务名 start | stop |· restart | status</p><p><strong>2）</strong> 经验技巧</p><p>查看服务的方法：/etc/init.d/服务名 ,发现只有两个服务保留在 service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100init.d]#pwd</span><br><span class="line">/etc/init.d</span><br><span class="line">[root@hadoop100init.d]#ls -al</span><br><span class="line">drwxr-xr-x. 2rootroot40963月19 15:24 .</span><br><span class="line">drwxr-xr-x. 10rootroot40963月19 15:24 ..</span><br><span class="line">-rw-r--r--. 1rootroot181041月3 2018 functions</span><br><span class="line">-rwxr-xr-x. 1rootroot43341月3 2018 netconsole</span><br><span class="line">-rwxr-xr-x. 1rootroot72931月3 2018 network</span><br><span class="line">-rw-r--r--. 1rootroot11604月11 2018 README</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3）</strong> 案例实操</p><p>（1）查看网络服务的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]#service network status</span><br></pre></td></tr></table></figure><p>（2）停止网络服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]#service network stop</span><br></pre></td></tr></table></figure><p>（3）启动网络服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]#service network start</span><br></pre></td></tr></table></figure><p>（4）重启网络服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]#service network restart</span><br></pre></td></tr></table></figure><h2 id="6-3-chkconfig-设置后台服务的自启配置（CentOS-6-版本）"><a href="#6-3-chkconfig-设置后台服务的自启配置（CentOS-6-版本）" class="headerlink" title="6.3 chkconfig 设置后台服务的自启配置（CentOS 6 版本）"></a><strong>6.3 chkconfig</strong> 设置后台服务的自启配置（<strong>CentOS 6</strong> 版本）</h2><p><strong>1）</strong> 基本语法 chkconfig （功能描述：查看所有服务器自启配置）</p><p>chkconfig 服务名 off （功能描述：关掉指定服务的自动启动） chkconfig 服务名 on （功能描述：开启指定服务的自动启动） chkconfig 服务名 –list （功能描述：查看服务开机启动状态）</p><p><strong>2）</strong> 案例实操</p><p>（1）开启/关闭 network(网络)服务的自动启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]#chkconfig network on</span><br><span class="line">[root@hadoop100 桌面]#chkconfig network off</span><br></pre></td></tr></table></figure><p>（2）开启/关闭 network 服务指定级别的自动启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]#chkconfig --level 指定级别 network on</span><br><span class="line">[root@hadoop100 桌面]#chkconfig --level 指定级别 network off</span><br></pre></td></tr></table></figure><h2 id="6-4-systemctl-（CentOS-7-版本-重点掌握）"><a href="#6-4-systemctl-（CentOS-7-版本-重点掌握）" class="headerlink" title="6.4 systemctl （CentOS 7 版本**-**重点掌握）"></a><strong>6.4 systemctl</strong> （<strong>CentOS 7</strong> 版本**-**重点掌握）</h2><p><strong>1）</strong> 基本语法</p><p>​    systemctl start | stop | restart | status    服务名</p><p><strong>2）</strong> 经验技巧</p><p>查看服务的方法：/usr/lib/systemd/system</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 system]# pwd</span><br><span class="line">/usr/lib/systemd/system</span><br><span class="line">[root@hadoop100 init.d]# ls -al</span><br><span class="line">-rw-r--r--. 1 root root 275 4月</span><br><span class="line">-rw-r--r--.1rootroot380 4月</span><br><span class="line">-rw-r--r--.1rootroot361 4月</span><br><span class="line">-rw-r--r--.1rootroot266 4月</span><br><span class="line">-rw-r--r--.1rootroot262 4月</span><br><span class="line">-rw-r--r--.1rootroot311 4月</span><br><span class="line">-rw-r--r--.1rootroot751 4月</span><br><span class="line">-rw-r--r--.1rootroot527 3月</span><br><span class="line">-rw-r--r--.</span><br><span class="line">……1rootroot486 3月</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3）</strong> 案例实操</p><p>（1）查看防火墙服务的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# systemctl status firewalld</span><br></pre></td></tr></table></figure><p>（2）停止防火墙服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>（3）启动防火墙服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# systemctl start firewalld</span><br></pre></td></tr></table></figure><p>（4）重启防火墙服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="6-5-systemctl-设置后台服务的自启配置"><a href="#6-5-systemctl-设置后台服务的自启配置" class="headerlink" title="6.5 systemctl 设置后台服务的自启配置"></a><strong>6.5 systemctl</strong> 设置后台服务的自启配置</h2><p><strong>1）</strong>  基本语法</p><p>systemctl list-unit-files （功能描述：查看服务开机启动状态） systemctl disable service_name （功能描述：关掉指定服务的自动启动） systemctl enable service_name （功能描述：开启指定服务的自动启动）</p><p><strong>2）</strong>  案例实操</p><p>（1）开启/关闭 iptables(防火墙)服务的自动启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 桌面]# systemctl enable firewalld.service</span><br><span class="line"></span><br><span class="line">[root@hadoop100 桌面]# systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><h2 id="6-6-系统运行级别"><a href="#6-6-系统运行级别" class="headerlink" title="6.6 系统运行级别"></a><strong>6.6</strong> 系统运行级别</h2><h3 id="1）Linux-运行级别-CentOS-6-，如图-7-1-所示"><a href="#1）Linux-运行级别-CentOS-6-，如图-7-1-所示" class="headerlink" title="1）Linux 运行级别**[CentOS 6]**，如图 7-1 所示"></a><strong>1</strong>）<strong>Linux</strong> 运行级别**[CentOS 6]**，如图 <strong>7-1</strong> 所示</h3><p><img src="https://image.3001.net/images/20221009/16652816025839.jpg" alt="img"></p><p>图 6-1 Linux进程运行级别</p><h3 id="2）-CentOS7-的运行级别简化为"><a href="#2）-CentOS7-的运行级别简化为" class="headerlink" title="2） CentOS7 的运行级别简化为**:**"></a><strong>2）</strong> <strong>CentOS7</strong> 的运行级别简化为**:**</h3><p>multi-user.target 等价于原运行级别 3（多用户有网，无图形界面） graphical.target 等价于原运行级别 5（多用户有网，有图形界面）</p><h3 id="3）-查看当前运行级别"><a href="#3）-查看当前运行级别" class="headerlink" title="3） 查看当前运行级别**:**"></a><strong>3）</strong> 查看当前运行级别**:**</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></table></figure><h3 id="4）-修改当前运行级别"><a href="#4）-修改当前运行级别" class="headerlink" title="4） 修改当前运行级别"></a><strong>4）</strong> 修改当前运行级别</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default TARGET.target #1.（这里 TARGET 取 multi-user 或者 graphical）</span><br><span class="line"></span><br><span class="line">init 3/5 #2.(这里3代表命令行模式/5代表图形模式)</span><br></pre></td></tr></table></figure><h2 id="6-7-关闭防火墙"><a href="#6-7-关闭防火墙" class="headerlink" title="6.7 关闭防火墙"></a><strong>6.7</strong> 关闭防火墙</h2><p><strong>1）</strong> 临时关闭防火墙</p><p>（1）查看防火墙状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]# systemctl status firewalld</span><br></pre></td></tr></table></figure><p>（2）临时关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]# systemctl stop firewalld</span><br></pre></td></tr></table></figure><p><strong>2）</strong> 开机启动时关闭防火墙</p><p>（1）查看防火墙开机启动状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]# systemctl enable firewalld.service</span><br></pre></td></tr></table></figure><p>（2）设置开机时关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]# systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><h3 id="6-8-关机重启命令"><a href="#6-8-关机重启命令" class="headerlink" title="6.8 关机重启命令"></a><strong>6.8</strong> 关机重启命令</h3><p>在 linux 领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p><strong>1）</strong> 基本语法</p><p>（1）sync （功能描述：将数据由内存同步到硬盘中）</p><p>（2）halt （功能描述：停机，关闭系统，但不断电）</p><p>（3）poweroff （功能描述：关机，断电）</p><p>（3）reboot  （功能描述：就是重启，等同于 shutdown -r now）</p><p>（4）shutdown [选项] 时间</p><p>表 6-1</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-H</td><td>相当于–halt，停机</td></tr><tr><td>-r</td><td>-r=reboot  重启</td></tr></tbody></table><p>表 6-2</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>now</td><td>立刻关机</td></tr><tr><td>时间</td><td>等待多久后关机（时间单位是分钟）。</td></tr></tbody></table><p><strong>2）</strong> 经验技巧</p><p>Linux 系统中为了提高磁盘的读写效率，对磁盘采取了 “预读迟写”操作方式。当用户保存文件时，Linux 核心并不一定立即将保存数据写入物理磁盘中，而是将数据保存在缓冲区中，等缓冲区满时再写入磁盘，这种方式可以极大的提高磁盘写入数据的效率。但是，也带来了安全隐患，如果数据还未写入磁盘时，系统掉电或者其他严重问题出现，则将导</p><p>致数据丢失。使用 sync 指令可以立即将缓冲区的数据写入磁盘。</p><p><strong>3）</strong> 案例实操</p><p>（1）将数据由内存同步到硬盘中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]#sync</span><br></pre></td></tr></table></figure><p>（2）重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]# reboot</span><br></pre></td></tr></table></figure><p>（3）停机（不断电）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]#halt</span><br></pre></td></tr></table></figure><p>（4）计算机将在 1 分钟后关机，并且会显示在登录用户的当前屏幕中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]#shutdown -h 1 ‘This server will shutdown after 1 mins’</span><br></pre></td></tr></table></figure><p>（5）立马关机（等同于 poweroff）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]# shutdown -h now</span><br></pre></td></tr></table></figure><p>（6）系统立马重启（等同于 reboot）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100桌面]# shutdown -r now</span><br></pre></td></tr></table></figure><h1 id="第-7-章常用基本命令（重要）"><a href="#第-7-章常用基本命令（重要）" class="headerlink" title="第 7 章常用基本命令（重要）"></a>第 <strong>7</strong> 章常用基本命令（重要）</h1><p>Shell 可以看作是一个命令解释器，为我们提供了交互式的文本控制台界面。我们可以通过终端控制台来输入命令，由 shell 进行解释并最终交给内核执行。本章就将分类介绍常用的基本 shell 命令。</p><h2 id="7-1-帮助命令"><a href="#7-1-帮助命令" class="headerlink" title="7.1 帮助命令"></a><strong>7.1</strong> 帮助命令</h2><p><strong>7.1.1 man</strong> 获得帮助信息</p><p><strong>1）</strong>  基本语法</p><p>​    man [命令或配置文件] （功能描述：获得帮助信息）</p><p><strong>2）</strong>  显示说明</p><p>表 7-1</p><table><thead><tr><th>信息</th><th>功能</th></tr></thead><tbody><tr><td>NAME</td><td>命令的名称和单行描述</td></tr><tr><td>SYNOPSIS</td><td>怎样使用命令</td></tr><tr><td>DESCRIPTION</td><td>命令功能的深入讨论</td></tr><tr><td>EXAMPLES</td><td>怎样使用命令的例子</td></tr><tr><td>SEE ALSO</td><td>相关主题（通常是手册页）</td></tr></tbody></table><p><strong>3）</strong>  案例实操</p><p>（1）查看 ls 命令的帮助信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# man ls</span><br></pre></td></tr></table></figure><p><strong>7.1.2 help</strong> 获得 <strong>shell</strong> 内置命令的帮助信息</p><p>一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）命令”；相应的其它命令</p><p>被称为“外部命令”。</p><p><strong>1）</strong>  基本语法</p><p>help 命令（功能描述：获得 shell 内置命令的帮助信息）</p><p><strong>2）</strong>  案例实操</p><p>（1）查看 cd 命令的帮助信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# help cd</span><br></pre></td></tr></table></figure><p><strong>7.1.3</strong> 常用快捷键表 7-2 常用快捷键</p><table><thead><tr><th>常用快捷键</th><th>功能</th></tr></thead><tbody><tr><td>ctrl + c</td><td>停止进程</td></tr><tr><td>ctrl+l</td><td>清屏，等同于 clear；彻底清屏是：reset</td></tr><tr><td>善于用 tab 键</td><td>提示(更重要的是可以防止敲错)</td></tr><tr><td>上下键</td><td>查找执行过的命令</td></tr></tbody></table><h2 id="7-2-文件目录类"><a href="#7-2-文件目录类" class="headerlink" title="7.2 文件目录类"></a><strong>7.2</strong> 文件目录类</h2><h3 id="7-2-1-pwd-显示当前工作目录的绝对路径"><a href="#7-2-1-pwd-显示当前工作目录的绝对路径" class="headerlink" title="7.2.1 pwd 显示当前工作目录的绝对路径"></a><strong>7.2.1 pwd</strong> 显示当前工作目录的绝对路径</h3><p>pwd:print working directory 打印工作目录</p><p><strong>1）</strong>  基本语法 pwd    （功能描述：显示当前工作目录的绝对路径）</p><p><strong>2）</strong>  案例实操</p><p>（1）显示当前工作目录的绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# pwd</span><br><span class="line"></span><br><span class="line">/root</span><br></pre></td></tr></table></figure><h3 id="7-2-2-ls-列出目录的内容"><a href="#7-2-2-ls-列出目录的内容" class="headerlink" title="7.2.2 ls 列出目录的内容"></a><strong>7.2.2 ls</strong> 列出目录的内容</h3><p>ls:list 列出目录内容</p><p><strong>1）</strong>  基本语法</p><p>ls [选项] [目录或是文件]</p><p><strong>2）</strong>  选项说明</p><p>表7-3 选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</td></tr><tr><td>-l</td><td>长数据串列出，包含文件的属性与权限等等数据；(常用)等价于“ll”</td></tr></tbody></table><p><strong>3）</strong>  显示说明每行列出的信息依次是：文件类型与权限链接数文件属主文件属组文件大小用byte 来表示建立或最近修改的时间名字</p><p><strong>4）</strong>  案例实操</p><p>（1）查看当前目录的所有内容信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ ls -al </span><br><span class="line">总用量 44 </span><br><span class="line">drwx------. 5 atguigu atguigu 4096 5月 27 15:15 . </span><br><span class="line">drwxr-xr-x. 3 rootroot4096 5月 27 14:03 .. </span><br><span class="line">drwxrwxrwx. 2 rootroot4096 5月 27 14:14 hello </span><br><span class="line">-rwxrw-r--. 1 atguigu atguigu34 5月 27 14:20 test.txt</span><br></pre></td></tr></table></figure><h3 id="7-2-3-cd-切换目录"><a href="#7-2-3-cd-切换目录" class="headerlink" title="7.2.3 cd 切换目录"></a><strong>7.2.3 cd</strong> 切换目录</h3><p>cd:Change Directory 切换路径</p><p><strong>1）</strong>  基本语法</p><p>cd [参数]</p><p><strong>2）</strong>  参数说明</p><p>表 7-4参数说明</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>cd 绝对路径</td><td>切换路径</td></tr><tr><td>cd 相对路径</td><td>切换路径</td></tr><tr><td>cd ~或者 cd</td><td>回到自己的家目录</td></tr><tr><td>cd -</td><td>回到上一次所在目录</td></tr><tr><td>cd ..</td><td>回到当前目录的上一级目录</td></tr><tr><td>cd -P</td><td>跳转到实际物理路径，而非快捷方式路径</td></tr></tbody></table><p><strong>3）</strong>  案例实操</p><p>（1）使用绝对路径切换到 root 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cd /root/</span><br></pre></td></tr></table></figure><p>（2）使用相对路径切换到“公共的”目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cd 公共的/</span><br></pre></td></tr></table></figure><p>（3）表示回到自己的家目录，亦即是 /root 这个目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 公共的]# cd ~</span><br></pre></td></tr></table></figure><p>（4）cd- 回到上一次所在目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cd -</span><br></pre></td></tr></table></figure><p>（5）表示回到当前目录的上一级目录，亦即是“/root/公共的”的上一级目录的意思；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 公共的]# cd ..</span><br></pre></td></tr></table></figure><h3 id="7-2-4-mkdir-创建一个新的目录"><a href="#7-2-4-mkdir-创建一个新的目录" class="headerlink" title="7.2.4 mkdir 创建一个新的目录"></a><strong>7.2.4 mkdir</strong> 创建一个新的目录</h3><p>mkdir:Make directory 建立目录</p><p><strong>1）</strong>  基本语法 mkdir [选项] 要创建的目录</p><p><strong>2）</strong>  选项说明</p><p>表 7-5 选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>创建多层目录</td></tr></tbody></table><p><strong>3）</strong>  案例实操</p><p>（1）创建一个目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# mkdir xiyou</span><br><span class="line"></span><br><span class="line">[root@hadoop101 ~]# mkdir xiyou/mingjie</span><br></pre></td></tr></table></figure><p>（2）创建一个多级目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# mkdir -p xiyou/dssz/meihouwang</span><br></pre></td></tr></table></figure><h3 id="7-2-5-rmdir-删除一个空的目录"><a href="#7-2-5-rmdir-删除一个空的目录" class="headerlink" title="7.2.5 rmdir 删除一个空的目录"></a><strong>7.2.5 rmdir</strong> 删除一个空的目录</h3><p>rmdir:Remove directory 移除目录</p><p><strong>1</strong>）基本语法 rmdir 要删除的空目录 <strong>2</strong>）案例实操</p><p>（1）删除一个空的文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# rmdir xiyou/dssz/meihouwang</span><br></pre></td></tr></table></figure><h3 id="7-2-6-touch-创建空文件"><a href="#7-2-6-touch-创建空文件" class="headerlink" title="7.2.6 touch 创建空文件"></a><strong>7.2.6 touch</strong> 创建空文件</h3><p><strong>1）</strong>  基本语法</p><p>touch 文件名称</p><p><strong>2）</strong>  案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# touch xiyou/dssz/sunwukong.txt</span><br></pre></td></tr></table></figure><h3 id="7-2-7-cp-复制文件或目录"><a href="#7-2-7-cp-复制文件或目录" class="headerlink" title="7.2.7 cp 复制文件或目录"></a><strong>7.2.7 cp</strong> 复制文件或目录</h3><p><strong>1</strong>）基本语法 cp [选项] source dest    （功能描述：复制source文件到dest）</p><p><strong>1</strong>）选项说明</p><p>表7-6 选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>递归复制整个文件夹</td></tr></tbody></table><p><strong>3）</strong>  参数说明</p><p>表7-7 参数说明</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>source</td><td>源文件</td></tr><tr><td>dest</td><td>目标文件</td></tr></tbody></table><p><strong>4）</strong>  经验技巧强制覆盖不提示的方法：\cp</p><p><strong>5）</strong>  案例实操</p><p>（1）复制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cp xiyou/dssz/suwukong.txt xiyou/mingjie/</span><br></pre></td></tr></table></figure><p>（2）递归复制整个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cp -r xiyou/dssz/ ./</span><br></pre></td></tr></table></figure><h3 id="7-2-8-rm-删除文件或目录"><a href="#7-2-8-rm-删除文件或目录" class="headerlink" title="7.2.8 rm 删除文件或目录"></a><strong>7.2.8 rm</strong> 删除文件或目录</h3><p><strong>1</strong>）基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] deleteFile</span><br></pre></td></tr></table></figure><p>2）选项说明    （功能描述：递归删除目录中所有内容）</p><p>表7-8 选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>-r</td><td>递归删除目录中所有内容</td></tr><tr><td>-f</td><td>强制执行删除操作，而不提示用于进行确认。</td></tr><tr><td>-v</td><td>显示指令的详细执行过程</td></tr></tbody></table><p><strong>3</strong>）案例实操</p><p>（1）删除目录中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# rm xiyou/mingjie/sunwukong.txt</span><br></pre></td></tr></table></figure><p>（2）递归删除目录中所有内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# rm -rf dssz/</span><br></pre></td></tr></table></figure><h3 id="7-2-9-mv-移动文件与目录或重命名"><a href="#7-2-9-mv-移动文件与目录或重命名" class="headerlink" title="7.2.9 mv 移动文件与目录或重命名"></a><strong>7.2.9 mv</strong> 移动文件与目录或重命名</h3><p><strong>1）</strong>  基本语法</p><p>（1）mv oldNameFile newNameFile （功能描述：重命名）</p><p>（2）mv /temp/movefile /targetFolder （功能描述：移动文件）</p><p><strong>2）</strong>  案例实操</p><p>（1）重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# mv xiyou/dssz/suwukong.txt xiyou/dssz/houge.txt</span><br></pre></td></tr></table></figure><p>（2）移动文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# mv xiyou/dssz/houge.txt ./</span><br></pre></td></tr></table></figure><h3 id="7-2-10-cat-查看文件内容"><a href="#7-2-10-cat-查看文件内容" class="headerlink" title="7.2.10 cat 查看文件内容"></a><strong>7.2.10 cat</strong> 查看文件内容</h3><p>查看文件内容，从第一行开始显示。</p><p><strong>1）</strong>基本语法 cat [选项] 要查看的文件</p><p><strong>2）</strong>选项说明</p><p>表 7-9</p><table><thead><tr><th>选项</th><th>功能描述</th></tr></thead><tbody><tr><td>-n</td><td>显示所有行的行号，包括空行。</td></tr></tbody></table><p><strong>3）</strong>经验技巧一般查看比较小的文件，一屏幕能显示全的。</p><p><strong>4）</strong>案例实操</p><p>（1）查看文件内容并显示行号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ cat -n houge.txt</span><br></pre></td></tr></table></figure><h3 id="7-2-11-more-文件内容分屏查看器"><a href="#7-2-11-more-文件内容分屏查看器" class="headerlink" title="7.2.11 more 文件内容分屏查看器"></a><strong>7.2.11 more</strong> 文件内容分屏查看器</h3><p>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键，详见操作说明。</p><p><strong>1）</strong>  基本语法 more 要查看的文件</p><p><strong>2）</strong>  操作说明</p><p>表 7-10 操作说明</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键 (space)</td><td>代表向下翻一页；</td></tr><tr><td>Enter</td><td>代表向下翻『一行』；</td></tr><tr><td>q</td><td>代表立刻离开 more ，不再显示该文件内容。</td></tr><tr><td>Ctrl+F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl+B</td><td>返回上一屏</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><p><strong>3）</strong>  案例实操</p><p>（1）采用more查看文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# more smartd.conf</span><br></pre></td></tr></table></figure><h3 id="7-2-12-less-分屏显示文件内容"><a href="#7-2-12-less-分屏显示文件内容" class="headerlink" title="7.2.12 less 分屏显示文件内容"></a><strong>7.2.12 less</strong> 分屏显示文件内容</h3><p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后</p><p>才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><p><strong>1）</strong>基本语法</p><p>less 要查看的文件</p><p><strong>2）</strong>操作说明</p><p>表 7-11 操作说明</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻动一页；</td></tr><tr><td>[pagedown]</td><td>向下翻动一页</td></tr><tr><td>[pageup]</td><td>向上翻动一页；</td></tr><tr><td>/字串</td><td>向下搜寻『字串』的功能；n：向下查找；N：向上查找；</td></tr><tr><td>?字串</td><td>向上搜寻『字串』的功能；n：向上查找；N：向下查找；</td></tr><tr><td>q</td><td>离开 less 这个程序；</td></tr></tbody></table><p><strong>3）</strong>经验技巧</p><p>用SecureCRT时[pagedown]和[pageup]可能会出现无法识别的问题。</p><p><strong>4）</strong>案例实操</p><p>（1）采用less查看文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# less smartd.conf</span><br></pre></td></tr></table></figure><h3 id="7-2-13-echo"><a href="#7-2-13-echo" class="headerlink" title="7.2.13 echo"></a><strong>7.2.13 echo</strong></h3><p>echo 输出内容到控制台</p><p><strong>1）</strong>  基本语法</p><p>echo [选项] [输出内容] 选项：</p><p>-e： 支持反斜线控制的字符转换</p><table><thead><tr><th>控制字符</th><th>作用</th></tr></thead><tbody><tr><td>\</td><td>输出\本身</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符，也就是 Tab  键</td></tr></tbody></table><p><strong>2）</strong>  案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ echo “hello\tworld” hello\tworld</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 ~]$ echo -e “hello\tworld” hello  world</span><br></pre></td></tr></table></figure><h3 id="7-2-14-head-显示文件头部内容"><a href="#7-2-14-head-显示文件头部内容" class="headerlink" title="7.2.14 head 显示文件头部内容"></a><strong>7.2.14 head</strong> 显示文件头部内容</h3><p>head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容。</p><p><strong>1）</strong>  基本语法 head 文件 （功能描述：查看文件头10行内容） head -n 5 文件 （功能描述：查看文件头5行内容，5可以是任意行数）</p><p><strong>2）</strong>  选项说明</p><p>表7-12</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n&lt;行数&gt;</td><td>指定显示头部内容的行数</td></tr></tbody></table><p><strong>3）</strong>  案例实操</p><p>（1）查看文件的头2行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# head -n 2 smartd.conf</span><br></pre></td></tr></table></figure><h3 id="7-2-15-tail-输出文件尾部内容"><a href="#7-2-15-tail-输出文件尾部内容" class="headerlink" title="7.2.15 tail 输出文件尾部内容"></a><strong>7.2.15 tail</strong> 输出文件尾部内容</h3><p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。</p><table><thead><tr><th><strong>1</strong>） 基本语法</th><th></th></tr></thead><tbody><tr><td>（1）tail  文件</td><td>（功能描述：查看文件尾部10行内容）</td></tr><tr><td>（2）tail  -n 5 文件</td><td>（功能描述：查看文件尾部5行内容，5可以是任意行数）</td></tr><tr><td>（3）tail -f 文件  <strong>2</strong>） 选项说明</td><td>（功能描述：实时追踪该文档的所有更新）</td></tr></tbody></table><p>表7-13</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n&lt;行数&gt;</td><td>输出文件尾部 n 行内容</td></tr><tr><td>-f</td><td>显示文件最新追加的内容，监视文件变化</td></tr></tbody></table><p><strong>3</strong>）案例实操</p><p>（1）查看文件尾 1 行内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# tail -n 1 smartd.conf</span><br></pre></td></tr></table></figure><p>（2）实时追踪该档的所有更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# tail -f houge.txt</span><br></pre></td></tr></table></figure><h3 id="7-2-16-gt-输出重定向和-gt-gt-追加"><a href="#7-2-16-gt-输出重定向和-gt-gt-追加" class="headerlink" title="7.2.16 &gt; 输出重定向和 &gt;&gt; 追加"></a><strong>7.2.16 &gt;</strong> 输出重定向和 <strong>&gt;&gt;</strong> 追加</h3><p><strong>1）</strong>  基本语法</p><p>（1）ls -l &gt; 文件  （功能描述：列表的内容写入文件 a.txt 中（覆盖写））</p><p>（2）ls -al &gt;&gt; 文件 （功能描述：列表的内容追加到文件 aa.txt 的末尾）</p><p>（3）cat 文件 1 &gt; 文件 2   （功能描述：将文件 1 的内容覆盖到文件 2）</p><p>（4）echo “内容” &gt;&gt; 文件</p><p><strong>2）</strong>  案例实操</p><p>（1）将 ls 查看信息写入到文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# ls -l&gt;houge.txt</span><br></pre></td></tr></table></figure><p>（2）将 ls 查看信息追加到文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# ls -l&gt;&gt;houge.txt</span><br></pre></td></tr></table></figure><p>（3）采用 echo 将 hello 单词追加到文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# echo hello&gt;&gt;houge.txt</span><br></pre></td></tr></table></figure><h3 id="7-2-17-ln-软链接"><a href="#7-2-17-ln-软链接" class="headerlink" title="7.2.17 ln 软链接"></a><strong>7.2.17 ln</strong> 软链接</h3><p>软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放了链接其他文件的路径。</p><p><strong>1）</strong>  基本语法 ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）</p><p><strong>2）</strong>  经验技巧删除软链接： rm -rf 软链接名，而不是 rm -rf 软链接名/ 如果使用 rm -rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉查询：通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。</p><p><strong>3）</strong>  案例实操</p><p>（1）创建软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# mv houge.txt xiyou/dssz/</span><br><span class="line">[root@hadoop101 ~]# ln -s xiyou/dssz/houge.txt ./houzi</span><br><span class="line">[root@hadoop101 ~]# ll</span><br><span class="line">lrwxrwxrwx. 1 root root  20 6月 17 12:56 houzi -&gt; xiyou/dssz/houge.txt</span><br></pre></td></tr></table></figure><p>（2）删除软连接(注意不要写最后的/)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# rm -rf houzi</span><br></pre></td></tr></table></figure><p>（3）进入软连接实际物理路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# ln -s xiyou/dssz/ ./dssz</span><br><span class="line">[root@hadoop101 ~]# cd -P dssz/</span><br></pre></td></tr></table></figure><h3 id="7-2-18-history-查看已经执行过历史命令"><a href="#7-2-18-history-查看已经执行过历史命令" class="headerlink" title="7.2.18 history 查看已经执行过历史命令"></a><strong>7.2.18 history</strong> 查看已经执行过历史命令</h3><p><strong>1）</strong>  基本语法</p><p>​    history （功能描述：查看已经执行过历史命令）</p><p><strong>2）</strong>  案例实操</p><p>（1）查看已经执行过的历史命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 test1]# history</span><br></pre></td></tr></table></figure><h2 id="7-3-时间日期类"><a href="#7-3-时间日期类" class="headerlink" title="7.3 时间日期类"></a><strong>7.3</strong> 时间日期类</h2><p><strong>1）</strong>  基本语法</p><p>date [OPTION]… [+FORMAT]</p><p><strong>2）</strong>  选项说明</p><p>表 7-14</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d&lt;时间字符串&gt;</td><td>显示指定的“时间字符串”表示的时间，而非当前时间</td></tr><tr><td>-s&lt;日期时间&gt;</td><td>设置系统日期时间</td></tr></tbody></table><p><strong>3）</strong>  参数说明</p><p>表 7-15</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>&lt;+日期时间格式&gt;</td><td>指定显示时使用的日期时间格式</td></tr></tbody></table><h3 id="7-3-1-date-显示当前时间"><a href="#7-3-1-date-显示当前时间" class="headerlink" title="7.3.1 date 显示当前时间"></a><strong>7.3.1 date</strong> 显示当前时间</h3><p><strong>1）</strong>  基本语法</p><table><thead><tr><th>（1）date</th><th>（功能描述：显示当前时间）</th></tr></thead><tbody><tr><td>（2）date  +%Y</td><td>（功能描述：显示当前年份）</td></tr><tr><td>（3）date  +%m</td><td>（功能描述：显示当前月份）</td></tr><tr><td>（4）date  +%d</td><td>（功能描述：显示当前是哪一天）</td></tr><tr><td>（5）date  “+%Y-%m-%d %H:%M:%S”</td><td>（功能描述：显示年月日时分秒）</td></tr></tbody></table><p><strong>2）</strong>  案例实操</p><p>（1）显示当前时间信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# date</span><br></pre></td></tr></table></figure><p>2017 年 06 月 19 日星期一 20:53:30 CST</p><p>（2）显示当前时间年月日</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# date +%Y%m%d</span><br></pre></td></tr></table></figure><p>20170619</p><p>（3）显示当前时间年月日时分秒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br></pre></td></tr></table></figure><p>2017-06-19 20:54:58</p><h3 id="7-3-2-date-显示非当前时间"><a href="#7-3-2-date-显示非当前时间" class="headerlink" title="7.3.2 date 显示非当前时间"></a><strong>7.3.2 date</strong> 显示非当前时间</h3><p><strong>1）</strong>  基本语法</p><p>（1）date -d ‘1 days ago’ （功能描述：显示前一天时间）</p><p>（2）date -d ‘-1 days ago’    （功能描述：显示明天时间）</p><p><strong>2）</strong>  案例实操</p><p>（1）显示前一天</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# date -d &#x27;1 days ago&#x27;</span><br></pre></td></tr></table></figure><p>2017 年 06 月 18 日星期日 21:07:22 CST</p><p>（2）显示明天时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#date -d &#x27;-1 days ago&#x27;</span><br></pre></td></tr></table></figure><p>2017 年 06 月 20 日星期日 21:07:22 CST</p><h3 id="7-3-3-date-设置系统时间"><a href="#7-3-3-date-设置系统时间" class="headerlink" title="7.3.3 date 设置系统时间"></a><strong>7.3.3 date</strong> 设置系统时间</h3><p><strong>1</strong>）基本语法</p><p>date -s 字符串时间 <strong>2</strong>）案例实操</p><p>（1）设置系统当前时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# date -s &quot;2017-06-19 20:52:18&quot;</span><br></pre></td></tr></table></figure><h3 id="7-3-4-cal-查看日历"><a href="#7-3-4-cal-查看日历" class="headerlink" title="7.3.4 cal 查看日历"></a><strong>7.3.4 cal</strong> 查看日历</h3><p><strong>1）</strong>  基本语法 cal [选项]   （功能描述：不加选项，显示本月日历）</p><p><strong>2）</strong>  选项说明</p><p>表 7-16</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>具体某一年</td><td>显示这一年的日历</td></tr></tbody></table><p><strong>3）</strong>  案例实操</p><p>（1）查看当前月的日历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cal</span><br></pre></td></tr></table></figure><p>（2）查看 2017 年的日历</p><p>[root@hadoop101 ~]# cal 2017</p><h2 id="7-4-用户管理命令"><a href="#7-4-用户管理命令" class="headerlink" title="7.4 用户管理命令"></a><strong>7.4</strong> 用户管理命令</h2><h2 id="7-4-1-useradd-添加新用户"><a href="#7-4-1-useradd-添加新用户" class="headerlink" title="7.4.1 useradd 添加新用户"></a><strong>7.4.1 useradd</strong> 添加新用户</h2><p><strong>1）</strong>  基本语法 useradd 用户名 （功能描述：添加新用户）</p><p>useradd -g 组名用户名（功能描述：添加新用户到某个组）</p><p><strong>2）</strong>  案例实操</p><p>（1）添加一个用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# useradd tangseng</span><br><span class="line">[root@hadoop101 ~]#ll /home/</span><br></pre></td></tr></table></figure><p><strong>7.4.2 passwd</strong> 设置用户密码</p><p><strong>1</strong>）基本语法 passwd 用户名 （功能描述：设置用户密码） <strong>2</strong>）案例实操</p><p>（1）设置用户的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# passwd tangseng</span><br></pre></td></tr></table></figure><h4 id="7-4-3-id-查看用户是否存在"><a href="#7-4-3-id-查看用户是否存在" class="headerlink" title="7.4.3 id 查看用户是否存在"></a><strong>7.4.3 id</strong> 查看用户是否存在</h4><p><strong>1）</strong>  基本语法 id 用户名</p><p><strong>2）</strong>  案例实操</p><p>（1）查看用户是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#id tangseng</span><br></pre></td></tr></table></figure><p><strong>7.4.4 cat /etc/passwd</strong> 查看创建了哪些用户</p><p><strong>1</strong>）案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cat/etc/passwd</span><br></pre></td></tr></table></figure><p><strong>7.4.5 su</strong> 切换用户</p><p>su: swith user 切换用户</p><p><strong>1）</strong>基本语法su 用户名称 （功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量） su - 用户名称 （功能描述：切换到用户并获得该用户的环境变量及执行权限）</p><p><strong>2）</strong>案例实操</p><p>（1）切换用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#su tangseng</span><br><span class="line">[root@hadoop101 ~]#echo $PATH</span><br><span class="line">/usr/lib64/qt-</span><br><span class="line">3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/b in</span><br><span class="line">[root@hadoop101 ~]#exit</span><br><span class="line">[root@hadoop101 ~]#su - tangseng</span><br><span class="line">[root@hadoop101 ~]#echo $PATH</span><br><span class="line">/usr/lib64/qt-</span><br><span class="line">3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/t angseng/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>7.4.6 userdel</strong> 删除用户</p><p><strong>1）</strong>基本语法</p><p>（1）userdel 用户名  （功能描述：删除用户但保存用户主目录）</p><p>（2）userdel -r 用户名 （功能描述：用户和用户主目录，都删除）</p><p><strong>2）</strong>选项说明</p><p>表 7-17</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>删除用户的同时，删除与用户相关的所有文件。</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）删除用户但保存用户主目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#userdel tangseng</span><br><span class="line">[root@hadoop101 ~]#ll /home/</span><br></pre></td></tr></table></figure><p>（2）删除用户和用户主目录，都删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#useradd zhubajie</span><br><span class="line">[root@hadoop101 ~]#ll /home/</span><br><span class="line">[root@hadoop101 ~]#userdel -r zhubajie</span><br><span class="line">[root@hadoop101 ~]#ll /home/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>7.4.7 who</strong> 查看登录用户信息</p><p><strong>1）</strong>基本语法</p><p>（1）whoami （功能描述：显示自身用户名称）</p><p>（2）who am i    （功能描述：显示登录用户的用户名以及登陆时间）</p><p><strong>2）</strong>案例实操</p><p>（1）显示自身用户名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]# whoami</span><br></pre></td></tr></table></figure><p>（2）显示登录用户的用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]# who am i</span><br></pre></td></tr></table></figure><p><strong>7.4.8 sudo</strong> 设置普通用户具有 <strong>root</strong> 权限</p><p> <strong>1</strong>）添加 <strong>atguigu</strong> 用户，并对其设置密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101~]#useradd atguigu</span><br><span class="line">[root@hadoop101~]#passwd atguigu</span><br></pre></td></tr></table></figure><p><strong>2</strong>）修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101~]#vi /etc/sudoers</span><br></pre></td></tr></table></figure><p>修改 /etc/sudoers 文件，找到下面一行(91 行)，在 root 下面添加一行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root ALL=(ALL) ALL </span><br><span class="line">atguigu ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>或者配置成采用 sudo 命令时，不需要输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">rootALL=(ALL)ALL</span><br><span class="line">atguiguALL=(ALL)NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>​    修改完毕，现在可以用 atguigu 帐号登录，然后用命令 sudo ，即可获得 root 权限进行操作。</p><p><strong>3）</strong>案例实操</p><p>（1）用普通用户在/opt 目录下创建一个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 opt]$ sudo mkdir module</span><br><span class="line">[root@hadoop101 opt]# chown atguigu:atguigu module/</span><br></pre></td></tr></table></figure><p><strong>7.4.9 usermod</strong> 修改用户</p><p><strong>1）</strong>基本语法</p><p>usermod -g 用户组用户名</p><p><strong>2）</strong>选项说明</p><p>表7-18</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-g</td><td>修改用户的初始登录组，给定的组必须存在。默认组  id 是 1。</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）将用户加入到用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]# usermod -g root zhubajie</span><br></pre></td></tr></table></figure><h2 id="7-5-用户组管理命令"><a href="#7-5-用户组管理命令" class="headerlink" title="7.5 用户组管理命令"></a><strong>7.5</strong> 用户组管理命令</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同</p><p>Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对</p><p>/etc/group文件的更新。</p><p><strong>7.5.1 groupadd</strong> 新增组</p><p><strong>1）</strong>基本语法</p><p>groupadd 组名</p><p><strong>2）</strong>案例实操</p><p>（1）添加一个xitianqujing组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]#groupadd xitianqujing</span><br></pre></td></tr></table></figure><p><strong>7.5.2 groupdel</strong> 删除组</p><p><strong>1）</strong>基本语法</p><p>groupdel 组名</p><p><strong>2）</strong>案例实操</p><p>（1）删除xitianqujing组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]# groupdel xitianqujing</span><br></pre></td></tr></table></figure><p><strong>7.5.3 groupmod</strong> 修改组</p><p><strong>1</strong>）基本语法</p><p>groupmod -n 新组名老组名</p><p><strong>1</strong>）选项说明</p><p>表7-19</p><table><thead><tr><th>选项</th><th>功能描述</th></tr></thead><tbody><tr><td>-n&lt;新组名&gt;</td><td>指定工作组的新组名</td></tr></tbody></table><p><strong>3</strong>）案例实操</p><p>（1）修改atguigu组名称为atguigu1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#groupadd xitianqujing</span><br><span class="line">[root@hadoop101 ~]# groupmod -n xitian xitianqujing</span><br></pre></td></tr></table></figure><p><strong>7.5.4 cat /etc/group</strong> 查看创建了哪些组</p><p><strong>1</strong>）基本操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 atguigu]# cat /etc/group</span><br></pre></td></tr></table></figure><h2 id="7-6-文件权限类"><a href="#7-6-文件权限类" class="headerlink" title="7.6 文件权限类"></a><strong>7.6</strong> 文件权限类</h2><p><strong>7.6.1</strong> 文件属性</p><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属</p><p>的用户和组。</p><p><strong>1）</strong>从左到右的 <strong>10</strong> 个字符表示，如图 <strong>7-1</strong> 所示</p><p><img src="https://image.3001.net/images/20221009/16652816016638.jpg" alt="img"></p><p>图 7-1 文件属性</p><p>如果没有权限，就会出现减号[ - ]而已。从左至右用0-9这些数字来表示:</p><p>（1）0 首位表示类型</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等</p><p>- 代表文件 d 代表目录</p><p>l 链接文档(link file)；</p><p>（2）   第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User</p><p>（3）   第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group</p><p>（4）   第7-9位确定其他用户拥有该文件的权限 —Other</p><p><strong>2）****rwx</strong> 作用文件和目录的不同解释</p><p>（1）   作用到文件：</p><p>[ r ]代表可读(read): 可以读取，查看</p><p>[ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前</p><p>提条件是对该文件所在的目录有写权限，才能删除该文件.</p><p>[ x ]代表可执行(execute):可以被系统执行</p><p>（2）   作用到目录：</p><p>[ r ]代表可读(read): 可以读取，ls查看目录内容</p><p>[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录</p><p>[ x ]代表可执行(execute):可以进入该目录</p><p><strong>3）</strong>案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# ll  </span><br><span class="line">总用量 104  </span><br><span class="line">-rw-------. 1 root root 1248 1月 8 17:36 anaconda-ks.cfg </span><br><span class="line">drwxr-xr-x. 2  root root 4096 1月 12 14:02  dssz  </span><br><span class="line">lrwxrwxrwx.  1 root root   20 1月 12 14:32 houzi -&gt; xiyou/dssz/houge.tx  </span><br></pre></td></tr></table></figure><p>文件基本属性介绍，如图7-2所示：</p><p><img src="https://image.3001.net/images/20221009/16652816018579.jpg" alt="img"></p><p>图7-2 文件基本属性介绍</p><p>（1）   如果查看到是文件：链接数指的是硬链接个数。</p><p>（2）   如果查看的是文件夹：链接数指的是子文件夹个数。</p><p><strong>7.6.2 chmod</strong> 改变权限</p><p><strong>1）</strong>基本语法</p><p>如图 7-3 所示</p><p><img src="https://image.3001.net/images/20221009/16652816018782.jpg" alt="img"></p><p>图 7-3 基本语法第一种方式变更权限</p><p>chmod [{ugoa}{+-=}{rwx}] 文件或目录第二种方式变更权限</p><p>chmod [mode=421 ] [文件或目录]</p><p><strong>2）</strong>经验技巧 u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和)</p><p>​    r=4 w=2 x=1    rwx=4+2+1=7</p><p><strong>3）</strong>案例实操</p><p>（1）   修改文件使其所属主用户具有执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# cp xiyou/dssz/houge.txt ./</span><br><span class="line">[root@hadoop101 ~]# chmod u+x houge.txt</span><br></pre></td></tr></table></figure><p>（2）   修改文件使其所属组用户具有执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# chmod g+x houge.txt</span><br></pre></td></tr></table></figure><p>（3）   修改文件所属主用户执行权限,并使其他用户具有执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# chmod u-x,o+x houge.txt</span><br></pre></td></tr></table></figure><p>（4）   采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# chmod 777 houge.txt</span><br></pre></td></tr></table></figure><p>（5）   修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可执行权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# chmod -R 777 xiyou/</span><br></pre></td></tr></table></figure><p><strong>7.6.3 chown</strong> 改变所有者</p><p><strong>1）</strong>基本语法chown [选项] [最终用户] [文件或目录] （功能描述：改变文件或者目录的所有者）</p><p><strong>2）</strong>选项说明</p><p>表7-20</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-R</td><td>递归操作</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）   修改文件所有者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# chown atguigu houge.txt</span><br><span class="line">[root@hadoop101 ~]# ls -al</span><br><span class="line">-rwxrwxrwx. 1 atguigu root 551 5月 23 13:02 houge.txt</span><br></pre></td></tr></table></figure><p>（2）   递归改变文件所有者和所有组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 xiyou]# ll </span><br><span class="line">drwxrwxrwx. 2 root root 4096 9月 3 21:20 xiyou </span><br><span class="line">[root@hadoop101 xiyou]# chown -R atguigu:atguigu xiyou/</span><br><span class="line">[root@hadoop101 xiyou]# ll</span><br><span class="line">drwxrwxrwx. 2 atguigu atguigu 4096 9月 3 21:20 xiyou</span><br></pre></td></tr></table></figure><p><strong>7.6.4 chgrp</strong> 改变所属组</p><p><strong>1）</strong>基本语法chgrp [最终用户组] [文件或目录] （功能描述：改变文件或者目录的所属组）</p><p><strong>2）</strong>案例实操</p><p>（1）修改文件的所属组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# chgrp root houge.txt</span><br><span class="line">[root@hadoop101 ~]# ls -al</span><br><span class="line">-rwxrwxrwx. 1 atguigu root 551 5月 23 13:02 houge.txt</span><br></pre></td></tr></table></figure><h2 id="7-7-搜索查找类"><a href="#7-7-搜索查找类" class="headerlink" title="7.7 搜索查找类"></a><strong>7.7</strong> 搜索查找类</h2><p><strong>7.7.1 find</strong> 查找文件或者目录</p><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。</p><p><strong>1）</strong>基本语法</p><p>find [搜索范围] [选项]</p><p><strong>2）</strong>选项说明</p><p>表 7-21</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件,单位为:  <strong>b</strong>  —— 块（512  字节） <strong>c</strong> —— 字节 <strong>w</strong>  —— 字（2  字节） <strong>k</strong> —— 千字节  <strong>M</strong>  —— 兆字节 <strong>G</strong> ——  吉字节</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）   按文件名：根据名称查找/目录下的filename.txt文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# find xiyou/ -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><p>（2）   按拥有者：查找/opt目录下，用户名称为-user的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# find xiyou/ -user atguigu</span><br></pre></td></tr></table></figure><p>（3）   按文件大小：在/home目录下查找大于200m的文件（+n 大于 -n小于 n等于）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]find /home -size +204800</span><br></pre></td></tr></table></figure><p><strong>7.7.2 locate</strong> 快速定位文件路径</p><p>locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。</p><p><strong>1）</strong>基本语法</p><p>locate 搜索文件</p><p><strong>2）</strong>经验技巧由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。</p><p><strong>3）</strong>案例实操</p><p>（1）查询文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# updatedb</span><br><span class="line">[root@hadoop101 ~]#locate tmp</span><br></pre></td></tr></table></figure><p><strong>7.7.3 grep</strong> 过滤查找及<strong>“|”</strong>管道符</p><p>管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理</p><p><strong>1）</strong>基本语法grep 选项查找内容源文件</p><p><strong>2）</strong>选项说明</p><p>表7-22</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号。</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）查找某文件在第几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# ls | grep -n test</span><br></pre></td></tr></table></figure><h2 id="7-8-压缩和解压类"><a href="#7-8-压缩和解压类" class="headerlink" title="7.8 压缩和解压类"></a><strong>7.8</strong> 压缩和解压类</h2><p><strong>7.8.1 gzip/gunzip</strong> 压缩</p><p><strong>1）</strong>基本语法gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz 文件） gunzip 文件.gz （功能描述：解压缩文件命令）</p><p><strong>2）</strong>经验技巧</p><p>（1）只能压缩文件不能压缩目录</p><p>（2）不保留原来的文件</p><p>（3）同时多个文件会产生多个压缩包</p><p><strong>3）</strong>案例实操</p><p>（1）gzip压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# ls test.java</span><br><span class="line"></span><br><span class="line">[root@hadoop101 ~]# gzip houge.txt</span><br><span class="line"></span><br><span class="line">[root@hadoop101 ~]# ls houge.txt.gz</span><br></pre></td></tr></table></figure><p>（2）gunzip解压缩文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#  gunzip houge.txt.gz  </span><br><span class="line">[root@hadoop101 ~]# ls houge.txt  </span><br></pre></td></tr></table></figure><p><strong>7.8.2 zip/unzip</strong> 压缩</p><p><strong>1</strong>）基本语法 zip [选项] XXX.zip 将要压缩的内容 （功能描述：压缩文件和目录的命令）</p><table><thead><tr><th>unzip [选项]  XXX.zip  <strong>2</strong>）选项说明</th><th>（功能描述：解压缩文件）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>表 7-23</p><table><thead><tr><th>zip 选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>压缩目录</td></tr><tr><td></td><td>表 7-24</td></tr><tr><td>unzip 选项</td><td>功能</td></tr><tr><td>-d&lt;目录&gt;</td><td>指定解压后文件的存放目录</td></tr></tbody></table><p><strong>3）</strong>  经验技巧 zip 压缩命令在windows/linux都通用，可以压缩目录且保留源文件。</p><p><strong>4）</strong>  案例实操</p><p>（1）   压缩 houge.txt 和bailongma.txt，压缩后的名称为mypackage.zip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]# touch bailongma.txt</span><br><span class="line"></span><br><span class="line">[root@hadoop101 ~]# zip mypackage.zip houge.txt bailongma.txt adding: houge.txt (stored 0%) adding: bailongma.txt (stored 0%)</span><br><span class="line"></span><br><span class="line">[root@hadoop101 opt]# ls houge.txt bailongma.txt mypackage.zip</span><br></pre></td></tr></table></figure><p>（2）   解压 mypackage.zip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# unzip mypackage.zip</span><br><span class="line">Archive: houma.zip extracting: houge.txt extracting: bailongma.txt [root@hadoop101 ~]# ls</span><br><span class="line">houge.txt bailongma.txt mypackage.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）   解压mypackage.zip到指定目录-d</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# unzip mypackage.zip -d /opt</span><br><span class="line"></span><br><span class="line">[root@hadoop101 ~]# ls /opt/</span><br></pre></td></tr></table></figure><p><strong>7.8.3 tar</strong> 打包</p><p><strong>1）</strong>基本语法tar [选项] XXX.tar.gz 将要打包进去的内容  （功能描述：打包目录，压缩后的</p><p>文件格式.tar.gz）</p><p><strong>2）</strong>选项说明</p><p>表 7-25</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar 打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar 文件</td></tr><tr><td>-C</td><td>解压到指定目录</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）压缩多个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]# tar -zcvf houma.tar.gz houge.txt bailongma.txt</span><br><span class="line">houge.txt bailongma.txt</span><br><span class="line">[root@hadoop101 opt]# ls houma.tar.gz houge.txt bailongma.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）压缩目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# tar -zcvf xiyou.tar.gz xiyou/ xiyou/ xiyou/mingjie/ xiyou/dssz/ xiyou/dssz/houge.txt</span><br></pre></td></tr></table></figure><p>（3）解压到当前目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# tar -zxvf houma.tar.gz</span><br></pre></td></tr></table></figure><p>（4）解压到指定目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# tar -zxvf xiyou.tar.gz -C /opt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# ll /opt/</span><br></pre></td></tr></table></figure><h2 id="7-9-磁盘查看和分区类"><a href="#7-9-磁盘查看和分区类" class="headerlink" title="7.9 磁盘查看和分区类"></a><strong>7.9</strong> 磁盘查看和分区类</h2><h4 id="7-9-1-du-查看文件和目录占用的磁盘空间"><a href="#7-9-1-du-查看文件和目录占用的磁盘空间" class="headerlink" title="7.9.1 du 查看文件和目录占用的磁盘空间"></a><strong>7.9.1 du</strong> 查看文件和目录占用的磁盘空间</h4><p>du: disk usage 磁盘占用情况</p><p><strong>1）</strong>基本语法du 目录/文件（功能描述：显示目录下每个子目录的磁盘使用情况）</p><p><strong>2）</strong>选项说明</p><p>表 7-26</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td></tr><tr><td>-a</td><td>不仅查看子目录大小，还要包括文件</td></tr><tr><td>-c</td><td>显示所有的文件和子目录大小后，显示总和</td></tr><tr><td>-s</td><td>只显示总和</td></tr><tr><td>–max-depth=n</td><td>指定统计子目录的深度为第 n 层</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）查看当前用户主目录占用的磁盘空间大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# du -sh</span><br></pre></td></tr></table></figure><p>166M  .</p><h4 id="7-9-2-df-查看磁盘空间使用情况"><a href="#7-9-2-df-查看磁盘空间使用情况" class="headerlink" title="7.9.2 df 查看磁盘空间使用情况"></a><strong>7.9.2 df</strong> 查看磁盘空间使用情况</h4><p>df: disk free 空余磁盘</p><p><strong>1</strong>）基本语法 df 选项 （功能描述：列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况） <strong>2</strong>）选项说明</p><p>表 7-26</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td></tr></tbody></table><p><strong>3</strong>）案例实操</p><p>（1）查看磁盘使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# df -h</span><br><span class="line">FilesystemSize Used Avail Use% Mounted on</span><br><span class="line">/dev/sda215G 3.5G11G 26% / tmpfs939M 224K 939M1% /dev/shm /dev/sda1190M39M 142M 22% /boot</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>7.9.3 lsblk</strong> 查看设备挂载情况</p><p><strong>1）</strong>基本语法</p><p>​    lsblk        （功能描述：查看设备挂载情况）</p><p><strong>2）</strong>选项说明</p><p>表 7-28</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>查看详细的设备挂载情况，显示文件系统信息</td></tr></tbody></table><p><strong>7.9.5</strong> <strong>mount/umount</strong> 挂载**/**卸载</p><p>对于Linux用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根目录、一个独立且唯一的文件结构。</p><p>Linux中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理</p><p>方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，</p><p>要载入的那个分区将使它的存储空间在这个目录下获得。</p><p><strong>1）</strong>挂载前准备（必须要有光盘或者已经连接镜像文件），如图 <strong>7-5</strong>， <strong>7-6</strong> 所示</p><p><img src="https://image.3001.net/images/20221009/16652816017119.jpg" alt="img"></p><p>图 7-5</p><p><img src="https://image.3001.net/images/20221009/16652816026310.jpg" alt="img"></p><p>图7-6 挂载镜像文件</p><p><strong>2）</strong>基本语法</p><p>​    mount [-t vfstype] [-o options] device dir  （功能描述：挂载设备）</p><p>​    umount 设备文件名或挂载点 （功能描述：卸载设备）</p><p><strong>3）</strong>参数说明</p><p>表7-29</p><table><thead><tr><th>-t  vfstype</th><th>指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：  光盘或光盘镜像：iso9660  DOS fat16 文件系统：msdos  <a href="http://blog.csdn.net/hancunai0017/article/details/6995284">Windows</a> 9x fat32 文件系统：vfat  Windows NT ntfs 文件系统：ntfs  Mount Windows 文件<a href="http://blog.csdn.net/hancunai0017/article/details/6995284">网络共</a>享：smbfs  <a href="http://blog.csdn.net/hancunai0017/article/details/6995284">UNIX</a>(LINUX) 文件网络共享：nfs</th></tr></thead><tbody><tr><td>-o  options</td><td>主要用来描述设备或档案的挂接方式。常用的参数有：  loop：用来把一个文件当成硬盘分区挂接上系统  ro：采用只读方式挂接设备  rw：采用读写方式挂接设备  iocharset：指定访问文件系统所用字符集</td></tr><tr><td>device</td><td>要挂接(mount)的设备</td></tr><tr><td>dir</td><td>设备在系统上的挂接点(mount point)</td></tr></tbody></table><p><strong>4）</strong>案例实操</p><p>（1）挂载光盘镜像文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# mkdir /mnt/cdrom/</span><br><span class="line">[root@hadoop101 ~]# mount -t iso9660 /dev/cdrom /mnt/cdrom/ #挂载到挂载点： /mnt/cdrom中</span><br><span class="line">[root@hadoop101 ~]# ll /mnt/cdrom/#建立挂载点</span><br><span class="line">设备/dev/cdrom</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）卸载光盘镜像文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# umount /mnt/cdrom</span><br></pre></td></tr></table></figure><p>添加红框中内容，保存退出。</p><p>如图7-7所示</p><p><img src="https://image.3001.net/images/20221009/16652816025041.jpg" alt="img"></p><p>图7-7 设置开机自动挂载</p><p><strong>7.9.4 fdisk</strong> 分区</p><p><strong>1）</strong>基本语法fdisk -l   （功能描述：查看磁盘分区详情）</p><p>fdisk 硬盘设备名 （功能描述：对新增硬盘进行分区操作）</p><p><strong>2）</strong>选项说明</p><p>表 7-27</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-l</td><td>显示所有硬盘的分区列表</td></tr></tbody></table><p><strong>3）</strong>经验技巧</p><p>该命令必须在 root 用户下才能使用</p><p><strong>4）</strong>功能说明</p><p>（1）Linux 分区</p><p>Device：分区序列</p><p>Boot：引导</p><p>Start：从X磁柱开始</p><p>End：到Y磁柱结束</p><p>Blocks：容量</p><p>Id：分区类型ID</p><p>System：分区类型</p><p>（2）分区操作按键说明</p><p>m：显示命令列表</p><p>p：显示当前磁盘分区 n：新增分区</p><p>w：写入分区信息并退出</p><p>q：不保存分区信息直接退出</p><p><strong>5）</strong>案例实操</p><p>（1）查看系统分区情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 /]# fdisk -l</span><br><span class="line">Disk /dev/sda: 21.5 GB, 21474836480 bytes</span><br><span class="line">255 heads, 63 sectors/track, 2610 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x0005e654</span><br><span class="line">Device BootStartEndBlocksIdSystem</span><br><span class="line">/dev/sda1*12620480083 Linux</span><br><span class="line">Partition 1 does not end on cylinder boundary.</span><br><span class="line">/dev/sda22613321048576083 Linux</span><br><span class="line">/dev/sda313321593209715282 Linux swap / Solaris</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-10-进程管理类"><a href="#7-10-进程管理类" class="headerlink" title="7.10 进程管理类"></a><strong>7.10</strong> 进程管理类</h2><p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p><h4 id="7-10-1-ps-查看当前系统进程状态"><a href="#7-10-1-ps-查看当前系统进程状态" class="headerlink" title="7.10.1 ps 查看当前系统进程状态"></a><strong>7.10.1 ps</strong> 查看当前系统进程状态</h4><p>ps:process status 进程状态</p><p><strong>1</strong>）基本语法</p><table><thead><tr><th>ps aux | grep xxx</th><th>（功能描述：查看系统中所有进程）</th></tr></thead><tbody><tr><td>ps -ef | grep xxx  <strong>2</strong>）选项说明</td><td>（功能描述：可以查看子父进程之间的关系）</td></tr></tbody></table><p>表 7-30</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>列出带有终端的所有用户的进程</td></tr><tr><td>x</td><td>列出当前用户的所有进程，包括没有终端的进程</td></tr><tr><td>u</td><td>面向用户友好的显示风格</td></tr><tr><td>-e</td><td>列出所有进程</td></tr><tr><td>-u</td><td>列出某个用户关联的所有进程</td></tr><tr><td>-f</td><td>显示完整格式的进程列表</td></tr></tbody></table><p><strong>3</strong>）功能说明</p><p>（1）ps aux 显示信息说明</p><p>USER：该进程是由哪个用户产生的</p><p>PID：进程的 ID 号</p><p>%CPU：该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源； %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</p><p>VSZ：该进程占用虚拟内存的大小，单位 KB；</p><p>RSS：该进程占用实际物理内存的大小，单位 KB；</p><p>TTY：该进程是在哪个终端中运行的。对于 CentOS 来说，tty1 是图形化终端， tty2-tty6 是本地的字符界面终端。pts/0-255 代表虚拟终端。</p><p>STAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、</p><p>Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示</p><p>START：该进程的启动时间</p><p>TIME：该进程占用 CPU 的运算时间，注意不是系统时间</p><p>COMMAND：产生此进程的命令名</p><p>（2）ps -ef 显示信息说明</p><p>UID：用户 ID PID：进程 ID</p><p>PPID：父进程 ID</p><p>C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</p><p>STIME：进程启动的时间</p><p>TTY：完整的终端名称</p><p>TIME：CPU 时间</p><p>CMD：启动进程所用的命令和参数</p><p><strong>4）</strong>经验技巧如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux;</p><p>​    如果想查看进程的父进程 ID 可以使用 ef;</p><p><strong>5）</strong>案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 datas]# ps aux</span><br></pre></td></tr></table></figure><p>如图 1-161 所示</p><p><img src="https://image.3001.net/images/20221009/16652816026254.jpg" alt="img"></p><p>图 1-161 查看进程的 CPU 占用率和内存占用率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 datas]# ps -ef</span><br></pre></td></tr></table></figure><p>如图 7-8 所示</p><p><img src="https://image.3001.net/images/20221009/16652816027514.jpg" alt="img"></p><p>图 7-8 查看进程的父进程 ID</p><p><strong>7.10.2 kill</strong> 终止进程</p><p><strong>1）</strong>基本语法kill [选项] 进程号 （功能描述：通过进程号杀死进程） killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</p><p><strong>2）</strong>选项说明</p><p>表 7-31</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-9</td><td>表示强迫进程立即停止</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）   杀死浏览器进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 桌面]# kill -9 5102</span><br></pre></td></tr></table></figure><p>（2）   通过进程名称杀死进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 桌面]# killall firefox</span><br></pre></td></tr></table></figure><p><strong>7.10.3 pstree</strong> 查看进程树</p><p><strong>1）</strong>基本语法</p><p>pstree [选项]</p><p><strong>2）</strong>选项说明</p><p>表 7-32</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>显示进程的 PID</td></tr><tr><td>-u</td><td>显示进程的所属用户</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）   显示进程 pid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 datas]# pstree -p</span><br></pre></td></tr></table></figure><p>（2）   显示进程所属用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 datas]# pstree -u</span><br></pre></td></tr></table></figure><h4 id="7-10-4-top-实时监控系统进程状态"><a href="#7-10-4-top-实时监控系统进程状态" class="headerlink" title="7.10.4 top 实时监控系统进程状态"></a><strong>7.10.4 top</strong> 实时监控系统进程状态</h4><p><strong>1）</strong> 基本命令</p><p>top [选项]</p><p><strong>2）</strong> 选项说明</p><p>表 7-33</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当中可以执行的命令：</td></tr><tr><td>-i</td><td>使 top 不显示任何闲置或者僵死进程。</td></tr><tr><td>-p</td><td>通过指定监控进程 ID 来仅仅监控某个进程的状态。</td></tr></tbody></table><p><strong>3）</strong> 操作说明</p><p>表 7-34</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以 CPU 使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以 PID 排序</td></tr><tr><td>q</td><td>退出 top</td></tr></tbody></table><p><strong>4）</strong> 查询结果字段解释</p><p>第一行信息为任务队列信息</p><p>表 7-35</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>12:26:46</td><td>系统当前时间</td></tr><tr><td>up 1 day,  13:32</td><td>系统的运行时间，本机已经运行 1 天  13 小时 32 分钟</td></tr><tr><td>2 users</td><td>当前登录了两个用户</td></tr><tr><td>load average:  0.00, 0.00, 0.00</td><td>系统在之前 1 分钟，5 分钟，15 分钟的平均负载。一般认为小于 1 时，负载较小。如果大于  1，系统已经超出负荷。</td></tr></tbody></table><p>第二行为进程信息</p><p>表 7-36</p><table><thead><tr><th>Tasks: 95  total</th><th>系统中的进程总数</th></tr></thead><tbody><tr><td>1  running</td><td>正在运行的进程数</td></tr><tr><td>94  sleeping</td><td>睡眠的进程</td></tr><tr><td>0  stopped</td><td>正在停止的进程</td></tr><tr><td>0  zombie</td><td>僵尸进程。如果不是 0，需要手工检查僵尸进程</td></tr></tbody></table><p>第三行为 CPU 信息</p><p>表 7-37</p><table><thead><tr><th>Cpu(s):  0.1%us</th><th>用户模式占用的 CPU  百分比</th></tr></thead><tbody><tr><td>0.1%sy</td><td>系统模式占用的 CPU  百分比</td></tr><tr><td>0.0%ni</td><td>改变过优先级的用户进程占用的 CPU  百分比</td></tr><tr><td>99.7%id</td><td>空闲 CPU  的 CPU  百分比</td></tr><tr><td>0.1%wa</td><td>等待输入/输出的进程的占用 CPU  百分比</td></tr><tr><td>0.0%hi</td><td>硬中断请求服务占用的 CPU  百分比</td></tr><tr><td>0.1%si</td><td>软中断请求服务占用的 CPU  百分比</td></tr></tbody></table><p><img src="https://image.3001.net/images/20221009/16652816025830.gif" alt="img"></p><p>第四行为物理内存信息</p><p>表 7-38</p><table><thead><tr><th>Mem:  625344k total</th><th>物理内存的总量，单位 KB</th></tr></thead><tbody><tr><td>571504k  used</td><td>已经使用的物理内存数量</td></tr><tr><td>53840k  free</td><td>空闲的物理内存数量，我们使用的是虚拟机，总共只分配了  628MB 内存，所以只有 53MB  的空闲内存了</td></tr><tr><td>65800k  buffers</td><td>作为缓冲的内存数量</td></tr></tbody></table><p>第五行为交换分区（swap）信息</p><p>表 7-39</p><table><thead><tr><th>Swap:  524280k total</th><th>交换分区（虚拟内存）的总大小</th></tr></thead><tbody><tr><td>0k  used</td><td>已经使用的交互分区的大小</td></tr><tr><td>524280k  free</td><td>空闲交换分区的大小</td></tr><tr><td>409280k  cached</td><td>作为缓存的交互分区的大小</td></tr></tbody></table><p><strong>5）</strong> 案例实操</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 atguigu]# top -d 1</span><br><span class="line">[root@hadoop101 atguigu]# top -i</span><br><span class="line">[root@hadoop101 atguigu]# top -p 2575</span><br></pre></td></tr></table></figure><p>执行上述命令后，可以按 P、M、N 对查询出的进程结果进行排序。</p><p><strong>7.10.5 netstat</strong> 显示网络状态和端口占用信息</p><p><strong>1）</strong>基本语法netstat -anp | grep 进程号  （功能描述：查看该进程网络信息） netstat –nlp | grep 端口号 （功能描述：查看网络端口号占用情况）</p><p><strong>2）</strong>选项说明</p><p>表 7-40</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示所有正在监听（listen）和未监听的套接字（socket）</td></tr><tr><td>-n</td><td>拒绝显示别名，能显示数字的全部转化成数字</td></tr><tr><td>-l</td><td>仅列出在监听的服务状态</td></tr><tr><td>-p</td><td>表示显示哪个进程在调用</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）   通过进程号查看sshd进程的网络信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 hadoop-2.7.2]# netstat -anp | grep sshd</span><br><span class="line">tcp00 0.0.0.0:220.0.0.0:*LISTEN</span><br><span class="line">951/sshd</span><br><span class="line">tcp00 192.168.202.100:22192.168.202.1:57741</span><br><span class="line">ESTABLISHED 3380/sshd: root@pts</span><br><span class="line">tcp052 192.168.202.100:22192.168.202.1:57783</span><br><span class="line">ESTABLISHED 3568/sshd: root@pts</span><br><span class="line">tcp00 192.168.202.100:22192.168.202.1:57679</span><br><span class="line">ESTABLISHED 3142/sshd: root@pts</span><br><span class="line">tcp600 :::22:::*LISTEN</span><br><span class="line">951/sshd unix 2[ ]DGRAM395743568/sshd: root@pts unix 2[ ]DGRAM374523142/sshd: root@pts unix 2[ ]DGRAM486513380/sshd: root@pts</span><br><span class="line">unix 3[ ]STREAMCONNECTED21224951/sshd</span><br><span class="line">（2）查看某端口号是否被</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）   查看某端口号是否被占用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101桌面]# netstat -nltp | grep 22</span><br><span class="line">tcp00 192.168.122.1:530.0.0.0:*LISTEN</span><br><span class="line">1324/dnsmasq tcp00 0.0.0.0:220.0.0.0:*LISTEN</span><br><span class="line">951/sshd</span><br><span class="line">tcp60</span><br><span class="line">951/sshd0 :::22:::*LISTEN</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-11-crontab-系统定时任务"><a href="#7-11-crontab-系统定时任务" class="headerlink" title="7.11 crontab 系统定时任务"></a><strong>7.11 crontab</strong> 系统定时任务</h2><p><strong>7.11.1 crontab</strong> 服务管理</p><p><strong>1</strong>）重新启动 crond 服务</p><p>[root@hadoop101 ~]# systemctl restart crond</p><p><strong>7.11.2 crontab</strong> 定时任务设置</p><p><strong>1）</strong>基本语法</p><p>crontab [选项]</p><p><strong>2）</strong>选项说明</p><p>表 7-41</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>编辑 crontab  定时任务</td></tr><tr><td>-l</td><td>查询 crontab  任务</td></tr><tr><td>-r</td><td>删除当前用户所有的 crontab  任务</td></tr></tbody></table><p><strong>3）</strong>参数说明</p><p>[root@hadoop101 ~]# crontab -e</p><p>（1）进入 crontab 编辑界面。会打开 vim 编辑你的工作。</p><p>* * * * * 执行的任务</p><p>表 7-42</p><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个“*”</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td>第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个“*”</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个“*”</td><td>一周当中的星期几</td><td>0-7 （ 0  和 7  都代表星期日）</td></tr></tbody></table><p>（2）特殊符号</p><p>表 7-43</p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。</td></tr><tr><td>，</td><td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的 8  点 0  分，12  点 0  分，16  点 0  分都执行一次命令</td></tr><tr><td>-</td><td>代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周一到周六的凌晨  5 点 0  分执行命令</td></tr><tr><td>*/n</td><td>代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔 10  分钟就执行一遍命令</td></tr></tbody></table><p>（3）特定时间执行命令</p><p>表 7-44</p><table><thead><tr><th>时间</th><th>含义</th></tr></thead><tbody><tr><td>45  22 * * * 命令</td><td>每天 22 点 45  分执行命令</td></tr><tr><td>0  17 * * 1 命令</td><td>每周 1 的 17  点 0  分执行命令</td></tr><tr><td>0  5 1,15 * * 命令</td><td>每月 1 号和 15  号的凌晨 5  点 0  分执行命令</td></tr><tr><td>40  4 * * 1-5 命令</td><td>每周一到周五的凌晨 4 点 40  分执行命令</td></tr><tr><td>*/10  4 * * * 命令</td><td>每天的凌晨 4 点，每隔 10  分钟执行一次命令</td></tr><tr><td>0  0 1,15 * 1 命令</td><td>每月 1 号和 15  号，每周 1  的 0  点 0  分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。</td></tr></tbody></table><p><strong>4）</strong>案例实操</p><p>（1）每隔 1 分钟，向/root/bailongma.txt 文件中添加一个 11 的数字</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * /bin/<span class="keyword">echo</span> ”<span class="number">11</span>” &gt;&gt; /root/bailongma.txt</span><br></pre></td></tr></table></figure><h1 id="第-8-章软件包管理"><a href="#第-8-章软件包管理" class="headerlink" title="第 8 章软件包管理"></a>第 <strong>8</strong> 章软件包管理</h1><h1 id="8-1-RPM"><a href="#8-1-RPM" class="headerlink" title="8.1 RPM"></a><strong>8.1 RPM</strong></h1><p><strong>8.1.1 RPM</strong> 概述</p><p>RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe</p><p>是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p><p>RPM包的名称格式</p><p>Apache-1.3.23-11.i386.rpm</p><p>-    “apache” 软件名称</p><p>-    “1.3.23-11”软件的版本号，主版本和此版本</p><p>-    “i386”是软件所运行的硬件平台，Intel 32位处理器的统称</p><p>-    “rpm”文件扩展名，代表RPM包</p><p><strong>8.1.2 RPM</strong> 查询命令（<strong>rpm -qa</strong>）</p><p><strong>1）</strong>基本语法rpm -qa  （功能描述：查询所安装的所有 rpm 软件包）</p><p><strong>2）</strong>经验技巧由于软件包比较多，一般都会采取过滤。rpm -qa | grep rpm软件包</p><p><strong>3）</strong>案例实操</p><p>（1）查询firefox软件安装情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 Packages]# rpm -qa |grep firefox firefox-45.0.1-1.el6.centos.x86_64</span><br></pre></td></tr></table></figure><p>(2) 查询firefox软件安装包安装情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 Packages]# rpm -qi grep firefox </span><br></pre></td></tr></table></figure><p><strong>8.1.3 RPM</strong> 卸载命令（<strong>rpm -e</strong>）</p><p><strong>1）</strong>基本语法</p><p>（1） rpm -e RPM软件包</p><p>（2） rpm -e –nodeps 软件包</p><p><strong>2）</strong>选项说明</p><p>表 8-1</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>卸载软件包</td></tr><tr><td>–nodeps</td><td>卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件</td></tr></tbody></table><p><img src="https://image.3001.net/images/20221009/16652816012041.gif" alt="img"></p><p><strong>3）</strong>案例实操</p><p>（1） 卸载firefox软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 Packages]# rpm -e firefox</span><br></pre></td></tr></table></figure><p><strong>8.1.4 RPM</strong> 安装命令（<strong>rpm -ivh</strong>）</p><p><strong>1）</strong>基本语法</p><p>rpm -ivh RPM 包全名</p><p><strong>2）</strong>选项说明</p><p>表 8-2</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-i</td><td>install，安装</td></tr><tr><td>-v</td><td>–verbose，显示详细信息</td></tr><tr><td>-h</td><td>–hash，进度条</td></tr><tr><td>–nodeps</td><td>安装前不检查依赖</td></tr></tbody></table><p><strong>3）</strong>案例实操</p><p>（1）安装firefox软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 Packages]# pwd</span><br><span class="line">/run/media/root/CentOS 7 x86_64/Packages</span><br><span class="line">[root@hadoop101 Packages]# rpm -ivh firefox-45.0.1-1.el6.centos.x86_64.rpm warning: firefox-45.0.1-1.el6.centos.x86_64.rpm: Header V3 RSA/SHA1</span><br><span class="line">Signature, key ID c105b9de: NOKEY</span><br><span class="line">Preparing...###########################################</span><br><span class="line">[100%]</span><br><span class="line">1:firefox###########################################</span><br><span class="line">[100%]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8-2-YUM-仓库配置"><a href="#8-2-YUM-仓库配置" class="headerlink" title="8.2 YUM 仓库配置"></a><strong>8.2 YUM</strong> 仓库配置</h1><p><strong>8.2.1</strong> <strong>YUM</strong> 概述</p><p>YUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS</p><p>中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装，如图 8-1 所示</p><p><img src="https://image.3001.net/images/20221009/16652816017318.jpg" alt="img"></p><p>图 8-1 YUM 概述</p><p><strong>8.2.2</strong> <strong>YUM</strong> 的常用命令</p><p><strong>1）</strong>  基本语法</p><p>yum [选项] [参数]</p><p><strong>2）</strong>  选项说明</p><p>表 8-3</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-y</td><td>对所有提问都回答“yes”</td></tr></tbody></table><p><strong>3）</strong>  参数说明</p><p>表 8-4</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>install</td><td>安装 rpm  软件包</td></tr><tr><td>update</td><td>更新 rpm  软件包</td></tr><tr><td>check-update</td><td>检查是否有可用的更新 rpm  软件包</td></tr><tr><td>remove</td><td>删除指定的 rpm  软件包</td></tr><tr><td>list</td><td>显示软件包信息</td></tr><tr><td>clean</td><td>清理 yum  过期的缓存</td></tr><tr><td>deplist</td><td>显示 yum  软件包的所有依赖关系</td></tr></tbody></table><p><strong>4）</strong>  案例实操实操</p><p>（1）采用 yum 方式安装 firefox</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]#yum -y install firefox</span><br></pre></td></tr></table></figure><p><strong>8.2.3</strong> 修改网络 <strong>YUM</strong> 源</p><p>默认的系统 YUM 源，需要连接国外 apache 网站，网速比较慢，可以修改关联的网络</p><p>YUM 源为国内镜像的网站，比如网易 163,aliyun 等</p><p><strong>1）</strong>  安装 wget, wget 用来从指定的 URL 下载文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~] yum install wget</span><br></pre></td></tr></table></figure><p><strong>2）</strong>  在/etc/yum.repos.d/目录下，备份默认的 repos 文件,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 yum.repos.d] pwd</span><br><span class="line">/etc/yum.repos.d</span><br><span class="line">[root@hadoop101 yum.repos.d] cp CentOS-Base.repo .repo.backupCentOS-Base</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3）</strong>  下载网易 163 或者是 aliyun 的 repos 文件,任选其一，如图 8-2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 yum.repos.d] wget http://mirrors.aliyun.com/repo/Centos-7.repo #阿里云</span><br><span class="line"></span><br><span class="line">[root@hadoop101 yum.repos.d] wget http://mirrors.163.com/.help/CentOS7-Base-163.repo #网易163</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20221009/16652816017849.jpg" alt="img"></p><p>图 8-2 <strong>4</strong>）使用下载好的 repos 文件替换默认的 repos 文件</p><p>例如:用 CentOS7-Base-163.repo 替换 CentOS-Base.repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 yum.repos.d]# mv CentOS7-Base-163.repoCentOS-Base.repo</span><br></pre></td></tr></table></figure><p><strong>5</strong>）清理旧缓存数据，缓存新数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 yum.repos.d]#yum clean all</span><br><span class="line">[root@hadoop101 yum.repos.d]#yum makecache</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>yum makecache 就是把服务器的包信息下载到本地电脑缓存起来</p><p><strong>6</strong>）测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 yum.repos.d]# yum list | grep firefox</span><br><span class="line">[root@hadoop101 ~]#yum -y install firefox</span><br></pre></td></tr></table></figure><h1 id="第9章克隆虚拟机"><a href="#第9章克隆虚拟机" class="headerlink" title="第9章克隆虚拟机"></a>第<strong>9</strong>章克隆虚拟机</h1><p><strong>9.1</strong> 克隆</p><p><strong>1）</strong>  从现有虚拟机(关机状态)克隆出新虚拟机，右键选择管理=&gt;克隆，如图 9-1</p><p><img src="https://image.3001.net/images/20221009/16652816027361.jpg" alt="img"></p><p>图 9-1</p><p><strong>2）</strong>  点击下一步,如图 9-2</p><p><img src="https://image.3001.net/images/20221009/16652816024993.jpg" alt="img"></p><p>图 9-2</p><p><strong>3）</strong>  选择虚拟机中的当前状态,如图 9-3</p><p><img src="https://image.3001.net/images/20221009/16652816028336.jpg" alt="img"></p><p>图 9-3</p><p><strong>4）</strong>  选择创建完整克隆，如图 9-4</p><p><img src="https://image.3001.net/images/20221009/16652816029486.jpg" alt="img"></p><p>图 9-4</p><p><strong>5）</strong>  设置虚拟机名称及存储位置，如图 9-5</p><p><img src="https://image.3001.net/images/20221009/16652816028125.jpg" alt="img"></p><p>图 9-5</p><p><strong>6）</strong>  等等等……等待克隆完成，如图 9-6,9-7</p><p><img src="https://image.3001.net/images/20221009/16652816012990.jpg" alt="img"></p><p>图 9-6</p><p><img src="https://image.3001.net/images/20221009/16652816028081.jpg" alt="img"></p><p>图 9-7</p><p><strong>9.2</strong> 开机修改系统相关配置</p><p>注意: 使用 root 用户。</p><p><strong>1</strong>）修改 vim /etc/sysconfig/network-scripts/ifcfg-ens33 ,修改 IP 地址,如图 9-8 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20221009/16652816017784.jpg" alt="img"></p><p>图 9-8 <strong>2</strong>）修改 /etc/hostname ,修改主机名,如图 9-9 vim /etc/hostname</p><p><img src="https://image.3001.net/images/20221009/16652816012674.jpg" alt="img"></p><p>图 9-9</p><h1 id="第-10-章常见错误及解决方案"><a href="#第-10-章常见错误及解决方案" class="headerlink" title="第 10 章常见错误及解决方案"></a>第 <strong>10</strong> 章常见错误及解决方案</h1><p><strong>1</strong>）虚拟化支持异常情况如下几种情况</p><p><img src="https://image.3001.net/images/20221009/16652816025024.jpg" alt="img"></p><p>图 10-1</p><p><img src="https://image.3001.net/images/20221009/16652816027706.jpg" alt="img"></p><p>图10-2</p><p><img src="https://image.3001.net/images/20221009/16652816027033.jpg" alt="img"></p><p>图10-3</p><p><img src="https://image.3001.net/images/20221009/16652816016913.jpg" alt="img"></p><p>图 10-4</p><p>问题原因：宿主机 BIOS 设置中的硬件虚拟化被禁用了解决办法：需要打开笔记本 BIOS 中的 IVT 对虚拟化的支持</p><p><img src="https://image.3001.net/images/20221009/16652816029585.jpg" alt="img"></p><p>图 10-5 </p><h1 id="第-11-章企业真实面试题"><a href="#第-11-章企业真实面试题" class="headerlink" title="第 11 章企业真实面试题"></a>第 <strong>11</strong> 章企业真实面试题</h1><p><strong>11.1</strong> 百度**&amp;**考满分</p><p>问题：Linux 常用命令参考答案：find、df、tar、ps、top、netstat等。（尽量说一些高级命令）</p><p><strong>11.2</strong> 瓜子二手车</p><p>问题：Linux 查看内存、磁盘存储、io 读写、端口占用、进程等命令</p><p>答案：</p><p>1、查看内存：top</p><p>2、查看磁盘存储情况：df -h</p><p>3、查 看磁盘IO读写情况：iotop（需要安装一下：yum install iotop）、 iotop -o（直接查看输出比较高的磁盘读写程序）</p><p>4、查看端口占用情况：netstat -tunlp | grep 端口号</p><p>5、查看进程：ps -aux</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;尚硅谷高级技术之-Linux&quot;&gt;&lt;a href=&quot;#尚硅谷高级技术之-Linux&quot; class=&quot;headerlink&quot; title=&quot;尚硅谷高级技术之 Linux&quot;&gt;&lt;/a&gt;尚硅谷高级技术之 Linux&lt;/h1&gt;&lt;h1 id=&quot;第-1-章-Linux-入门&quot;&gt;&lt;a href=&quot;#第-1-章-Linux-入门&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 Linux 入门&quot;&gt;&lt;/a&gt;第 &lt;strong&gt;1&lt;/strong&gt; 章 &lt;strong&gt;Linux&lt;/strong&gt; 入门&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1.1&lt;/strong&gt; 概述如图 1-1 所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20221009/16652816012747.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux+shell" scheme="https://yangmour.github.io/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>VMware 安装</title>
    <link href="https://yangmour.github.io/2022/10/08/%E5%A4%A7%E6%95%B0%E6%8D%AE/linux+shell/VMware%20%E5%AE%89%E8%A3%85/"/>
    <id>https://yangmour.github.io/2022/10/08/%E5%A4%A7%E6%95%B0%E6%8D%AE/linux+shell/VMware%20%E5%AE%89%E8%A3%85/</id>
    <published>2022-10-08T05:06:17.000Z</published>
    <updated>2022-10-09T04:45:09.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VMware-安装"><a href="#VMware-安装" class="headerlink" title="VMware 安装"></a>VMware 安装</h2><p>[TOC]</p><p>尚硅谷高级技术之 Linux（环境准备）</p><p>（作者：尚硅谷研究院）</p><h1 id="第-1-章-VMware"><a href="#第-1-章-VMware" class="headerlink" title="第 1 章 VMware"></a>第 1 章 VMware</h1><h2 id="1-1-VMware-安装"><a href="#1-1-VMware-安装" class="headerlink" title="1.1 VMware 安装"></a>1.1 VMware 安装</h2><p>一台电脑本身是可以装多个操作系统的，但是做不到多个操作系统切换自如，所以我们需要一款软件帮助我们达到这个目的，不然数仓项目搭建不起来。</p><p>推荐的软件为 VMware，VMware 可以使用户在一台计算机上同时运行多个操作系统，还可以像 Windows 应用程序一样来回切换。用户可以如同操作真实安装的系统一样操作虚拟机系统，甚至可以在一台计算机上将几个虚拟机系统连接为一个局域网或者连接到互联网。</p><span id="more"></span><p>以下是 VMware Workstation Pro 15.5 的安装步骤。</p><h3 id="1-1-1-VMware-Workstation-Pro-15-5-安装包"><a href="#1-1-1-VMware-Workstation-Pro-15-5-安装包" class="headerlink" title="1.1.1 VMware Workstation Pro 15.5 安装包"></a><strong>1.1.1 VMware Workstation Pro 15.5</strong> 安装包</h3><p><img src="https://image.3001.net/images/20221008/16652200217745.gif" alt="img"></p><h3 id="1-2-2-欢迎界面"><a href="#1-2-2-欢迎界面" class="headerlink" title="1.2.2 欢迎界面"></a><strong>1.2.2</strong> 欢迎界面</h3><p><img src="https://image.3001.net/images/20221008/16652200219921.gif" alt="img"></p><h3 id="1-2-3-同意许可证"><a href="#1-2-3-同意许可证" class="headerlink" title="1.2.3 同意许可证"></a><strong>1.2.3</strong> 同意许可证</h3><p><img src="https://image.3001.net/images/20221008/16652200218929.gif" alt="img"></p><p><img src="https://image.3001.net/images/20221008/16652200217265.gif" alt="img"></p><p>每次开启虚拟机时，会提醒让你更新版本，建议两个都不勾。</p><p><img src="https://image.3001.net/images/20221008/16652200224286.gif" alt="img"></p><p>建议勾选，安装后使用起来会比较方便。</p><p><img src="https://image.3001.net/images/20221008/16652200219795.gif" alt="img"></p><h3 id="1-2-7-开始安装"><a href="#1-2-7-开始安装" class="headerlink" title="1.2.7 开始安装"></a><strong>1.2.7</strong> 开始安装</h3><p><img src="https://image.3001.net/images/20221008/16652200229140.gif" alt="img"></p><p><img src="https://image.3001.net/images/20221008/16652200219402.gif" alt="img"></p><p>输入许可证，激活 VMware。</p><p>注：如果点击的是完成也没关系，后面还是输入许可证的。</p><p><img src="file:///C:/Users/xiwen/AppData/Local/Temp/msohtmlclip1/01/clip_image018.gif" alt="img"></p><p><strong>1</strong>）生成许可证**(<strong>在当时安装包的同名的目录下</strong>)**</p><p><img src="https://image.3001.net/images/20221008/16652200214819.gif" alt="img"></p><p><img src="https://image.3001.net/images/20221008/1665220021497.gif" alt="img"></p><h3 id="1-2-11-VMware-安装完毕"><a href="#1-2-11-VMware-安装完毕" class="headerlink" title="1.2.11 VMware 安装完毕"></a><strong>1.2.11 VMware</strong> 安装完毕</h3><p><img src="https://image.3001.net/images/20221008/16652200229047.gif" alt="img"></p><p>桌面上的快捷方式，双击它就可以使用啦。</p><h1 id="第-2-章-CentOS"><a href="#第-2-章-CentOS" class="headerlink" title="第 2 章 CentOS"></a>第 2 章 CentOS</h1><p>系统的安装得分两个步骤，第一步得配置一台电脑，选配cpu，内存，磁盘，网卡等硬件。第二步才是安装系统。</p><h2 id="2-1-配置电脑"><a href="#2-1-配置电脑" class="headerlink" title="2.1 配置电脑"></a>2.1 配置电脑</h2><p><strong>2.1.1</strong> 进入 <strong>VMware</strong> 双击 VMware 图标，看到如下界面。</p><p><img src="https://image.3001.net/images/20221008/16652200226932.gif" alt="img"></p><h3 id="2-1-2-自定义新的虚拟机"><a href="#2-1-2-自定义新的虚拟机" class="headerlink" title="2.1.2 自定义新的虚拟机"></a><strong>2.1.2</strong> 自定义新的虚拟机</h3><p><img src="https://image.3001.net/images/20221008/16652200211450.gif" alt="img"></p><h3 id="2-1-3-解决虚拟机的兼容性"><a href="#2-1-3-解决虚拟机的兼容性" class="headerlink" title="2.1.3 解决虚拟机的兼容性"></a><strong>2.1.3</strong> 解决虚拟机的兼容性</h3><p><img src="https://image.3001.net/images/20221008/16652200216776.gif" alt="img"></p><h3 id="2-1-4-选择当前虚拟机的操作系统"><a href="#2-1-4-选择当前虚拟机的操作系统" class="headerlink" title="2.1.4 选择当前虚拟机的操作系统"></a><strong>2.1.4</strong> 选择当前虚拟机的操作系统</h3><p><img src="file:///C:/Users/xiwen/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif" alt="img"></p><h3 id="2-1-5-选择虚拟机将来需要安装的系统"><a href="#2-1-5-选择虚拟机将来需要安装的系统" class="headerlink" title="2.1.5 选择虚拟机将来需要安装的系统"></a><strong>2.1.5</strong> 选择虚拟机将来需要安装的系统</h3><p>因为不同的操作系统需要解决不同的兼容性问题，所以需要选择将来用什么系统，提前做适配。</p><p><img src="file:///C:/Users/xiwen/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif" alt="img"></p><p>给自己配置电脑取个名字，并存放在物理机的位置在哪。</p><p><img src="https://image.3001.net/images/20221008/16652200225601.gif" alt="img"></p><p>有个原则就是选满（跟物理机的 CPU 个数相同，但是不能超过）。</p><p><strong>1）</strong>  查看物理机 <strong>CPU</strong> 个数（<strong>windows10</strong> 为例）</p><p><img src="https://image.3001.net/images/20221008/16652200224393.gif" alt="img"></p><p><strong>2）</strong>  设置虚拟机处理器的数量</p><p><img src="https://image.3001.net/images/20221008/16652200215953.gif" alt="img"></p><p>内存大小有一定要求，建议 4g，不能给太多，后期会有多台虚拟机同时启动。</p><p><img src="https://image.3001.net/images/20221008/16652200225472.gif" alt="img"></p><h3 id="2-1-9-选择虚拟机上网方式"><a href="#2-1-9-选择虚拟机上网方式" class="headerlink" title="2.1.9 选择虚拟机上网方式"></a><strong>2.1.9</strong> 选择虚拟机上网方式</h3><p><img src="https://image.3001.net/images/20221008/16652200229167.gif" alt="img"></p><p>2）  没有 VMware 之前物理机的网络适配器信息（每个人不同，我只有 3 个）</p><p><img src="https://image.3001.net/images/20221008/16652200222844.gif" alt="img"></p><p>3）  安装 VMware 之后物理机的网络适配器信息（会多两个 vmnet1 和 vmnet8）</p><p><img src="https://image.3001.net/images/20221008/16652200225527.gif" alt="img"></p><p>注：vmnet8 是虚拟机使用 NAT 模式上网的网卡</p><h3 id="2-1-10-选择对应的文件系统的-IO-方式"><a href="#2-1-10-选择对应的文件系统的-IO-方式" class="headerlink" title="2.1.10 选择对应的文件系统的 IO 方式"></a><strong>2.1.10</strong> 选择对应的文件系统的 <strong>IO</strong> 方式</h3><p><img src="https://image.3001.net/images/20221008/16652200225008.gif" alt="img"></p><h3 id="2-1-11-选择磁盘的类型"><a href="#2-1-11-选择磁盘的类型" class="headerlink" title="2.1.11 选择磁盘的类型"></a><strong>2.1.11</strong> 选择磁盘的类型</h3><p><img src="https://image.3001.net/images/20221008/16652200228110.gif" alt="img"></p><h3 id="2-1-12-选择磁盘的种类"><a href="#2-1-12-选择磁盘的种类" class="headerlink" title="2.1.12 选择磁盘的种类"></a><strong>2.1.12</strong> 选择磁盘的种类</h3><p><img src="file:///C:/Users/xiwen/AppData/Local/Temp/msohtmlclip1/01/clip_image056.gif" alt="img"></p><p><img src="https://image.3001.net/images/20221008/16652200211567.gif" alt="img"></p><h3 id="1-1-14-虚拟机文件的存放位置"><a href="#1-1-14-虚拟机文件的存放位置" class="headerlink" title="1.1.14 虚拟机文件的存放位置"></a><strong>1.1.14</strong> 虚拟机文件的存放位置</h3><p><img src="https://image.3001.net/images/20221008/16652200224946.gif" alt="img"></p><h3 id="2-1-14-电脑配置完毕"><a href="#2-1-14-电脑配置完毕" class="headerlink" title="2.1.14 电脑配置完毕"></a><strong>2.1.14</strong> 电脑配置完毕</h3><p><img src="https://image.3001.net/images/20221008/16652200228401.gif" alt="img"></p><h2 id="2-2-安装系统（CentOS7）"><a href="#2-2-安装系统（CentOS7）" class="headerlink" title="2.2 安装系统（CentOS7）"></a>2.2 安装系统（CentOS7）</h2><p>（1） window7 里面看不到（得去 bios 里面看）</p><p><img src="https://image.3001.net/images/20221008/16652200223107.gif" alt="img"></p><p>注：在安装系统之前需要检查自己 bios 的虚拟化设置是否打开（大部分的电脑都是打</p><p>开的，大家可以先尝试直接安装，如果出现错误再去调试，没有出错就不用管了）以下是查看虚拟机 bios 是否开启的方式。</p><p><img src="https://image.3001.net/images/20221008/16652200229490.gif" alt="img"></p><p>（2） window7 里面看不到（得去 bios 里面看）</p><p>（3） 如果发现 bios 虚拟化没有开启怎么办，重启电脑，在加载界面时按 f1-f10,或者电脑旁边一个小洞，具体怎么进入得去查一下（按照自己电脑的型号去查）</p><p>（4） 修改虚拟化为开启（thinkpad 为例）找到 security 里面的 VT 并改成 enabled</p><p><img src="file:///C:/Users/xiwen/AppData/Local/Temp/msohtmlclip1/01/clip_image068.gif" alt="img"></p><p><img src="https://image.3001.net/images/20221008/16652200229903.gif" alt="img"></p><h3 id="2-2-1-选择-cd-dvd-的方式安装系统"><a href="#2-2-1-选择-cd-dvd-的方式安装系统" class="headerlink" title="2.2.1 选择 cd/dvd 的方式安装系统"></a><strong>2.2.1</strong> 选择 <strong>cd/dvd</strong> 的方式安装系统</h3><p><img src="https://image.3001.net/images/20221008/16652200228193.gif" alt="img"></p><p><img src="https://image.3001.net/images/20221008/16652202879963.png" alt="image-20221008171117368"></p><p><img src="https://image.3001.net/images/20221008/166522029411.png" alt="image-20221008171124541"></p><h3 id="2-2-2系统安装引导界面"><a href="#2-2-2系统安装引导界面" class="headerlink" title="2.2.2系统安装引导界面"></a>2.2.2系统安装引导界面</h3><p>​    你得需要将鼠标点击进入界面中，但是鼠标会消失，你此刻得用键盘的上下键来控制选项，图标变白了表示当前选中的是哪个选项，然后敲回车，表示执行所选选项。</p><p>​    注：如果这个时候你需要鼠标可以使用 ctrl+alt 一起按呼出鼠标。</p><p><img src="https://image.3001.net/images/20221008/16652203573341.png" alt="image-20221008171226929"></p><p><img src="https://image.3001.net/images/20221008/1665220379976.png" alt="image-20221008171249619"></p><p><img src="https://image.3001.net/images/20221008/16652203916205.png" alt="image-20221008171300884"></p><h3 id="2-2-3需要定制化的内容"><a href="#2-2-3需要定制化的内容" class="headerlink" title="2.2.3需要定制化的内容"></a>2.2.3需要定制化的内容</h3><p>按照编号依次点击。</p><p><img src="https://image.3001.net/images/20221008/16652204264895.png" alt="image-20221008171335946"></p><p><strong>1）</strong>调整时间差</p><p><img src="https://image.3001.net/images/20221008/16652204338995.png" alt="image-20221008171343312"></p><p><strong>2）</strong>安装 <strong>GHOME</strong>（图形化界面的方式）注意图上标注的点击顺序</p><p><img src="https://image.3001.net/images/20221008/166522044374.png" alt="image-20221008171353253"></p><p>3）配置磁盘分区</p><p><img src="https://image.3001.net/images/20221008/16652204751248.png" alt="image-20221008171424531"></p><p>（1） 手动添加分区</p><p><img src="https://image.3001.net/images/20221008/16652204821989.png" alt="image-20221008171432552"></p><p>（2） 添加 boot 区 给上 1G 容量后点击添加挂载点</p><p><img src="https://image.3001.net/images/20221008/16652204896187.png" alt="image-20221008171439138"></p><p><img src="https://image.3001.net/images/20221008/16652205016279.png" alt="image-20221008171451163"></p><p>（3） 添加 swap 交换分区</p><p><img src="https://image.3001.net/images/20221008/16652205088206.png" alt="image-20221008171458050"></p><p><img src="https://image.3001.net/images/20221008/16652205158145.png" alt="image-20221008171505172"></p><p><img src="https://image.3001.net/images/20221008/16652205298304.png" alt="image-20221008171519165"></p><p>（4） 配置根(/)目录</p><p><img src="https://image.3001.net/images/20221008/16652205376901.png" alt="image-20221008171527545"></p><p>根目录作为存储使用，将剩下的空间都给他（50 - 4 - 1）= 45</p><p><img src="https://image.3001.net/images/20221008/16652205477345.png" alt="image-20221008171536855"></p><p>3 个分区都配置完毕过后可以点击完成。</p><p><img src="https://image.3001.net/images/20221008/16652205598677.png" alt="image-20221008171548990"></p><p>（5）分区配置完毕，点击接受更改</p><p><img src="https://image.3001.net/images/20221008/16652205662222.png" alt="image-20221008171555486"></p><p><strong>4</strong>）关闭 <strong>kdump</strong> 本身虚拟机内存就不够，他会吃掉一部分内存，我们尽量省一点</p><p><img src="https://image.3001.net/images/20221008/16652205756469.png" alt="image-20221008171604623"></p><p>5）修改主机名</p><p><img src="https://image.3001.net/images/20221008/16652206029733.png" alt="image-20221008171632037"></p><p>6）是否打开安全协议（开启与否都可以）</p><p><img src="https://image.3001.net/images/20221008/16652206286481.png" alt="image-20221008171658263"></p><p><strong>7）</strong>开始安装</p><p><img src="https://image.3001.net/images/20221008/1665220635779.png" alt="image-20221008171705269"></p><p><strong>8）</strong>安装时间比较长 大概需要 <strong>10</strong> 几分钟（设置 <strong>root</strong> 用户密码，一定要设置）</p><p><img src="https://image.3001.net/images/20221008/16652206426598.png" alt="image-20221008171711892"></p><p>密码设置成什么自己决定，但是不要忘，建议使用（123456）</p><p><img src="https://image.3001.net/images/20221008/16652206523854.png" alt="image-20221008171722274"></p><h3 id="2-2-4-虚拟机的使用引导界面"><a href="#2-2-4-虚拟机的使用引导界面" class="headerlink" title="2.2.4 虚拟机的使用引导界面"></a>2.2.4 虚拟机的使用引导界面</h3><p>1）安装完成重启虚拟机</p><p><img src="https://image.3001.net/images/20221008/16652206918563.png" alt="image-20221008171734562"></p><p><strong>2</strong>）进入引导界面**(<strong>以下内容就按照图片走，就不做过多解释</strong>)**</p><p><img src="https://image.3001.net/images/20221008/1665220714824.png" alt="image-20221008171824156"></p><p><img src="https://image.3001.net/images/20221008/16652207208897.png" alt="image-20221008171830223"></p><p><img src="https://image.3001.net/images/20221008/16652207261915.png" alt="image-20221008171836116"></p><p><img src="https://image.3001.net/images/20221008/16652207311576.png" alt="image-20221008171840839"></p><p><img src="https://image.3001.net/images/20221008/16652207373932.png" alt="image-20221008171846536"></p><p><img src="https://image.3001.net/images/20221008/16652207449893.png" alt="image-20221008171853949"></p><p><img src="https://image.3001.net/images/20221008/16652207518367.png" alt="image-20221008171900785"></p><p><img src="https://image.3001.net/images/20221008/16652207583151.png" alt="image-20221008171908121"></p><p><img src="https://image.3001.net/images/20221008/16652207634770.png" alt="image-20221008171913296"></p><p><img src="https://image.3001.net/images/20221008/16652207699318.png" alt="image-20221008171919078"></p><h3 id="2-2-5-切换-root-用户"><a href="#2-2-5-切换-root-用户" class="headerlink" title="2.2.5 切换 root 用户"></a><strong>2.2.5</strong> 切换 <strong>root</strong> 用户</h3><p>当前登录的用户是刚刚创建的用户，权限会缺少，所以使用 root，修改一些内容更加方</p><p>便。</p><p><img src="https://image.3001.net/images/20221008/16652207782311.png" alt="image-20221008171928414"></p><p>1）切换 root 用户</p><p><img src="https://image.3001.net/images/20221008/16652207876076.png" alt="image-20221008171937334"></p><p><img src="https://image.3001.net/images/20221008/16652207932984.png" alt="image-20221008171943468"></p><p>刚才的引导再来一遍（就不再放图片了）。</p><p><img src="https://image.3001.net/images/20221008/16652208005515.png" alt="image-20221008171949877"></p><p>最后的用户变成 root 表示切换成功。</p><h2 id="2-3-网络配置"><a href="#2-3-网络配置" class="headerlink" title="2.3 网络配置"></a><strong>2.3</strong> 网络配置</h2><p>​    对安装好的 VMware 进行网络配置，方便虚拟机连接网络，本次设置建议选择 NAT 模式，需要宿主机的 Windows 和虚拟机的 Linux 能够进行网络连接，同时虚拟机的 Linux 可以通过宿主机的 Windows 进入互联网。</p><h4 id="2-3-1-编辑-VMware-的网络配置"><a href="#2-3-1-编辑-VMware-的网络配置" class="headerlink" title="2.3.1 编辑 VMware 的网络配置"></a>2.3.1 编辑 VMware 的网络配置</h4><p><img src="https://image.3001.net/images/20221008/16652208273569.png" alt="image-20221008172016936"></p><p><img src="https://image.3001.net/images/20221008/16652208337244.png" alt="image-20221008172022756"></p><p><img src="https://image.3001.net/images/20221008/16652208395162.png" alt="image-20221008172029448"></p><p><img src="https://image.3001.net/images/20221008/1665220847534.png" alt="image-20221008172036979"></p><p>然后全部点击确定，VMware 的网络配置就好了。</p><h4 id="2-3-2-windows-的网络配置"><a href="#2-3-2-windows-的网络配置" class="headerlink" title="2.3.2 windows 的网络配置"></a>2.3.2 windows 的网络配置</h4><p>以下以 window10 为例。</p><p>1）找到</p><p><img src="https://image.3001.net/images/20221008/16652208576371.png" alt="image-20221008172047299"></p><p><img src="https://image.3001.net/images/20221008/16652208623753.png" alt="image-20221008172052129"></p><p><img src="https://image.3001.net/images/20221008/16652208677826.png" alt="image-20221008172057033"></p><p><img src="https://image.3001.net/images/20221008/16652208769124.png" alt="image-20221008172106037"></p><p><img src="https://image.3001.net/images/20221008/1665220883200.png" alt="image-20221008172113196"></p><p><img src="https://image.3001.net/images/20221008/16652208907618.png" alt="image-20221008172119856"></p><p>按如上格式修改 IP 信息（地址，网关，DNS 服务器），修改完毕后全部点击确定退出。</p><h2 id="2-4-虚拟机网络-IP-修改地址配置"><a href="#2-4-虚拟机网络-IP-修改地址配置" class="headerlink" title="2.4 虚拟机网络 IP 修改地址配置"></a><strong>2.4</strong> 虚拟机网络 <strong>IP</strong> 修改地址配置</h2><p>（1）修改网络 IP 地址为静态 IP 地址，避免 IP 地址经常变化，从而方便节点服务器间</p><p>的互相通信。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p>（2）以下加粗的项必须修改，有值的按照下面的值修改，没有该项的则需要增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;#网络类型（通常是Ethemet）</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot; #IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;e83804c1-3257-4584-81bb-660665ac22f6&quot; #随机id</span><br><span class="line">DEVICE=&quot;ens33&quot; #接口名（设备,网卡）</span><br><span class="line">ONBOOT=&quot;yes&quot; #系统启动的时候网络接口是否有效（yes/no） #IP地址</span><br><span class="line">IPADDR=192.168.10.100</span><br><span class="line">#网关</span><br><span class="line">GATEWAY=192.168.10.2</span><br><span class="line">#域名解析器</span><br><span class="line">DNS1=192.168.10.2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）修改 IP 地址后的结果如图所示，执行“:wq”命令，保存退出</p><p><img src="https://image.3001.net/images/20221008/16652211087860.png" alt="image-20221008172458159"></p><p>（4）执行 systemctl restart network 命令，重启网络服务。如果报错，则执行“reboot”</p><p>命令，重启虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# systemctl restart network</span><br></pre></td></tr></table></figure><p>（5）使用 ifconfig 命令查看当前 IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20221008/1665221132134.png" alt="image-20221008172522133"></p><p>（6）保证 Linux 系统 ifcfg-ens33 文件中 IP 地址、虚拟网络编辑器地址和 Windows 系</p><h2 id="统-VM8-网络-IP-地址相同-2-5-修改主机名和-hosts-文件"><a href="#统-VM8-网络-IP-地址相同-2-5-修改主机名和-hosts-文件" class="headerlink" title="统 VM8 网络 IP 地址相同 2.5 修改主机名和 hosts 文件"></a>统 VM8 网络 IP 地址相同 2.5 修改主机名和 hosts 文件</h2><p><strong>1）</strong>修改主机名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/hostname hadoop100</span><br></pre></td></tr></table></figure><p><strong>2）</strong>配置 <strong>Linux</strong> 克隆机主机名称映射 <strong>hosts</strong> 文件，打开**/etc/hosts**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/hosts</span><br></pre></td></tr></table></figure><p>添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.100 hadoop100</span><br><span class="line"></span><br><span class="line">192.168.10.101 hadoop101</span><br><span class="line"></span><br><span class="line">192.168.10.102 hadoop102</span><br><span class="line"></span><br><span class="line">192.168.10.103 hadoop103</span><br><span class="line"></span><br><span class="line">192.168.10.104 hadoop104</span><br><span class="line"></span><br><span class="line">192.168.10.105 hadoop105</span><br><span class="line"></span><br><span class="line">192.168.10.106 hadoop106</span><br><span class="line"></span><br><span class="line">192.168.10.107 hadoop107</span><br><span class="line"></span><br><span class="line">192.168.10.108 hadoop108</span><br></pre></td></tr></table></figure><p><strong>3）</strong>重启克隆机 <strong>hadoop102</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# reboot</span><br></pre></td></tr></table></figure><p><strong>4）</strong>修改 <strong>windows</strong> 的主机映射文件（<strong>hosts</strong> 文件）</p><p>（1）如果操作系统是 window7，可以直接修改</p><p>①进入 C:\Windows\System32\drivers\etc 路径</p><p>②打开 hosts 文件并添加如下内容，然后保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.100 hadoop100</span><br><span class="line"></span><br><span class="line">192.168.10.101 hadoop101</span><br><span class="line"></span><br><span class="line">192.168.10.102 hadoop102</span><br><span class="line"></span><br><span class="line">192.168.10.103 hadoop103</span><br><span class="line"></span><br><span class="line">192.168.10.104 hadoop104</span><br><span class="line"></span><br><span class="line">192.168.10.105 hadoop105</span><br><span class="line"></span><br><span class="line">192.168.10.106 hadoop106</span><br><span class="line"></span><br><span class="line">192.168.10.107 hadoop107</span><br><span class="line"></span><br><span class="line">192.168.10.108 hadoop108</span><br></pre></td></tr></table></figure><p>（2）如果操作系统是 window10，先拷贝出来，修改保存以后，再覆盖即可</p><p>①进入 C:\Windows\System32\drivers\etc 路径</p><p>②拷贝 hosts 文件到桌面</p><p>③打开桌面 hosts 文件并添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.100 hadoop100</span><br><span class="line"></span><br><span class="line">192.168.10.101 hadoop101</span><br><span class="line"></span><br><span class="line">192.168.10.102 hadoop102</span><br><span class="line"></span><br><span class="line">192.168.10.103 hadoop103</span><br><span class="line"></span><br><span class="line">192.168.10.104 hadoop104</span><br><span class="line"></span><br><span class="line">192.168.10.105 hadoop105</span><br><span class="line"></span><br><span class="line">192.168.10.106 hadoop106</span><br><span class="line"></span><br><span class="line">192.168.10.107 hadoop107</span><br><span class="line"></span><br><span class="line">192.168.10.108 hadoop108</span><br></pre></td></tr></table></figure><p>④将桌面 hosts 文件覆盖 C:\Windows\System32\drivers\etc 路径 hosts 文件第 <strong>3</strong> 章远程终端工具安装</p><p>通常在工作过程中，公司中使用的真实服务器或者是云服务器，都不允许除运维人员之外的员工直接接触，因此就需要通过远程登录的方式来操作。所以，远程登录工具就是必不可缺的，目前，比较主流的有 Xshell，SSH Secure Shell，SecureCRT，FinalShell 等。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;VMware-安装&quot;&gt;&lt;a href=&quot;#VMware-安装&quot; class=&quot;headerlink&quot; title=&quot;VMware 安装&quot;&gt;&lt;/a&gt;VMware 安装&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;尚硅谷高级技术之 Linux（环境准备）&lt;/p&gt;
&lt;p&gt;（作者：尚硅谷研究院）&lt;/p&gt;
&lt;h1 id=&quot;第-1-章-VMware&quot;&gt;&lt;a href=&quot;#第-1-章-VMware&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 VMware&quot;&gt;&lt;/a&gt;第 1 章 VMware&lt;/h1&gt;&lt;h2 id=&quot;1-1-VMware-安装&quot;&gt;&lt;a href=&quot;#1-1-VMware-安装&quot; class=&quot;headerlink&quot; title=&quot;1.1 VMware 安装&quot;&gt;&lt;/a&gt;1.1 VMware 安装&lt;/h2&gt;&lt;p&gt;一台电脑本身是可以装多个操作系统的，但是做不到多个操作系统切换自如，所以我们需要一款软件帮助我们达到这个目的，不然数仓项目搭建不起来。&lt;/p&gt;
&lt;p&gt;推荐的软件为 VMware，VMware 可以使用户在一台计算机上同时运行多个操作系统，还可以像 Windows 应用程序一样来回切换。用户可以如同操作真实安装的系统一样操作虚拟机系统，甚至可以在一台计算机上将几个虚拟机系统连接为一个局域网或者连接到互联网。&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux+shell" scheme="https://yangmour.github.io/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Maven 核心程序解压和配置</title>
    <link href="https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/2.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Maven%20%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8E%8B%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/2.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Maven%20%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8E%8B%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2022-09-25T14:06:17.000Z</published>
    <updated>2022-09-26T04:07:46.219Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第一节-Maven核心程序解压与配置"><a href="#第一节-Maven核心程序解压与配置" class="headerlink" title="第一节 Maven核心程序解压与配置"></a>第一节 Maven核心程序解压与配置</h1><h2 id="1、Maven-官网地址"><a href="#1、Maven-官网地址" class="headerlink" title="1、Maven 官网地址"></a>1、Maven 官网地址</h2><p>首页：</p><p><a href="https://maven.apache.org/">Maven – Welcome to Apache Maven(opens new window)</a></p><p>下载页面：</p><p><a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven(opens new window)</a></p><span id="more"></span><p>下载链接：</p><p><img src="https://image.3001.net/images/20220926/16641596995220.png" alt="image-20220926103455907"></p><p>具体下载地址：<a href="https://dlcdn.apache.org/maven/maven-3/3.8.4/binaries/apache-maven-3.8.4-bin.zip">https://dlcdn.apache.org/maven/maven-3/3.8.4/binaries/apache-maven-3.8.4-bin.zip</a></p><h2 id="2、解压Maven核心程序"><a href="#2、解压Maven核心程序" class="headerlink" title="2、解压Maven核心程序"></a>2、解压Maven核心程序</h2><p>核心程序压缩包：apache-maven-3.8.4-bin.zip，解压到<strong>非中文、没有空格</strong>的目录。例如：</p><p><img src="https://image.3001.net/images/20220926/16641602591169.png" alt="1"></p><p>在解压目录中，我们需要着重关注 Maven 的核心配置文件：<strong>conf/settings.xml</strong></p><h2 id="3、指定本地仓库"><a href="#3、指定本地仓库" class="headerlink" title="3、指定本地仓库"></a>3、指定本地仓库</h2><p>本地仓库默认值：用户家目录/.m2/repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本地仓库这个目录，我们手动创建一个空的目录即可。</p><p><strong>记住</strong>：一定要把 localRepository 标签<strong>从注释中拿出来</strong>。</p><p><strong>注意</strong>：本地仓库本身也需要使用一个<strong>非中文、没有空格</strong>的目录。</p><h2 id="4、配置阿里云提供的镜像仓库"><a href="#4、配置阿里云提供的镜像仓库" class="headerlink" title="4、配置阿里云提供的镜像仓库"></a>4、配置阿里云提供的镜像仓库</h2><p>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，<strong>访问国内网站</strong>，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是：</p><h3 id="①将原有的例子配置注释掉"><a href="#①将原有的例子配置注释掉" class="headerlink" title="①将原有的例子配置注释掉"></a>①将原有的例子配置注释掉</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">  &lt;id&gt;maven-default-http-blocker&lt;/id&gt;</span></span><br><span class="line"><span class="comment">  &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">  &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">  &lt;url&gt;http://0.0.0.0/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">  &lt;blocked&gt;true&lt;/blocked&gt;</span></span><br><span class="line"><span class="comment">&lt;/mirror&gt; --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="②加入我们的配置"><a href="#②加入我们的配置" class="headerlink" title="②加入我们的配置"></a>②加入我们的配置</h3><p>将下面 mirror 标签整体复制到 settings.xml 文件的 mirrors 标签的内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5、配置-Maven-工程的基础-JDK-版本"><a href="#5、配置-Maven-工程的基础-JDK-版本" class="headerlink" title="5、配置 Maven 工程的基础 JDK 版本"></a>5、配置 Maven 工程的基础 JDK 版本</h2><p>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 profile 标签整个复制到 settings.xml 文件的 profiles 标签内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="第二节-配置环境变量"><a href="#第二节-配置环境变量" class="headerlink" title="第二节 配置环境变量"></a>第二节 配置环境变量</h1><h2 id="1、检查-JAVA-HOME-配置是否正确"><a href="#1、检查-JAVA-HOME-配置是否正确" class="headerlink" title="1、检查 JAVA_HOME 配置是否正确"></a>1、检查 JAVA_HOME 配置是否正确</h2><p>Maven 是一个用 Java 语言开发的程序，它必须基于 JDK 来运行，需要通过 JAVA_HOME 来找到 JDK 的安装位置。</p><p><img src="https://image.3001.net/images/20220926/16641602858655.png" alt="1"></p><p>可以使用下面的命令验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;echo %JAVA_HOME%</span><br><span class="line">D:\software\Java</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="2、配置-MAVEN-HOME"><a href="#2、配置-MAVEN-HOME" class="headerlink" title="2、配置 MAVEN_HOME"></a>2、配置 MAVEN_HOME</h2><p><img src="https://image.3001.net/images/20220926/16641603476134.png" alt="1"></p><p>TIP</p><p>配置环境变量的规律：</p><p>XXX_HOME 通常指向的是 bin 目录的上一级</p><p>PATH 指向的是 bin 目录</p><h2 id="3、配置PATH"><a href="#3、配置PATH" class="headerlink" title="3、配置PATH"></a>3、配置PATH</h2><p><img src="https://image.3001.net/images/20220926/16641603568869.png" alt="1"></p><h2 id="4、验证"><a href="#4、验证" class="headerlink" title="4、验证"></a>4、验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;mvn -v</span><br><span class="line">Apache Maven 3.8.4 (9b656c72d54e5bacbed989b64718c159fe39b537)</span><br><span class="line">Maven home: D:\software\apache-maven-3.8.4</span><br><span class="line">Java version: 1.8.0_141, vendor: Oracle Corporation, runtime: D:\software\Java\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: <span class="string">&quot;windows 10&quot;</span>, version: <span class="string">&quot;10.0&quot;</span>, arch: <span class="string">&quot;amd64&quot;</span>, family: <span class="string">&quot;windows&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;第一节-Maven核心程序解压与配置&quot;&gt;&lt;a href=&quot;#第一节-Maven核心程序解压与配置&quot; class=&quot;headerlink&quot; title=&quot;第一节 Maven核心程序解压与配置&quot;&gt;&lt;/a&gt;第一节 Maven核心程序解压与配置&lt;/h1&gt;&lt;h2 id=&quot;1、Maven-官网地址&quot;&gt;&lt;a href=&quot;#1、Maven-官网地址&quot; class=&quot;headerlink&quot; title=&quot;1、Maven 官网地址&quot;&gt;&lt;/a&gt;1、Maven 官网地址&lt;/h2&gt;&lt;p&gt;首页：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://maven.apache.org/&quot;&gt;Maven – Welcome to Apache Maven(opens new window)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载页面：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://maven.apache.org/download.cgi&quot;&gt;Maven – Download Apache Maven(opens new window)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="maven" scheme="https://yangmour.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>5.第五章 其他核心概念</title>
    <link href="https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/5.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%85%B6%E4%BB%96%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/5.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%85%B6%E4%BB%96%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</id>
    <published>2022-09-25T14:06:17.000Z</published>
    <updated>2022-09-26T04:07:06.270Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第五章-其他核心概念"><a href="#第五章-其他核心概念" class="headerlink" title="第五章 其他核心概念"></a>第五章 其他核心概念</h1><h2 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h2><h3 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h3><p>为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p><span id="more"></span><h3 id="②三个生命周期"><a href="#②三个生命周期" class="headerlink" title="②三个生命周期"></a>②三个生命周期</h3><table><thead><tr><th>生命周期名称</th><th>作用</th><th>各个环节</th></tr></thead><tbody><tr><td>Clean</td><td>清理操作相关</td><td>pre-clean clean post-clean</td></tr><tr><td>Site</td><td>生成站点相关</td><td>pre-site site post-site deploy-site</td></tr><tr><td>Default</td><td>主要构建过程</td><td>validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目 main 目录下的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如JAR。 pre-integration-test integration-test post-integration-test verify install将包安装至本地仓库，以让其它项目依赖。 deploy将最终的包复制到远程的仓库，以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。</td></tr></tbody></table><h3 id="③特点"><a href="#③特点" class="headerlink" title="③特点"></a>③特点</h3><ul><li>前面三个生命周期彼此是独立的。</li><li>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记）</li></ul><p>Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。</p><h2 id="2、插件和目标"><a href="#2、插件和目标" class="headerlink" title="2、插件和目标"></a>2、插件和目标</h2><h3 id="①插件"><a href="#①插件" class="headerlink" title="①插件"></a>①插件</h3><p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p><h3 id="②目标"><a href="#②目标" class="headerlink" title="②目标"></a>②目标</h3><p>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p><p>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p><h2 id="3、仓库"><a href="#3、仓库" class="headerlink" title="3、仓库"></a>3、仓库</h2><ul><li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li><li>远程仓库：需要联网<ul><li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li><li>Internet<ul><li>中央仓库</li><li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li></ul></li></ul></li></ul><p>建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。</p><p>专门搜索 Maven 依赖信息的网站：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;第五章-其他核心概念&quot;&gt;&lt;a href=&quot;#第五章-其他核心概念&quot; class=&quot;headerlink&quot; title=&quot;第五章 其他核心概念&quot;&gt;&lt;/a&gt;第五章 其他核心概念&lt;/h1&gt;&lt;h2 id=&quot;1、生命周期&quot;&gt;&lt;a href=&quot;#1、生命周期&quot; class=&quot;headerlink&quot; title=&quot;1、生命周期&quot;&gt;&lt;/a&gt;1、生命周期&lt;/h2&gt;&lt;h3 id=&quot;①作用&quot;&gt;&lt;a href=&quot;#①作用&quot; class=&quot;headerlink&quot; title=&quot;①作用&quot;&gt;&lt;/a&gt;①作用&lt;/h3&gt;&lt;p&gt;为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="maven" scheme="https://yangmour.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>第四章 使用Maven：IDEA环境</title>
    <link href="https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/4.%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%BD%BF%E7%94%A8Maven%EF%BC%9AIDEA%E7%8E%AF%E5%A2%83/"/>
    <id>https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/4.%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%BD%BF%E7%94%A8Maven%EF%BC%9AIDEA%E7%8E%AF%E5%A2%83/</id>
    <published>2022-09-25T14:06:17.000Z</published>
    <updated>2022-09-26T04:04:42.842Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>:::TIP</p><p>各个 IDEA 不同版本在具体操作方面存在一定差异，这里我们以 2019.3.3 版本为例进行演示。其它版本大家灵活变通即可。</p><p><img src="https://image.3001.net/images/20220926/16641638856825.png" alt="1"></p><p>:::</p><span id="more"></span><h1 id="第一节-创建父工程"><a href="#第一节-创建父工程" class="headerlink" title="第一节 创建父工程"></a>第一节 创建父工程</h1><h2 id="1、创建-Project"><a href="#1、创建-Project" class="headerlink" title="1、创建 Project"></a>1、创建 Project</h2><p><img src="https://image.3001.net/images/20220926/16641638578184.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/16641638441130.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/16641638485854.png" alt="1"></p><h2 id="2、开启自动导入"><a href="#2、开启自动导入" class="headerlink" title="2、开启自动导入"></a>2、开启自动导入</h2><p>创建 Project 后，IDEA 会自动弹出下面提示，我们选择<strong>『Enable Auto-Import』</strong>，意思是启用自动导入。</p><p><img src="https://image.3001.net/images/20220926/16641638014435.png" alt="1"></p><p>这个自动导入<strong>一定要开启</strong>，因为 Project、Module 新创建或 pom.xml 每次修改时都应该让 IDEA 重新加载 Maven 信息。这对 Maven 目录结构认定、Java 源程序编译、依赖 jar 包的导入都有非常关键的影响。</p><p>另外也可以通过 IDEA 的 Settings 设置来开启：</p><p><img src="https://image.3001.net/images/20220926/16641637927641.png" alt="1"></p><h1 id="第二节-配置Maven信息"><a href="#第二节-配置Maven信息" class="headerlink" title="第二节 配置Maven信息"></a>第二节 配置Maven信息</h1><p>每次创建 Project 后都需要设置 Maven 家目录位置，否则 IDEA 将使用内置的 Maven 核心程序（不稳定）并使用默认的本地仓库位置。这样一来，我们在命令行操作过程中已下载好的 jar 包就白下载了，默认的本地仓库通常在 C 盘，还影响系统运行。</p><p>配置之后，IDEA 会根据我们在这里指定的 Maven 家目录自动识别到我们在 settings.xml 配置文件中指定的本地仓库。</p><h1 id="第三节-创建Java模块工程"><a href="#第三节-创建Java模块工程" class="headerlink" title="第三节 创建Java模块工程"></a>第三节 创建Java模块工程</h1><p><img src="https://image.3001.net/images/20220926/16641640657571.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/16641640784957.png" alt="1"></p><h1 id="第四节-创建Web模块工程"><a href="#第四节-创建Web模块工程" class="headerlink" title="第四节 创建Web模块工程"></a>第四节 创建Web模块工程</h1><h2 id="1、创建模块"><a href="#1、创建模块" class="headerlink" title="1、创建模块"></a>1、创建模块</h2><p>按照前面的同样操作创建模块，<strong>此时</strong>这个模块其实还是一个<strong>Java模块</strong>。</p><h2 id="2、修改打包方式"><a href="#2、修改打包方式" class="headerlink" title="2、修改打包方式"></a>2、修改打包方式</h2><p>Web 模块将来打包当然应该是 <strong>war</strong> 包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、Web-设定"><a href="#3、Web-设定" class="headerlink" title="3、Web 设定"></a>3、Web 设定</h2><p>首先打开项目结构菜单：</p><p><img src="https://image.3001.net/images/20220926/16641641252561.png" alt="1"></p><p>然后到 Facets 下查看 IDEA 是否已经帮我们自动生成了 Web 设定。正常来说只要我们确实设置了打包方式为 war，那么 IDEA 2019 版就会自动生成 Web 设定。</p><p><img src="https://image.3001.net/images/20220926/16641641377651.png" alt="1"></p><p>另外，对于 IDEA 2018 诸版本没有自动生成 Web 设定，那么请参照下面两图，我们自己创建：</p><p><img src="https://image.3001.net/images/20220926/16641641498826.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/16641641622088.png" alt="1"></p><h2 id="4、借助IDEA生成web-xml"><a href="#4、借助IDEA生成web-xml" class="headerlink" title="4、借助IDEA生成web.xml"></a>4、借助IDEA生成web.xml</h2><p><img src="https://image.3001.net/images/20220926/16641641795580.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/1664164188529.png" alt="1"></p><h2 id="5、设置-Web-资源的根目录"><a href="#5、设置-Web-资源的根目录" class="headerlink" title="5、设置 Web 资源的根目录"></a>5、设置 Web 资源的根目录</h2><p>结合 Maven 的目录结构，Web 资源的根目录需要设置为 src/main/webapp 目录。</p><p><img src="https://image.3001.net/images/20220926/16641642059197.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/1664164218691.png" alt="1"></p><h1 id="第五节-其他操作"><a href="#第五节-其他操作" class="headerlink" title="第五节 其他操作"></a>第五节 其他操作</h1><h2 id="1、在IDEA中执行Maven命令"><a href="#1、在IDEA中执行Maven命令" class="headerlink" title="1、在IDEA中执行Maven命令"></a>1、在IDEA中执行Maven命令</h2><h3 id="①直接执行"><a href="#①直接执行" class="headerlink" title="①直接执行"></a>①直接执行</h3><p><img src="https://image.3001.net/images/20220926/16641643376866.png" alt="1"></p><h3 id="②手动输入"><a href="#②手动输入" class="headerlink" title="②手动输入"></a>②手动输入</h3><p><img src="https://image.3001.net/images/20220926/16641643657196.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/16641643772932.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/16641643926988.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/16641644639040.png" alt="1"></p><p>如果有需要，还可以给命令后面附加参数：</p><p><img src="https://image.3001.net/images/20220926/16641644901937.png" alt="1"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -D 表示后面要附加命令的参数，字母 D 和后面的参数是紧挨着的，中间没有任何其它字符</span></span><br><span class="line"><span class="comment"># maven.test.skip=true 表示在执行命令的过程中跳过测试</span></span><br><span class="line">mvn clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="2、在IDEA中查看某个模块的依赖信息"><a href="#2、在IDEA中查看某个模块的依赖信息" class="headerlink" title="2、在IDEA中查看某个模块的依赖信息"></a>2、在IDEA中查看某个模块的依赖信息</h2><p><img src="https://image.3001.net/images/20220926/16641645066297.png" alt="1"></p><h2 id="3、工程导入"><a href="#3、工程导入" class="headerlink" title="3、工程导入"></a>3、工程导入</h2><p>Maven工程除了自己创建的，还有很多情况是别人创建的。而为了参与开发或者是参考学习，我们都需要导入到 IDEA 中。下面我们分几种不同情况来说明：</p><h3 id="①来自版本控制系统"><a href="#①来自版本控制系统" class="headerlink" title="①来自版本控制系统"></a>①来自版本控制系统</h3><p>目前我们通常使用的都是 Git（本地库） + 码云（远程库）的版本控制系统，结合 IDEA 的相关操作方式请点<a href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro008-Git/lecture/chapter05/verse03.html"><strong>这里</strong> (opens new window)</a>查看<strong>克隆远程库</strong>部分。</p><h3 id="②来自工程目录"><a href="#②来自工程目录" class="headerlink" title="②来自工程目录"></a>②来自工程目录</h3><p>直接使用 IDEA 打开工程目录即可。下面咱们举个例子：</p><h4 id="1-工程压缩包"><a href="#1-工程压缩包" class="headerlink" title="[1]工程压缩包"></a>[1]工程压缩包</h4><p>假设别人发给我们一个 Maven 工程的 zip 压缩包：maven-rest-demo.zip。从码云或GitHub上也可以以 ZIP 压缩格式对项目代码打包下载。</p><h4 id="2-解压"><a href="#2-解压" class="headerlink" title="[2]解压"></a>[2]解压</h4><p>如果你的所有 IDEA 工程有一个专门的目录来存放，而不是散落各处，那么首先我们就把 ZIP 包解压到这个指定目录中。</p><p><img src="https://image.3001.net/images/20220926/16641645525402.png" alt="1"></p><h4 id="3-打开"><a href="#3-打开" class="headerlink" title="[3]打开"></a>[3]打开</h4><p>只要我们确认在解压目录下可以直接看到 pom.xml，那就能证明这个解压目录就是我们的工程目录。那么接下来让 IDEA 打开这个目录就可以了。</p><p><img src="https://image.3001.net/images/20220926/16641645664230.png" alt="./images"></p><p><img src="https://image.3001.net/images/20220926/16641645789960.png" alt="1"></p><h4 id="4-设置-Maven-核心程序位置"><a href="#4-设置-Maven-核心程序位置" class="headerlink" title="[4]设置 Maven 核心程序位置"></a>[4]设置 Maven 核心程序位置</h4><p>打开一个新的 Maven 工程，和新创建一个 Maven 工程是一样的，此时 IDEA 的 settings 配置中关于 Maven 仍然是默认值：</p><p><img src="https://image.3001.net/images/20220926/16641645923956.png" alt="1"></p><p>所以我们还是需要像新建 Maven 工程那样，指定一下 Maven 核心程序位置：</p><p><img src="https://image.3001.net/images/20220926/1664164605368.png" alt="1"></p><h2 id="4、模块导入"><a href="#4、模块导入" class="headerlink" title="4、模块导入"></a>4、模块导入</h2><h3 id="①情景重现"><a href="#①情景重现" class="headerlink" title="①情景重现"></a>①情景重现</h3><p>在实际开发中，通常会忽略模块（也就是module）所在的项目（也就是project）仅仅导入某一个模块本身。这么做很可能是类似这样的情况：比如基于 Maven 学习 SSM 的时候，做练习需要导入老师发给我们的代码参考。</p><p><img src="https://image.3001.net/images/20220926/1664164626678.png" alt="1"></p><h3 id="②导入-Java-类型模块"><a href="#②导入-Java-类型模块" class="headerlink" title="②导入 Java 类型模块"></a>②导入 Java 类型模块</h3><h4 id="1-找到老师发的工程目录"><a href="#1-找到老师发的工程目录" class="headerlink" title="[1]找到老师发的工程目录"></a>[1]找到老师发的工程目录</h4><p><img src="https://image.3001.net/images/20220926/16641646467547.png" alt="1"></p><h4 id="2-复制我们想要导入的模块目录"><a href="#2-复制我们想要导入的模块目录" class="headerlink" title="[2]复制我们想要导入的模块目录"></a>[2]复制我们想要导入的模块目录</h4><p><img src="https://image.3001.net/images/20220926/16641646788885.png" alt="1"></p><h4 id="3-粘贴到我们自己工程目录下"><a href="#3-粘贴到我们自己工程目录下" class="headerlink" title="[3]粘贴到我们自己工程目录下"></a>[3]粘贴到我们自己工程目录下</h4><p>这个工程（project）是我们事先在 IDEA 中创建好的。</p><p><img src="https://image.3001.net/images/20220926/16641646864656.png" alt="1"></p><hr><p><img src="https://image.3001.net/images/20220926/16641647057449.png" alt="1"></p><h4 id="4-在-IDEA-中执行导入"><a href="#4-在-IDEA-中执行导入" class="headerlink" title="[4]在 IDEA 中执行导入"></a>[4]在 IDEA 中执行导入</h4><p><img src="https://image.3001.net/images/20220926/16641647212063.png" alt="1"></p><hr><p><img src="https://image.3001.net/images/20220926/1664164733942.png" alt="1"></p><hr><p><img src="https://image.3001.net/images/20220926/16641647479459.png" alt="1"></p><hr><p><img src="https://image.3001.net/images/20220926/16641647649901.png" alt="1"></p><hr><p><img src="https://image.3001.net/images/20220926/16641647758980.png" alt="1"></p><h4 id="5-修改-pom-xml"><a href="#5-修改-pom-xml" class="headerlink" title="[5]修改 pom.xml"></a>[5]修改 pom.xml</h4><p>刚刚导入的 module 的父工程坐标还是以前的，需要改成我们自己的 project。</p><p><img src="https://image.3001.net/images/20220926/16641647971886.png" alt="1"></p><hr><p><img src="https://image.3001.net/images/20220926/16641648322436.png" alt="1"></p><h4 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="[6]最终效果"></a>[6]最终效果</h4><p><img src="https://image.3001.net/images/20220926/16641648474295.png" alt="1"></p><h3 id="③导入-Web-类型模块"><a href="#③导入-Web-类型模块" class="headerlink" title="③导入 Web 类型模块"></a>③导入 Web 类型模块</h3><p>其它操作和上面演示的都一样，只是多一步：删除多余的、不正确的 web.xml 设置。如下图所示：</p><p><img src="https://image.3001.net/images/20220926/16641648618332.png" alt="1"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;:::TIP&lt;/p&gt;
&lt;p&gt;各个 IDEA 不同版本在具体操作方面存在一定差异，这里我们以 2019.3.3 版本为例进行演示。其它版本大家灵活变通即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20220926/16641638856825.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;</summary>
    
    
    
    
    <category term="maven" scheme="https://yangmour.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>1.第一章Maven概述</title>
    <link href="https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/1.%E7%AC%AC%E4%B8%80%E7%AB%A0%20Maven%E6%A6%82%E8%BF%B0/"/>
    <id>https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/1.%E7%AC%AC%E4%B8%80%E7%AB%A0%20Maven%E6%A6%82%E8%BF%B0/</id>
    <published>2022-09-25T14:06:17.000Z</published>
    <updated>2022-09-26T04:07:38.144Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第一节-为什么要学习Maven？"><a href="#第一节-为什么要学习Maven？" class="headerlink" title="第一节 为什么要学习Maven？"></a>第一节 为什么要学习Maven？</h1><h2 id="1、Maven-作为依赖管理工具"><a href="#1、Maven-作为依赖管理工具" class="headerlink" title="1、Maven 作为依赖管理工具"></a>1、Maven 作为依赖管理工具</h2><h3 id="①jar-包的规模"><a href="#①jar-包的规模" class="headerlink" title="①jar 包的规模"></a>①jar 包的规模</h3><p>随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。</p><span id="more"></span><p>比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：</p><ul><li>Nacos 服务注册发现</li><li>Web 框架环境</li><li>图模板技术 Thymeleaf</li></ul><p>最终却导入了 106 个 jar 包：</p><blockquote><p>org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compile<br>com.netflix.ribbon: ribbon:jar:2.3.0:compile<br>org.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compile<br>commons-configuration:commons-configuration:jar:1.8:compile<br>org.apache.logging.log4j:log4j-api:jar:2.13.3:compile<br>org.springframework:spring-beans:jar:5.2.11.RELEASE:compile<br>org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compile<br>org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compile<br>com.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compile<br>org.bouncycastle:bcprov-jdk15on:jar:1.64:compile<br>org.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compile<br>org.apache.httpcomponents:httpasyncclient:jar:4.1.4:compile<br>com.google.j2objc:j2objc-annotations:jar:1.3:compile<br>com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile<br>io.reactivex:rxjava:jar:1.3.8:compile<br>ch.qos.logback:logback-classic:jar:1.2.3:compile<br>org.springframework:spring-web:jar:5.2.11.RELEASE:compile<br>io.reactivex:rxnetty-servo:jar:0.4.9:runtime<br>org.springframework:spring-core:jar:5.2.11.RELEASE:compile<br>io.github.openfeign.form:feign-form-spring:jar:3.8.0:compile<br>io.github.openfeign.form:feign-form:jar:3.8.0:compile<br>com.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compile<br>org.apache.httpcomponents:httpcore:jar:4.4.13:compile<br>org.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compile<br>org.slf4j:jul-to-slf4j:jar:1.7.30:compile<br>com.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compile<br>org.yaml:snakeyaml:jar:1.26:compile<br>org.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compile<br>io.reactivex:rxnetty-contexts:jar:0.4.9:runtime<br>org.apache.httpcomponents:httpclient:jar:4.5.13:compile<br>io.github.openfeign:feign-core:jar:10.10.1:compile<br>org.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compile<br>org.hdrhistogram:HdrHistogram:jar:2.1.9:compile<br>org.springframework:spring-context:jar:5.2.11.RELEASE:compile<br>commons-lang:commons-lang:jar:2.6:compile<br>io.prometheus:simpleclient:jar:0.5.0:compile<br>ch.qos.logback:logback-core:jar:1.2.3:compile<br>org.springframework:spring-webmvc:jar:5.2.11.RELEASE:compile<br>com.sun.jersey:jersey-core:jar:1.19.1:runtime<br>javax.ws.rs:jsr311-api:jar:1.1.1:runtime<br>javax.inject:javax.inject:jar:1:runtime<br>org.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compile<br>com.netflix.ribbon:ribbon-core:jar:2.3.0:compile<br>com.netflix.hystrix:hystrix-core:jar:1.5.18:compile<br>com.netflix.ribbon:ribbon-transport:jar:2.3.0:runtime<br>org.springframework.boot:spring-boot-starter-json:jar:2.3.6.RELEASE:compile<br>org.springframework.cloud:spring-cloud-starter-openfeign:jar:2.2.6.RELEASE:compile<br>com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compile<br>com.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtime<br>io.github.openfeign:feign-hystrix:jar:10.10.1:compile<br>io.github.openfeign:feign-slf4j:jar:10.10.1:compile<br>com.alibaba.nacos:nacos-client:jar:1.4.2:compile<br>org.apache.httpcomponents:httpcore-nio:jar:4.4.13:compile<br>com.sun.jersey:jersey-client:jar:1.19.1:runtime<br>org.springframework.cloud:spring-cloud-context:jar:2.2.6.RELEASE:compile<br>org.glassfish:jakarta.el:jar:3.0.3:compile<br>org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile<br>com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compile<br>org.springframework.cloud:spring-cloud-commons:jar:2.2.6.RELEASE:compile<br>org.aspectj:aspectjweaver:jar:1.9.6:compile<br>com.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery:jar:2.2.6.RELEASE:compile<br>com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile<br>com.alibaba.spring:spring-context-support:jar:1.0.10:compile<br>jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile<br>org.bouncycastle:bcpkix-jdk15on:jar:1.64:compile<br>com.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:runtime<br>com.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compile<br>com.google.guava:guava:jar:29.0-jre:compile<br>com.google.guava:failureaccess:jar:1.0.1:compile<br>org.springframework.boot:spring-boot:jar:2.3.6.RELEASE:compile<br>com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compile<br>com.atguigu.demo:demo08-base-api:jar:1.0-SNAPSHOT:compile<br>org.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.6.RELEASE:compile<br>org.springframework.boot:spring-boot-autoconfigure:jar:2.3.6.RELEASE:compile<br>org.slf4j:slf4j-api:jar:1.7.30:compile<br>commons-io:commons-io:jar:2.7:compile<br>org.springframework.cloud:spring-cloud-starter:jar:2.2.6.RELEASE:compile<br>org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.39:compile<br>io.reactivex:rxnetty:jar:0.4.9:runtime<br>com.fasterxml.jackson.core:jackson-core:jar:2.11.3:compile<br>com.google.code.findbugs:jsr305:jar:3.0.2:compile<br>com.netflix.archaius:archaius-core:jar:0.7.6:compile<br>org.springframework.boot:spring-boot-starter-web:jar:2.3.6.RELEASE:compile<br>commons-codec:commons-codec:jar:1.14:compile<br>com.netflix.servo:servo-core:jar:0.12.21:runtime<br>com.google.errorprone:error_prone_annotations:jar:2.3.4:compile<br>org.attoparser:attoparser:jar:2.0.5.RELEASE:compile<br>com.atguigu.demo:demo10-base-util:jar:1.0-SNAPSHOT:compile<br>org.checkerframework:checker-qual:jar:2.11.1:compile<br>org.thymeleaf:thymeleaf-spring5:jar:3.0.11.RELEASE:compile<br>commons-fileupload:commons-fileupload:jar:1.4:compile<br>com.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compile<br>com.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtime<br>org.unbescape:unbescape:jar:1.1.6.RELEASE:compile<br>org.springframework:spring-jcl:jar:5.2.11.RELEASE:compile<br>com.alibaba.nacos:nacos-common:jar:1.4.2:compile<br>commons-collections:commons-collections:jar:3.2.2:runtime<br>javax.persistence:persistence-api:jar:1.0:compile<br>com.alibaba.nacos:nacos-api:jar:1.4.2:compile<br>org.thymeleaf:thymeleaf:jar:3.0.11.RELEASE:compile<br>org.springframework:spring-aop:jar:5.2.11.RELEASE:compile<br>org.springframework.boot:spring-boot-starter:jar:2.3.6.RELEASE:compile<br>org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.6.RELEASE:compile<br>org.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.6.RELEASE:compile<br>org.springframework:spring-expression:jar:5.2.11.RELEASE:compile<br>org.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.6.RELEASE:compile</p></blockquote><p>而如果使用 Maven 来引入这些 jar 包只需要配置三个『依赖』：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Nacos 服务注册发现启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- web启动器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图模板技术 thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="②jar-包的来源"><a href="#②jar-包的来源" class="headerlink" title="②jar 包的来源"></a>②jar 包的来源</h3><ul><li>这个jar包所属技术的官网。官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。</li><li>第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。<ul><li>jar包的名称</li><li>jar包的版本</li><li>jar包内的具体细节</li></ul></li><li>而使用 Maven 后，依赖对应的 jar 包能够自动下载，方便、快捷又规范。</li></ul><h3 id="③jar-包之间的依赖关系"><a href="#③jar-包之间的依赖关系" class="headerlink" title="③jar 包之间的依赖关系"></a>③jar 包之间的依赖关系</h3><p>框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。</p><p>下面是前面例子中 jar 包之间的依赖关系：</p><p><img src="https://image.3001.net/images/20220922/16638107713322.png" alt="image-20220922093930365"></p><p>而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。</p><p>而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。</p><h2 id="2、Maven-作为构建管理工具"><a href="#2、Maven-作为构建管理工具" class="headerlink" title="2、Maven 作为构建管理工具"></a>2、Maven 作为构建管理工具</h2><h3 id="①你没有注意过的构建"><a href="#①你没有注意过的构建" class="headerlink" title="①你没有注意过的构建"></a>①你没有注意过的构建</h3><p>你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。</p><h3 id="②脱离-IDE-环境仍需构建"><a href="#②脱离-IDE-环境仍需构建" class="headerlink" title="②脱离 IDE 环境仍需构建"></a>②脱离 IDE 环境仍需构建</h3><p><img src="https://image.3001.net/images/20220922/16638108421893.png" alt="image-20220922094041916"></p><h2 id="3、结论"><a href="#3、结论" class="headerlink" title="3、结论"></a>3、结论</h2><ul><li>管理规模庞大的 jar 包，需要专门工具。</li><li>脱离 IDE 环境执行构建操作，需要专门工具。</li></ul><h1 id="第二节-什么是-Maven？"><a href="#第二节-什么是-Maven？" class="headerlink" title="第二节 什么是 Maven？"></a>第二节 什么是 Maven？</h1><p>Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供构建和依赖管理支持的工具。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVQAAABWCAYAAACQLW4KAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAACAASURBVHic7Z15mBxVuf8/3+pJCAk7CIIsCYGw7/sOoqLyE/G6o6AgXhdcogICGpAdFImIAoKoeBEFAfWqCCgosm8xQFhCgIkg4RKyTsIkM9193t8fp3qmZ9IzXXWqujPw1Od5Oj2ZrnNOdU/XW+95V5kZBQUFBQXZiVb2CRQUFBS8Weho5eSSVgVWyTCFAV02wtRoSasAq2acxsxscR7nU1BQMDJQK2SVpPcB5wHbkl0L7gHuBY43s86s55YFSZOAqcChZLtR1JgNnGRmN+YwV0FBwUomd4Eq6cPADblO6rnWzI5uwbyJkLQ9cAewfs5TzzKzSTnPWVBQsBJohQ31uBbMCfARSaNaNHcSriJ/YQpQbcGcBQUFK4FcBWpsWzwozznrGA1s3aK5h0XSh4C9WzT9sy2at6CgoM3kraHuSXZnzXBs0cK5GyKpAzinhUs83sK5CwoK2kjeAnWfnOcbzCYtnr8RxwJbtXD+QqAWFLxJyFugbpnzfINpq0CVNAb4TouX+VeL5y8oKGgTeQvUHXKebzCbtXj+wXwR2KiF8y8Cnm/h/AUFBW0kN4Ea2xp3ymu+IWjl1nsAklYDTmnxMtNGWtJCQUFBOHlqqNsBY3KcrxFbSlKL16jxFeAtLV7j0RbPX1BQ0EbyFKi75zjXUKxKG+yoktYCTmr1OhQCtaDgTUWeAnW3HOcajnbEop4MrNWGdQqBWlDwJuKNKFC3aeXkkjbAb/dbTeGQKih4k5GLQI1TQlvtkKrRag31W8C4Fq8BhUOqoOBNR14a6nbkU30pCS0TqJI2Az7XqvkHUWz3CwreZORVD7UdDqkardzyn4GvGdAOCoEKLP3xlh+xKsdSlTPH/a5U/tFakzsXrezzKigIIZfyfZIuBz6f/XQSs7aZ5XrRSdoamAGU8px3GLY0s+fatNaIZPlPtzzYqnaHVYmsKlwVrMqrmN6/xonPPriyz6+gIC15bfnbqaFCa4qknE37hGnhkAIwd6AiIpVAJSPqgKiDDRTZbQsvnNjqrLsgen86aZvlV038afdlE3/bdemkw1f2+RSMLDJv+WOHVLu//OOBR/KaTNKuwAfzmi8BbXdISRqLzzSbFD+vg7d7r4lvNePiRw8wP37MA/4NPG1m/5f/WUWTwFAEEuaqJhDAmh2UruZM7c0Z5vJfN4BfTBizvLc0BXES+Lq8kdmHlkyddNzqX3v2561cWtJb8IWH9gLeig/pWwP/t+qKH0uAV4C7gX+ZWaWV59ROJK0O7Ir/7k4ExgLr0v+9XYr/nnYCj5jZCynmvhL4bIOXuoHVgCfxZsb5wIZmVo7H7QfcHp/LRWZ2EuRjQ92e9jmkaozPeb5zia/kNtFy+2l8Eb4POALYBZ8QEfweJS3EV8b6I/CHPMwVZjapL+9NLIs6GGsyTMLJ9ugau8Xxa8CVWdfJSveV4zcUHf8r1e3EBBIYNrX7B9veOnbyU6/ktZ6k9YC31z3SFh1aKule4Gbgf8xsWV7nNhTx920H/I16sFwxvICaDzxnZnMTzLca8EngePz3N/FuWtIc4LfAjxJ8Tx/E34yOwt+sZgB/w9cp3pB+n826+JZOj0mKgEvxwhSgb43MNlRJn6X9X/rLzOyEPCaSdADwzzzmSsHHzOz6vCeVtBHwMeADwL60tqvtNOB84KZQbXv5lVssMlgzFqrzgPUAzEHvEj3cMz9aZ/0xG23NGX9fadpW9xVb7qLI/gi8rT7p2SrgKsJVoFrlG2udOOvirGtJ2hv4Kn63lFd3ivnAT4AfmtmrOc05AEkX4887yfetF9jfzB4eYq6N8TU0jsZr4Vkw4Grgm2a2YLgDJd0OvBM4zMxuj3/3PuB/6w47ysx+3UDm7WFmj0A+F1y7AvrrGZ/jXOflOFdScjNXgL8QJf0ZeAn4PrA/rW8RviteC5ghaf+0g5descX65s0NxOL49dprvUt0f8/8aGdg4tzlcw7O5WwDWHr5lh9QZPcAbxv0Ug+C2iOCA7OsI+kgSfcA9+NviHm2+lkXOA14RtKncpwXAEnvBL5G8u/baPx7HDzPapLOxmuGJ5BdmIL/Cx0PPBmb9YZj5/h5Wt3varLt9/HzDpLWxO9ob8N/Z8vAE7UBeVx07XZIQU4CVdJ78MKnnSwCEtt4hkPSjrEgvR94L60Xoo3YFrhD0vFpBnVEAxsTOqPbDJYv1N0986O9iIWKoffld6rJee2UrU7ofU2T6d/W1XgFGF0znsRPQUWBJG0l6VbgH8B+YWeamLWAX0j6U2xSyItjA8asWf+fWBOcBXyb1nT8eCtwl6Q9G70oaRN8IaTZZjav7qWaQL0Ab7I4AK+wrIZPTx8HPGlmPbUBmS5ASaNpv0MKchCocdWqc7OfSmoezeqQkhRJOhVvi31vPqeVidHAVZK+lHTA0tmjNu2eU7rLlfUigKB7+fzSXb0Lo4HatWzf3M+2CXNPnXSSiR9VlmlrjJpTzDCexF+cAm9DRWAilY1S0ihJ3wIeAw7L89wTcDjwT0mDte5QQhSqXvDOJknnAX/Af66tZDXgRknrNnitJjgHmyF2w5/rdLxzan/gM8APiM1TDNRoM2s0O9C+QPh6xkraMOMcH8Ebu9tNJoeUpHH4Lch55JeYkRffl7RHkgOr2LhqDwe9/p9oo9dfju7tflWPlrs4CEPmwKpgFWG92mn2mRNaXRayj//72tZTrBJ9F3/LW7/yuh73p8s95rVxr5QKiA8SSvw3jbWhe/B9ytrtzK2xDX5XsXaWSeKqbCEhjEdJuhl4FTiV9jmEN6FxB46aQO0zxcXyZUNgeqyBPhW/NBevsdZMCAP+9lkFapbtvhHfqQLZPHRgXAz7rIChhr8QloeuTQb7qaS34reHK2UbnIDReCdAU8wxOhaaHZXXo/0qi0ujXFm4srD4Of551Kj5q+7cfMbszPnytie7qs5yscPJqtCzOOoCuwWxP3UXvmr/CEqq3p9kfkmH4jWahlvPNrMVcHPcqTiUPQkThmviHaetbOg5FJ+NCyDVUxOO9ddmrTbJA/Fzrffbt82si35lbEACSlYNJ4tD6nR8HFdoRsxE4N7AsZ/Gx7Sl5dtmdp6kgwm3vQZpqLEx/C7Czrud7CBpZzObPtxB6lWHM8AEBhbRjYsdVPHD4tdkjKf/i90S/vPf232ZiAtVUt/6RFTdMu5ZMrvjOMHLBmVhFUMViYpBVdD1ltHlpt9DSZ8Afk6+DqesHIy3CSY21Qxir/xOpW2sgvfmX1v3u88C65jZjLrf3YkXqrUEnMuAW82spqmeDJxlZjPrJ88qUEM11NeB7+I9ZH3hMikJ0lDjO/LpAUMfwIcJAYSG8SxIE3RcI7b3/g/5CNPl+K3WAvzfYQzeuL45+W1Bj8LbnYakWparF5pY7Dm3QULVCWDjnM6rIbOP2f7TUYlLvDA1iPqeL3CyrwmNJTJvL40VspoV3IyrOGP2sDsWSV8FptLeWOekfEbSGWY2P2DsSNC0QziIOoFqZnOAOfUHmFkvdR2JzWw5/dt+zOzlRhMHC9RYMG0fOPzO+ISR9A/gQwFzTAxc+4ukr/pvwJfrnEmhrVFC7acnk22bPxf4MT7UY1ot26Oe2AyyHd5r+zmytbNpWsqxWlZVdZqoYPlA7bT2s8BWCFvKjc6Pb3+EIn5qSJj59SLDTFOjDjuWisZihkVCJZ/VVUfZRun8IaYGQNIX8E6MrFTw0SGL8MHzm5DPDXAM/u8dEj74RhWoLfOdZNFQdyR8+3Jj3c/30CaBGmdfnBqw1jW1wN04S2JCwBwQIFAlbQOcGbheGa9VX2hm3cMdGKcqPgZMlvQb4C+Edy1o5EkduF6vqvVC00GH6Bek9cIVY/3A8xiWWR/c8cCSdD0lSvEW368ru74k9rOqNjIzZPKCND5GJa+tYly6wdnPdA41f7zN/3GGU3wZ+AXwV/yNcEnd3MI7TfYFTiTb9vurkqamyaiKS1224u/yKHAfPvtoHv5T3xp/kz6MfPrWhV6/TckiULM4pB6q+znUDhrSAfXrpNculzBQCO/KirGJSQlxSF1EmCayEPiAmd2VdqCZPSDpJOCqgHWB5mFErlfL6wWocxoTec2wsZaaM88esePWEfqDRYwxA5mhSMiYFnVES1zF9pRRJ0hj7bXkz1Elm40bM6TpSNJewM8I2+bPwQvJG8ys2uiAeLc0B6+c3Cjp7cANJLiZNWB9fAD8pSnG5JnQMx9vy73WzF4a6qA41OtbeI06i0N9HUljmykZIWQ5qdAPtIeBge1PUIs/Scc6khLfIeP4s28ErHPBoMIgWQKwU2mocQhSSJypAz4aIkzruAZ/MwlhXrMDrBJ1uzpvPmXWd2UtGuTh9z9XeOnJvXcdH3guK/D8YTutT090i6uwlqsKq8QhWhXmmrNrXYXj4//Xft+XZuoqwirClaPPbfC9x15vNH+c134jYSGFPwO2NrNfDyVMG2FmdwLvwAunENLuEvMSqD8BJpjZ+cMJU/B2SzP7IjAlh3Vb4hzMIlBDNdRpNfspQBzj1dDAm4A0xaZPIX0624vA4BztZilsQzHfzGanHPPNwLWmmtlfA8cCENtZ/xU4fGazA6xs3QOEZlWbubKec2WwXuHih/WK8uLoVVfW75vNmYTp2+0xumdp6QpXYYLFwjF+VK2iU62ic22AkFWfEK09qPCTDS9++vZhlvkl6R1pDjjRzD5Tv7VPQxxZ8YWQscBuktKUr8yaIVkGPmFmn0/7fs3sPHyE0IgjSKBKGoN3YIRwX4PfhaZiJhKo8VYhJDTk1Ni7V0+oQTvVdj+21b4nYJ0X8Z0H8iA0muHxZgdUeqIuV+4Xmq5HE6ysWa53oHZqvXqhvKDjBFfWTo/tsHtm55RVdHm5K9qgX0BSE5LnmNOJVtGq9YLU1QRrLdGgYg+/HlW+OtT8ceGMdwec2olm9v3wd9bHjfiKSWkZh09cSEoWDdUBx5jZdRnmuCbDWPACPXdCNdSdCLe/NhKoocWWk2qoU0hvzJ4O/Lr+F7GQCw1dSrXdNzMH/C7lGg8B7zSzhlvRNMR1bkMD6h9rdoAzW2S9/dt7V9YGrifqdAO3/Mt6FpQWuV5NjDXWfQLPB4BpW+z5ZatyXHV5tJ1VVe7bype51VXZzCpsM3BrDwO3/prX21P60BY/nNXTaP64UlKIULzazKZmeW81YttqaFRBIiEZO6RCbLU1vmtmv8kwHuBWILFJZBALWmE/hXChmEXdb6uGKmkiPv82LWc1yLnPEqoS4pD6Ir424zp4Z9p8GmuN3XjN9G85FhbeJ143LT0k2PJHy6KFDtU7n2SwCBT/X4vLC0svV3u0a52FfQ8GRogk5tGJex4EXCzvnV+zsjSaVhrrdpUxJ+rgD67K5cI7p3zoFN6yX/LnJ6NcKrmPbX7tky8Os8wUYPWUpzab/NuWP9H8kIZsmvC4LNf/c4RHrfRhZgskLSAshLFl3TJCBWqouv/SEJXfQ99gkg6oZ5L+fT5Kf8mutOsNN2cq4hS3X2RYM4hYOz0ncPiTSYR69/+NmgM8VRrnuqNRtjsGhiryP7zWu6i0xCrq24Ka/ydEwPPIxL02EPo10GHmQ56qy9QdjZaTq55YJbqiFhNLnVffTDXv/zKcO3rTXz95x1BrSNqUsMpLZ7VAWwpVUJJ+vlm2++c2MKOFEtqyqGW93EK3/MEOqSF+HypQN5Y0ZD6wpB2AjwfM+/UhKkKFvu/XzGw4zWakMRVfqiyERDeOnZ962LlerVteWNq957WOGZVuPUpZ41xZ/+5Z0NHrytrcYu3V+kKntOTRiXul2iE8svleEXCdwYa1UiYYuIq2d5XoXEd0glVYo35rP2jL/7RVtP/mN864qclSp5Lec9wLZLEjDkVDk0QCkhZLCRWocxlkRstIqPx6qvkhYaTWUGMBlsZ4Xc9QF1voHVX4AP+hjPBnk/5Dv9HMhqrgHypQ3xAto+PiK5fhC1eEksa0MddgAxzbV5aWqIp7DeZjA4sB193ZHL6Yc+IIBoPTZbwdqMlS5ENDZ1a6XVepEpki7lEJqWSRSkTqsCgq2dJKT/SM69EaKvEthuk5Fvc8Ojr52+5jIa1xjhwZOK7VGupN9bVDsxDvokKLUOda4L2ekC3/zoSr2g0Fi5nNk7SYQYVnE7IlDQSqpN2B96ecq5fhQ5VCv0gt+wNmJS66sg++nOEHyV4pPfHNw4xXQDvU/X8f84WGVwxNM17G91dKHFv78OZ7HwB8uyaQ5aUp5msYnEu5dFOlbF6rrLUHBFQCRYZKHEJkyDimyVIfw3vJ07IBcIWk3+E/tyzV18BrmIfik0FCxw+LpPGEO6RuCxzXiE0J11BHlEDNYpAe7mJ7nrAYz6EamIUYvq8YqnhJnESQtgZAjZUuUGMtaiI+7W4i/rPeHV/PMq9UpF5SOEQMDf6stwN+j/HRgccB3hm4Cwmdgg9N2Htt4FdCpVrtUp9VCsA3EecYjFLtrZtR67lqVV+UJbaf3ofZtY1X6SNVt4JBfJbGXTdXBklMFqFKRRkY0gYdwPjAcS8OqsqfKyECNfQDfblJk7DcBGrc7CxthtFSvIlgKFp1I8mFeAs0CS8gN4l/3hqfVrgR4QVd0vB4fdJGAl4YlCM31qCB01LgK5I5EiYbGLpE2CaxMwvFHfYM+wewnowdoT+rVbWIA7zTSgZWUZmIz+381MNDZvJJ2pI3bpGQwSRx1oRe//ea2dLAsY0ILY40lB8nF9qpoTYTKqGet0ZxoSHa6ZVN7lyh7/tVM/tP4Nghib3KB8WPPfHCc2XX2kwZa9vIGamB30kbYEO9A5j60IS9P7Fn5wNDZtfcN2H/94joaGHUHrFzvxvpIrDfxbv/mlGVvv+jem315F2efahZkPxHm7z+RuLfCY4JFah5bvch3I8Tmv2XiFQCVdJYwkOHml1szwTOO0BDjdtCvyvlHIvxbQ2GY6U7pGKzw8fw/coTtRppMylNGxoYr+qF5ySgk0EVgeI6pG8FdjD0DoZIerh7wkGrR0Q/8SLS9f1eXvecgvGdWJuPjQB9ZoB6bdVhnLbr8w8mCZAPdQCNRBYnOCZUoN4TOG4oQjM1R5SGugvhDqlmbyQkXQ5gQ0lrmtniuKRZiEH+bDN7rckxoQI1s/1U0rb4dNIPEv75t4O0GuosfLZL/XvazdADxAK1r6Czf94hfn4vQwhUI7rA4Tbx3Uki6rTU+4RJ2O6xthp32TPqtNXliFsNHhZc3+z8Ja1BeDbZSOTZ4V7M4JDqJX8/wogUqGm9ZFkCeptdbE9Tr1Kk453x8wWkt2c9T5OyZZI2wteeDCFTDylJ1+EdPR9hZAvTHlLeFPfsfKDX0As1keeIcES7OaKHHBFVSvHvBj9H72g0398nHLqzQ5+Pj8ERYf7Ra0SnGzqzX0DXqu570RuHuz6DcRjGhrs9/+DsBG/hYEb23yQtzdoRhV7/03IM5ifuCRVyPc6Nq/O3jLQCNVRLe8XMXhnugLi4bWg86g8l3YavbJ+WkxM4UtrukIrrW07HJyZkbabYDh5r1AmgGY5o+iDhubojmlsnPKnWCcj4mPF3TThkhZhJI5pqRJH1C1IcwqELHPqKIxrXL2jrWpl4wSpgZ4ObSJ4K2rJCxSuBFxIIm9DroFG6eRbyTizKjXYJ1KRC5enA+Tckvd0U4C4zuznBcVluJKnviHF/+7/i4xRbRRWfMXIdcBrenPCjDPMF3Ti8NrqC8FzHES0brJ0OEqwDttp/nfDuDziig12/EI0f0TOOaIYjOqJOY+0zBECftjoddBTo07u/8GDS+rxvFoHqgP9OcFyohpq3QA09j5Y6pCCFDTVuHxJSJR+SX2wty7FtgAMmJzy2bQ4pSUcBPyS/2NBl+HJ6T+CLlszEe3OfbbANu1nS+wmLtw0ybTiih+MtN3XPexs8DBzY4LXa8874zpTcOuHwktAFcVdnRETU3z/lG2BX1JxUru6YOvvqHcL+bcb6e3Y+kKaC0VAx0Ekw/N9iuFDCPKk1Y6xFgiwDXsM7g682s6YVwggXZA81PyQVI1ZDTeOU2oXwrWdSwTIrcP4QbmzW6riOtjikJL0TXwwlizDtwguaO4B/4ouVpBES7WzvgqP0iPmg71F1wnJ/g2tBB/bl38NggdqnvRs6BqJJ9U2onBeU1wt3oKCRk6pe6B4Kbrmw76Q8/aDOu8BLwCeHSXEeccQOqZDiNK81q8QfQKhgb3k8eBqBmsUhlfTOEBo6lRYHnJXkwDjeMzQoPrGQkbQ28CvCY0kX42tx/iC04ntcODzEi7uMwIITB3Xe+fqdE97xYCxEiYXnZgZPNdJOoc/jL4A/TXh/h4im1AvK2MW1VHC5iP46SHjSL3QddVrtpft03pv2wg9pcQLwETN7IHDsymKlRbnUI2lDfKJKWhaY2ZANFfMijUDNEtietMVJuwTqVWb2ZMJj2+WQOpdwwX0v8F9mNjdwfI3QjJ/HstRhdUR/qxeo8fNooGr4thwNBGsUj/24sAn9cQI1orPBpoCNqtNYY8vqCtv+hRE2bDvoHJn9BhSmMHK0wpFyHg1Js4Vvhx1xHuFtN5KyEPh2iuND3/fLQ9R+XYG4CHYSp0AjrgPenoMwBR8GFEKmL6uj9LcG4VF7VImm1Xn2BzxXKUUAhr5Sv4mPj5/piGY7okMbOKmwFR+T9+28e2HAqYeYR/JMv2wnob3U8hZkI0JTHopEAjUurNHy1h9x2E1o6FRSzkhZHKEdN5KvExbP+DxwfMr8+eH4SOC4TF9WR3R/lWjewNCo6CBH6c6BIVUDHq/ePOHDuzqi3Ru8dqJDFw60ltaHUtUewqH/PaDzH78MPPXVAsa0opd9OxgpmuGIrviWVEPdlXBHSdoPNDRjKgkvAFekHNPSP2BcX/bTgWt8No7fzYykXQnPPsn0ZX1355+do/THQcJzW0f0SL2gHBTof5sj+nyDUKjfGdrZiMY3ELSDtdX5RhS6M4CGhVyasr6koM4DK4vYjxBiW2+FQ2pEa6hJbaitzJAazDTgvzKsNxxnpAk+l7Q5YZ5NSP6+307Y1vHfZvb3gHFD0azm51B0Ex4/3Icj+hVwbF2qqYDRoB6LS/bVvfZKt8Y+t4r1fnJQKFSvsO8J+1sDJ1WsPdR6nFgZ7JhDOm/LErb0Ir66V1p2BP6RYd0hkXQosB++5saGDFSEevEmr4XAL1LYckeEVhhnLL41YGjbOmYkFaihd4W5AZWWWhV8O4P07SayOKSSfpkOD5w/t5CbOCQmVFObnjIsqyGO6O+gThuYw3+goXuAQwd5/G9dUFrrPetWFtooyvWC85II+wLY2MHFUSCqc0xZVdhRh3XeckvG054FcTeAdLyLnAWqpHHAlcBRCYccRvLEhJGy3V/pBYqakXTLH5zDGzBm2BTVDJwat2ZOQ5ZmhEmdRAcGrnF/4LhG/AAYsjdXE3LRQt7febOrEl0+yAH1Lkd0e4P00xsqRF9eUlrt9Trb6GtG9GeHPlnvgGrwcA4dc1jnLUHdUweRNI55MJ+SFNogcwXiIi23kVyYQrJSfTVGikNqRGjKw9FUoMZ/rNCMkJAPtBXZUv80sz8FjGvHHTEkpg4GlAkNR9JxpG8VU09uF40jutoRLa8TnhN82miJMh10R2OpEl3/4iobP2uK9l2mVTrqbKPfcugsR6T6wij9NlZhqMfQce/t/FNejfHuDRy3EXBeHicgaUd8JtJ+KYYZwxdTH8wbXUMdOQIV2In2OaSIg9LzTscbrk9UQ+JSgC39IknamOSdJgezfeC4+vXfBfwk4zSPZz2PGh/qvH5Bj8Zc5ogq/bn7pY0d0UtCLIrW6J0zaoOHneNfDpWqitYuq2OeQzOMaI4RHTi4MIr1a6s3O6Jt/1/nH67J63zN7AnCO2ieKOkLoWtLGi1pMr5CVNqU8MvMLFE7kvg7GhKZMJIypEaUQN0lw/yhd6jMTo46bg4MpN6CsKaBkNzUkaol8iA+kcVbLOkYfGWlLFvPCvn+rXittM6PX+nY4N9d0Wr3OKKqI3p3lehWr2na/T0adZGT1nDygnJJNO5lIzrZEV2woic/qlWzOuTIzps+2Du7I802Nymh2q6AyyT9SNJ6iQdJq0g6Hl+7dCo+Rz8Nz5BOwRgR2/1YsIcUC0qTWJSZJAI19AOdl8GzltdFWsFXUgqhHRlSWYK81wKujrsoJEbS5pJ+A1xDWBxlPc/m1Ra4xuRZU1+oKrqlq7Ta/q+MWv+lrmi1NRyl25dEq93VHa16UE2QGhGmiO5ozKuO6K2OaPtYkM41olsc0VlGdLgR7TZ/3bXvvWSLyV96ddIGWYqZDMV1ZEtGOQF4UdINkr4k6RBJm0l6i6RNJW0laXdJn5f0a3xBk6uAzQLWWgQcYWavpxjTTv/JcIx47RSSaSehGmqWO9SwlcNTcKWZzWx+WENa1YywngX4UJbQnPAjgcck/RL4fbwFHUBsutgcn1b6KbyHOa9KVqHb3WFx6GxDnwbGL+4YN36RjbukGnXs5zPwheTLQfsq+9E5L49e79JRVp1l0oKqddwvVafjqESR3oZzP48W2wESX/3qzB/kntpsZp2SLge+nGGaVYEPx49WUQY+amZpCxCFKlR5C9QRbz+FJgJV0iqEN8PK8kZmZxhbowvfNiSUlt+ZzawsaTrZumZugS/0cpak/+CjJLrix3p4G/gaGeYfjlwjMi7c6qQdQe8xRbOBPxo6CsDEgVV0N+gQw2+rnK+PMr3Sob1ktlNVHb7ts2wvEaEInBlS9JqD95347PeaVaPPwneATxAes9xqKsDHzez2gLGFhpqCZlv+7Qm3sWV5I3ls+c8O7b8da3Xt0sz/GLhOIzbGN+87FPgAcACtE6aQs/PwmzO/93gV/cERHVBVdIRTRFURVZWOrEalV5xE34PIVSJ93qHT+mymfa8JQ4tdFP1QEXu1WJhiZgvw6cMjf3QaFwAABZtJREFUkSpwtJndlHZgXNkppNXIwhZUdnpTCNQsDqksb+R5/FY4lOfwRZpD2ZzWO6Rq/DZwnZFA7sWRT5t54TOnzbzgS45ouyp6OHYybeFMz1VVl4svXWZWer+htU1RfU6UmaK/OOm/Db1csY68zBvDYmbXAOe0Y60U9ADHmNlvAsfvHTgu1+QcSZsQFmnwn6QFivKimUANtZ9k6kUfl4LL4pE9JWPBkLal2sY23rsyrLcyaVnDsynPnPeiU7S/k35aVYRJ4x3R4lgL7bZS6XInfaWBdiqH3lNFZ6tDN58y8/xWF9vpw8ym4J19I4HngX3NLEvM7b6B40ZKQH/byyQ2E6g7Bc6bxxsJ3TI8HLK9GUSoTfM/gV0VjwWCikJnJGvKaFcuZ9GA07eZ0uGIji6r4/CKSji0j5OmOTTHEV1TdvqUQ2Oc+uNN48pS0036iquO2eOUGee3s6VOjeMIa2WeJzcAu5pZVjvmPoHj8hZkoYpdntmEiRjSPhrbEXcMnPfOwHH1PEb6xntG8j5Rw7F/4LigZmSxp/hYfMX+LLGpSXkJuBD4Od7meidh7W1ey/Ok6nGK3mb+wjwO+Bnwuqt0HK+Oyu1Iz2F25KrS+mWVx8lF60WuYyHjmHvGI2d0t+qckhCnN58k6Ul80kRoBEcI0/Ap1iHOp0aElOzsJf8dV6hi13aBKrPGGYySIvwFk9ZzuRzY1MwyXWySDiG9YL7YzL6RZd147btJL1QNOMTMgr9MkvYEbgbeFjpHE+bhtadL6hv0SfoZXktOwzLgLSljGlNx6nZnRgbXgb5u8A4jOljYvAufnHLyaducOamq6B0XPjXlslatnxVJ2wIXAO9r8VJP4yMNfmtDXdABSJpH+rJ9vzKzT+Z1DvF5/Ip0dQrAfybb5fl5JGFIrSS+0/4Qb9hOynR84HBmzSUuTXcByYKmF8XHnpR13Zjz8cInKfOBb2YRpgBm9hC+JulZ5GcCqAC34muubmpmFzbodvo1/I4gKd3A5FYKU4Aq0Z6O6IwLnjx9jlP0Ryf9l5O+B3De02c8Gxkt9d5nxcyeMrMj8KmhF5JvmNlC4HJgHzPb1sxuaIHwmELy76EBfwK+mPM5gK9hnMa59DxwbLuFKQyjofYd4JvHDZfyNQZfz/MVfL+cXN9EnF45Hp/VE+EFxBL6BX03vrpT3usKX96s2ZbNgM4cq+bX1l8H+Dheu9kXWD3h0Aq+VOF9+OIdtycJH4vf7+74VsPDsRiYkaaubCgnbn/uGhfN+FYXwNd2OP8omX0H2OviGaeFtCtZ6UgqAe/El/zbF+9sSZo6ugR/03sQuBv4S97fuUZIWgt//Y1lxWvB8DuVBfjc/cUtPI818NE39a2wB58L+F31rHZ8PxvRVKAWrHziC3FL/I1tAj7tFPq/RAvxWvIsvHBfKV+mVvGVHS6MhD0g+KVB1yVPnBLasmREIWkUXnvdFH/DjPB/22V401kXPj15drsKJBdkI7eajAWtIy7g/Ez8eKOGWAXjFH1Y2J2Y/QrpSuBNIVDjG98MWtv2p6CNhHh2Cwraxhd2+r4cmuzQRZc+8c2FVVT64o4XNTNLFBSsFAqBWjCiceiDTvrHjx8/aR6AU/Qnp+i9K/u8CgoaUQjUghHLkdufri7XPblsri9Qfqn1/n6x6z5iZZ5XQcFQFAK1YMTS5bqP7HLd/7z68ZPm13537eOnLpjvlox5+7YntSMBoqAgFYVALRixLHbdk7ts2fcH/35+dclt811X2iy6goKWUwjUghHJNlt95ohu67nn7qemzh/8Wrf1/K7XKsW2v2DEUQjUgpHKZGAF7RTg6ZlXzwdW32arzxRhfwUjikKgFow4ttnqM4cD9z098+oFwxx2J3Bwe86ooCAZhUAtGImcAFzc5JjfEdaorqCgZfx/v2CTW+S1eMcAAAAASUVORK5CYII=" alt="./images"></p><h2 id="1、构建"><a href="#1、构建" class="headerlink" title="1、构建"></a>1、构建</h2><p>Java 项目开发过程中，构建指的是使用『原材料生产产品』的过程。</p><ul><li><p>原材料</p><ul><li><p>Java 源代码</p></li><li><p>基于 HTML 的 Thymeleaf 文件</p></li><li><p>图片</p></li><li><p>配置文件</p></li><li><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6></li></ul></li><li><p>产品</p><ul><li>一个可以在服务器上运行的项目</li></ul></li></ul><p>构建过程包含的主要的环节：</p><ul><li>清理：删除上一次构建的结果，为下一次构建做好准备</li><li>编译：Java 源程序编译成 *.class 字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库</li><li>部署<ul><li>部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上</li><li>部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</li></ul></li></ul><h2 id="2、依赖"><a href="#2、依赖" class="headerlink" title="2、依赖"></a>2、依赖</h2><p>如果 A 工程里面用到了 B 工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。例如：</p><ul><li>junit-4.12 依赖 hamcrest-core-1.3</li><li>thymeleaf-3.0.12.RELEASE 依赖 ognl-3.1.26<ul><li>ognl-3.1.26 依赖 javassist-3.20.0-GA</li></ul></li><li>thymeleaf-3.0.12.RELEASE 依赖 attoparser-2.0.5.RELEASE</li><li>thymeleaf-3.0.12.RELEASE 依赖 unbescape-1.1.6.RELEASE</li><li>thymeleaf-3.0.12.RELEASE 依赖 slf4j-api-1.7.26</li></ul><p>依赖管理中要解决的具体问题：</p><ul><li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li><li>jar 包之间的依赖：通过依赖的传递性自动完成</li><li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul><h2 id="3、Maven-的工作机制"><a href="#3、Maven-的工作机制" class="headerlink" title="3、Maven 的工作机制"></a>3、Maven 的工作机制</h2><p><img src="https://image.3001.net/images/20220922/16638123817009.png" alt="image-20220922100621134"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;第一节-为什么要学习Maven？&quot;&gt;&lt;a href=&quot;#第一节-为什么要学习Maven？&quot; class=&quot;headerlink&quot; title=&quot;第一节 为什么要学习Maven？&quot;&gt;&lt;/a&gt;第一节 为什么要学习Maven？&lt;/h1&gt;&lt;h2 id=&quot;1、Maven-作为依赖管理工具&quot;&gt;&lt;a href=&quot;#1、Maven-作为依赖管理工具&quot; class=&quot;headerlink&quot; title=&quot;1、Maven 作为依赖管理工具&quot;&gt;&lt;/a&gt;1、Maven 作为依赖管理工具&lt;/h2&gt;&lt;h3 id=&quot;①jar-包的规模&quot;&gt;&lt;a href=&quot;#①jar-包的规模&quot; class=&quot;headerlink&quot; title=&quot;①jar 包的规模&quot;&gt;&lt;/a&gt;①jar 包的规模&lt;/h3&gt;&lt;p&gt;随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="maven" scheme="https://yangmour.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>第三章 使用 Maven：命令行环境</title>
    <link href="https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/3.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BD%BF%E7%94%A8%20Maven%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <id>https://yangmour.github.io/2022/09/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/maven/3.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BD%BF%E7%94%A8%20Maven%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83/</id>
    <published>2022-09-25T14:06:17.000Z</published>
    <updated>2022-09-26T03:40:24.837Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第一节-实验一：根据坐标创建-Maven-工程"><a href="#第一节-实验一：根据坐标创建-Maven-工程" class="headerlink" title="第一节 实验一：根据坐标创建 Maven 工程"></a>第一节 实验一：根据坐标创建 Maven 工程</h1><h2 id="1、Maven-核心概念：坐标"><a href="#1、Maven-核心概念：坐标" class="headerlink" title="1、Maven 核心概念：坐标"></a>1、Maven 核心概念：坐标</h2><h3 id="①数学中的坐标"><a href="#①数学中的坐标" class="headerlink" title="①数学中的坐标"></a>①数学中的坐标</h3><p><img src="https://image.3001.net/images/20220926/16641606046087.png" alt="1"></p><p>使用 x、y、z 三个<strong>『向量』</strong>作为空间的坐标系，可以在<strong>『空间』</strong>中唯一的定位到一个<strong>『点』</strong>。</p><span id="more"></span><h3 id="②Maven中的坐标"><a href="#②Maven中的坐标" class="headerlink" title="②Maven中的坐标"></a>②Maven中的坐标</h3><h4 id="1-向量说明"><a href="#1-向量说明" class="headerlink" title="[1]向量说明"></a>[1]向量说明</h4><p>使用三个<strong>『向量』</strong>在<strong>『Maven的仓库』</strong>中<strong>唯一</strong>的定位到一个<strong>『jar』</strong>包。</p><ul><li><strong>groupId</strong>：公司或组织的 id</li><li><strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id</li><li><strong>version</strong>：版本号</li></ul><h4 id="2-三个向量的取值方式"><a href="#2-三个向量的取值方式" class="headerlink" title="[2]三个向量的取值方式"></a>[2]三个向量的取值方式</h4><ul><li>groupId：公司或组织域名的倒序，通常也会加上项目名称<ul><li>例如：com.atguigu.maven</li></ul></li><li>artifactId：模块的名称，将来作为 Maven 工程的工程名</li><li>version：模块的版本号，根据自己的需要设定<ul><li>例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本</li><li>例如：RELEASE 表示正式版本</li></ul></li></ul><p>举例：</p><ul><li>groupId：com.atguigu.maven</li><li>artifactId：pro01-atguigu-maven</li><li>version：1.0-SNAPSHOT</li></ul><h3 id="③坐标和仓库中-jar-包的存储路径之间的对应关系"><a href="#③坐标和仓库中-jar-包的存储路径之间的对应关系" class="headerlink" title="③坐标和仓库中 jar 包的存储路径之间的对应关系"></a>③坐标和仓库中 jar 包的存储路径之间的对应关系</h3><p>坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面坐标对应的 jar 包在 Maven 本地仓库中的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><p>一定要学会根据坐标到本地仓库中找到对应的 jar 包。</p><h2 id="2、实验操作"><a href="#2、实验操作" class="headerlink" title="2、实验操作"></a>2、实验操作</h2><h3 id="①创建目录作为后面操作的工作空间"><a href="#①创建目录作为后面操作的工作空间" class="headerlink" title="①创建目录作为后面操作的工作空间"></a>①创建目录作为后面操作的工作空间</h3><p>例如：D:\maven-workspace\space201026</p><p>WARNING</p><p>此时我们已经有了三个目录，分别是：</p><ul><li>Maven 核心程序：中军大帐</li><li>Maven 本地仓库：兵营</li><li>本地工作空间：战场</li></ul><h3 id="②在工作空间目录下打开命令行窗口"><a href="#②在工作空间目录下打开命令行窗口" class="headerlink" title="②在工作空间目录下打开命令行窗口"></a>②在工作空间目录下打开命令行窗口</h3><p><img src="https://image.3001.net/images/20220926/16641607527417.png" alt="1"></p><h3 id="③使用命令生成Maven工程"><a href="#③使用命令生成Maven工程" class="headerlink" title="③使用命令生成Maven工程"></a>③使用命令生成Maven工程</h3><p><img src="https://image.3001.net/images/20220926/16641608091666.png" alt="1"></p><p>运行 <strong>mvn archetype:generate</strong> 命令</p><p>下面根据提示操作</p><p>TIP</p><p>Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:【直接回车，使用默认值】</p><p>Define value for property ‘groupId’: com.atguigu.maven</p><p>Define value for property ‘artifactId’: pro01-maven-java</p><p>Define value for property ‘version’ 1.0-SNAPSHOT: :【直接回车，使用默认值】</p><p>Define value for property ‘package’ com.atguigu.maven: :【直接回车，使用默认值】</p><p>Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro01-maven-java version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入 N 再回车。】</p><h3 id="④调整"><a href="#④调整" class="headerlink" title="④调整"></a>④调整</h3><p>Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。</p><p>自动生成的 App.java 和 AppTest.java 可以删除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖信息配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependencies复数标签：里面包含dependency单数标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependency单数标签：配置一个具体的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过坐标来依赖其他jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 依赖的范围 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="⑤自动生成的-pom-xml-解读"><a href="#⑤自动生成的-pom-xml-解读" class="headerlink" title="⑤自动生成的 pom.xml 解读"></a>⑤自动生成的 pom.xml 解读</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、Maven核心概念：POM"><a href="#3、Maven核心概念：POM" class="headerlink" title="3、Maven核心概念：POM"></a>3、Maven核心概念：POM</h2><h3 id="①含义"><a href="#①含义" class="headerlink" title="①含义"></a>①含义</h3><p>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p><h3 id="②模型化思想"><a href="#②模型化思想" class="headerlink" title="②模型化思想"></a>②模型化思想</h3><p>POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</p><h3 id="③对应的配置文件"><a href="#③对应的配置文件" class="headerlink" title="③对应的配置文件"></a>③对应的配置文件</h3><p>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。</p><h2 id="4、Maven核心概念：约定的目录结构"><a href="#4、Maven核心概念：约定的目录结构" class="headerlink" title="4、Maven核心概念：约定的目录结构"></a>4、Maven核心概念：约定的目录结构</h2><h3 id="①各个目录的作用"><a href="#①各个目录的作用" class="headerlink" title="①各个目录的作用"></a>①各个目录的作用</h3><p><img src="https://image.3001.net/images/20220926/16641609575011.png" alt="1"></p><p>另外还有一个 target 目录专门存放构建操作输出的结果。</p><h3 id="②约定目录结构的意义"><a href="#②约定目录结构的意义" class="headerlink" title="②约定目录结构的意义"></a>②约定目录结构的意义</h3><p>Maven 为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。</p><h3 id="③约定大于配置"><a href="#③约定大于配置" class="headerlink" title="③约定大于配置"></a>③约定大于配置</h3><p>Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p><p>目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码。</p><h1 id="第二节-实验二：在-Maven-工程中编写代码"><a href="#第二节-实验二：在-Maven-工程中编写代码" class="headerlink" title="第二节 实验二：在 Maven 工程中编写代码"></a>第二节 实验二：在 Maven 工程中编写代码</h1><h2 id="1、主体程序"><a href="#1、主体程序" class="headerlink" title="1、主体程序"></a>1、主体程序</h2><p><img src="https://image.3001.net/images/20220926/16641616754791.png" alt="1"></p><p>主体程序指的是被测试的程序，同时也是将来在项目中真正要使用的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、测试程序"><a href="#2、测试程序" class="headerlink" title="2、测试程序"></a>2、测试程序</h2><p><img src="https://image.3001.net/images/20220926/16641617423463.png" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.maven.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入的效果是将Assert类中的静态资源导入当前类</span></span><br><span class="line"><span class="comment">// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Calculator对象</span></span><br><span class="line">Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用Calculator对象的方法，获取到程序运行实际的结果</span></span><br><span class="line"><span class="keyword">int</span> actualResult = calculator.sum(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明一个变量，表示程序运行期待的结果</span></span><br><span class="line"><span class="keyword">int</span> expectedResult = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用断言来判断实际结果和期待结果是否一致</span></span><br><span class="line"><span class="comment">// 如果一致：测试通过，不会抛出异常</span></span><br><span class="line"><span class="comment">// 如果不一致：抛出异常，测试失败</span></span><br><span class="line">assertEquals(expectedResult, actualResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验三：执行-Maven-的构建命令"><a href="#实验三：执行-Maven-的构建命令" class="headerlink" title="实验三：执行 Maven 的构建命令"></a>实验三：执行 Maven 的构建命令</h1><h2 id="1、要求"><a href="#1、要求" class="headerlink" title="1、要求"></a>1、要求</h2><p>运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The goal you specified <span class="keyword">requires</span> a project to execute but there is no POM in <span class="keyword">this</span> directory</span><br></pre></td></tr></table></figure><p>TIP</p><p>mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。</p><h2 id="2、清理操作"><a href="#2、清理操作" class="headerlink" title="2、清理操作"></a>2、清理操作</h2><p>mvn clean</p><p>效果：删除 target 目录</p><h2 id="3、编译操作"><a href="#3、编译操作" class="headerlink" title="3、编译操作"></a>3、编译操作</h2><p>主程序编译：mvn compile</p><p>测试程序编译：mvn test-compile</p><p>主体程序编译结果存放的目录：target/classes</p><p>测试程序编译结果存放的目录：target/test-classes</p><h2 id="4、测试操作"><a href="#4、测试操作" class="headerlink" title="4、测试操作"></a>4、测试操作</h2><p>mvn test</p><p>测试的报告存放的目录：target/surefire-reports</p><h2 id="5、打包操作"><a href="#5、打包操作" class="headerlink" title="5、打包操作"></a>5、打包操作</h2><p>mvn package</p><p>打包的结果——jar 包，存放的目录：target</p><h2 id="6、安装操作"><a href="#6、安装操作" class="headerlink" title="6、安装操作"></a>6、安装操作</h2><p>mvn install</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\target\pro01-maven-java-1.0-SNAPSHOT.jar to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\pom.xml to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.pom</span><br></pre></td></tr></table></figure><p>安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。</p><p>坐标信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Maven 仓库中生成的路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p><h1 id="实验四：创建-Maven-版的-Web-工程"><a href="#实验四：创建-Maven-版的-Web-工程" class="headerlink" title="实验四：创建 Maven 版的 Web 工程"></a>实验四：创建 Maven 版的 Web 工程</h1><h2 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h2><p>使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法：</p><p><img src="https://image.3001.net/images/20220926/16641619469677.png" alt="1"></p><p>参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。</p><h2 id="2、操作"><a href="#2、操作" class="headerlink" title="2、操作"></a>2、操作</h2><p>注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：不能在一个非 pom 的工程下再创建其他工程。所以不要再刚才创建的工程里再创建新的工程，<strong>请回到工作空间根目录</strong>来操作。</p><p>然后运行生成工程的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure><p>下面的操作按照提示执行：</p><p>TIP</p><p>Define value for property ‘groupId’: com.atguigu.maven Define value for property ‘artifactId’: pro02-maven-web Define value for property ‘version’ 1.0-SNAPSHOT: :【直接回车，使用默认值】</p><p>Define value for property ‘package’ com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro02-maven-web version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认】</p><h2 id="3、生成的pom-xml"><a href="#3、生成的pom-xml" class="headerlink" title="3、生成的pom.xml"></a>3、生成的pom.xml</h2><p>确认打包的方式是war包形式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4、生成的Web工程的目录结构"><a href="#4、生成的Web工程的目录结构" class="headerlink" title="4、生成的Web工程的目录结构"></a>4、生成的Web工程的目录结构</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALMAAAB7CAIAAACwzSZ9AAAKpklEQVR42u2df2ybRxnHzyT5AxptY2lJ0NakSZ2gVGZ/ACIjoYAmgRYn7bKBjFppRJOQI7GJRINIoLitWjkCVlY1qIBqIdFqUiSiKaq2JaZUqoamRstYxyhRVdWmSZo1S2k7OihDIr+49733x72vn/Pr2H7f997wfCpZzvX12X7vk+fOzn3t0Pr6OkGQHEJoBgKCZiAwoYtLaAYCgGYgMGgGAoNmIDDlN6P55l5lVav8I8olW+HqV+jFf6saFz99wu8njjhQfjPCS3vue+jbigtkTRGBXipemJd35l+db5j0+4kjDrhgxvt77ns4JtKCttyZm5jfgWaUQna0u3n2+fWhx1y8j/KbsfP9Pfc//C2RFvTK7fn0dbfMSA/XRceVK+0/ePPC/h1q2/m+z+9PEVtjsPHVDLosCIVC+VtAdi5SM74p0oJeuT2Xvt6Ydul8ndub+W08rNpAfrF0soO60n31O6/1byeEaww6/pnx6u9OzWWufO9HyYrKStayurLyq58mGltau2O9+XtsutH9wPanRFrQK7dmzy40uWDG3Mgzj17+rjbw4LmjFSXZuBnKhk9mrK2u/vInQ399Z/qzn2tjcjAtWMuzPx7+WEVFnh5VM54UaUErz625PwjMYE94kuxnMwJ5apQ9ea79C8fPKAXAmDUoca0M0JKQ7rl4tJO1XhgM/aZZrR8GwpqhGjMaO7d/4BK7U6JNQI8c0XtQtFP+V39UXH0iZCHV0fNKzPbA9NuqnR+JvHjQ2iEH91CVmxP2rOmjPbZL0KfoRLlsBmVlefnXPzvAVIj/8FDq54d5UfL32PQeNeMJkRZqzTi3sPP3IjNefJsbaW0gre3qmcoap1g/rJ4OTyYhNEMd2jB8BtVTz5xji5KnJ5V+zCKUHR2c2H3UOiWZI2f8BvM1iW+Mjpsdjn09p2gtGI/8fN8zx2bI3tP0YeuPPwP1KTpR7ptB9OmDCvGJLdUf/ftegVpQGhe6Pln/hEiL9bXlW3OvLza+vFZRDZrBFUnLiTDbzSGxHkaENUM59QcJt/y0LVT5ERVdZ51MqTePaysY9r9EF8hc6mqov+K2oe0lJ9g9cg9A74EMdsw/m5h9ji6Mut5gR14D+ySCE+WJGbwchWuhmbF9D6gFvX538eLqyn8+qmq59dAL5TNDP4lmu3kTqsj3yaRhDISTGcrIDRBWpbjVDJPvCOk9SE5ry17LA8vt3DAj94nTds6J52PnjpEjrIYBfWZ9NoPJkR4fffzJfZVVVQX2uON614P13aAWtOXvs+drtrffWZh6L5w7oahFslUbRfV3NGLMJtwzz5lN7FWda7QsS4s1g3OOe1TqDPXc5TCZaTxhHK+vEhRv+shRrrTkM0Pp9uAr5FKrMqew62xOEfQpOlEemlEEO+ajDzZ0gVrQy5vXztc2PUYvbzSfBc2YbY2Pv8Tqp7GwyP2dgFaghF8n8nOwpRpDizXH2YTN68qhjzwdJy8R/hWQMULWB2DcUUFmWJZBtuUI0KfoRJWT8pvRMB+tqe8UvTt+89rrtU1fo5c3WgRmuPxiDCkQF8yYi9Y0PC56d3zp2h/rmr5KLxfRDLkpvxn1c9GtDd8QvTu+9Lc36nbuppeLn0EzpMYFM2Y7ta2l6/pf4Pk/ypP1EAmtVWxZCo+Xci+I2+DOHQQGzUBg0AwEBs1AYDCJhMCgGQgMmoHAoBkIjHdm/OuSQw6l4uON90cwhyIL3pnxz78451BqvohpA1nw0Ix3nXMoNW1ohix4Z8aH7zrnULaiGdKwYTOKzqF8+GfnHMrWR93IoSDFsDEzTp06deXKlWQyWanvCV1ZWUkkEq2trb29DjmUu+8451C2fQnNkIUNmLG6ujo0NDQ9Pd3W1sbkYFqwluHh4Yq8ORTVDIccisiM7EhH84C2b3ty/WSn2nA5MUmi0VT78cyF/jBJ94WiWkaRNSClsbGasby8fODAAabCoUOHDh8+zIuS/7Z3LzrnULa1QzkUpoEihKVpYIpZQlG0mEEhysqG1xlGnaiurr53716BWlD+8bZzDmVb28uhytwcCqsHfC2wykL/P7kLvSgvxbw24SeRArUgzAynHErFlpYHIi8IOmB1gvmBZrhOka9aqRyjo6P79u2rKjiH8sGfCsqhfKojZ0LJjoxk+vs7CVcqbBOMUlSINrWkR0aa+1GSkvHu/YwP3iooh1L75dydw9zyUlta5Cw9zDWqsfhASsI7M+68VVAOpXb32dLvCykdD82YLiiHUodmyIF3ZtyeLiiHUvcVNEMKPDTjTeccSqhyS2075lCkAHfuIDBoBgKDZiAwaAYCg2YgMGgGAoNmIDBoBgLjvxmYQ5ET/83AHIqcSGCGxzkU5e/1YzHc5+OE/2Z4nUNBMwqjbGZgDmWTUR4zMIey+SiDGf7lUNSdwZOxsaiyz0/Z5Ue0XYHmNvOcpAq3UVC9+fHIwID1JohKeWqGPzkUtj2UDSnbKcrHlNi1vomuk+qAG5uILWZEU+ZNcPFhoWzrDJ9yKEaaQHQ9p2rYaoZ2GG3tJafRDJNyvjbxPIfiZAZRpCBsmgACCWhGPsr8qtXTHIqjGRmzTa0cEawZheP/+xkl5FAcZxNzJmmPx0mKYM0oHP/NwByKnEhgBuZQpMR/MzCHIicSmIE5FCnx3wxETtAMBAbNQGDQDAQGzUBg0AwEBs1AYNAMBEZeMzCH4i/ymoE5FH+R2AzvcijAx1cj8prhYQ4FzQBw3Ywg5FDQDAB3zQhIDgXNAHDRDL9yKNwmPu7zyM3W3G9C4b4tRW03P6A6N64iPFjcSTBxt2b4kkPhN3p2JGdI7DTLo9g3DVu3k5vflmLqBMVViPhguD2ouL7O8CGHoo846eu4Opi43Ht18ELXBNsAnDHqhYZaNoh1NrFMLoKvY8o9OJunkyDixWsTz3MobCM450QiNpYkfOkI24+HBrUZiqugGeXF2xyKqsYYmYpoI0avsznFVuXTfX3kpD4RRLj1AvshDcVVRAcL24OKvO9nlPJ9KJaRsWVWRYvKSDyVsq0dobhK3oOh9qAirxmy5lBE00Tgpw8bEpshaQ4FzfAbWXMoaIbfYA7FX+Q1A/EXNAOBQTMQGDQDgUEzEBg0A4FBMxAYNAOBCZ4ZmEPxhuCZgTkUbwigGR5/H8r/K8Ezo+gcim1rJrBtQ/mxa8LYvqEQN/YXm7sExR9eb9/rM2U91PxvbpMIkfTT8ANoRtE5FODjyM0x4T+ROvdPprbPoRVt/rWZoWzkmeE2F1rNkPwPs8Ezo/gciqVK0FE6Q+Ip0mNs62KfIZx1NCPPqNrNSGR2JbnChGa4Sgnfh8KNhyJGjzJu9m2/jmbkG1TgsGZu3yGa4SolfB+KOSCqGOqw9ep7ys/0GLtGzRUAHx/Z+DrDdM2+5dhyL1IuMwJoRgnfh2JMGnr8JKz93HLUoSRYlijmQsMQRhtcQWnR3eg5gzXDRUrIoRBzFtG/mMD+cyFmEDi1QvJMOsyNuLEgRTNcoJQcCtFXnjO7Bs0CYPl5QzUD6FxUe7T5o/04muEWJeVQCOG/PQ362brO4KYJLvUozJLkXahmwcibtATPDFlzKJuNAJohaQ5lsxE8M2TNoWw2AmgG5lA8IXhmIN6AZiAwaAYCg2YgMP8DCKejFGc0blMAAAAASUVORK5CYII=" alt="./images"></p><p>webapp 目录下有 index.jsp</p><p>WEB-INF 目录下有 web.xml</p><h2 id="5、创建-Servlet"><a href="#5、创建-Servlet" class="headerlink" title="5、创建 Servlet"></a>5、创建 Servlet</h2><h3 id="①在-main-目录下创建-java-目录"><a href="#①在-main-目录下创建-java-目录" class="headerlink" title="①在 main 目录下创建 java 目录"></a>①在 main 目录下创建 java 目录</h3><p><img src="https://image.3001.net/images/20220926/16641619928607.png" alt="1"></p><h3 id="②在-java-目录下创建-Servlet-类所在的包的目录"><a href="#②在-java-目录下创建-Servlet-类所在的包的目录" class="headerlink" title="②在 java 目录下创建 Servlet 类所在的包的目录"></a>②在 java 目录下创建 Servlet 类所在的包的目录</h3><p><img src="https://image.3001.net/images/20220926/16641620096437.png" alt="1"></p><h3 id="③在包下创建-Servlet-类"><a href="#③在包下创建-Servlet-类" class="headerlink" title="③在包下创建 Servlet 类"></a>③在包下创建 Servlet 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">response.getWriter().write(<span class="string">&quot;hello maven web&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="④在-web-xml-中注册-Servlet"><a href="#④在-web-xml-中注册-Servlet" class="headerlink" title="④在 web.xml 中注册 Servlet"></a>④在 web.xml 中注册 Servlet</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.maven.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6、在-index-jsp-页面编写超链接"><a href="#6、在-index-jsp-页面编写超链接" class="headerlink" title="6、在 index.jsp 页面编写超链接"></a>6、在 index.jsp 页面编写超链接</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;helloServlet&quot;</span>&gt;</span>Access Servlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>:::TIP</p><p>JSP全称是 Java Server Page，和 Thymeleaf 一样，是服务器端页面渲染技术。这里我们不必关心 JSP 语法细节，编写一个超链接标签即可。</p><p>:::</p><h2 id="7、编译"><a href="#7、编译" class="headerlink" title="7、编译"></a>7、编译</h2><p>此时直接执行 mvn compile 命令出错：</p><p>:::DANGER</p><p>程序包 javax.servlet.http 不存在</p><p>程序包 javax.servlet 不存在</p><p>找不到符号</p><p>符号: 类 HttpServlet</p><p>……</p><p>:::</p><p>上面的错误信息说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，Web 工程需要依赖 servlet-api.jar 包。</p><p><img src="https://image.3001.net/images/20220926/16641622101242.png" alt="1"></p><h2 id="8、配置对-servlet-api-jar-包的依赖"><a href="#8、配置对-servlet-api-jar-包的依赖" class="headerlink" title="8、配置对 servlet-api.jar 包的依赖"></a>8、配置对 servlet-api.jar 包的依赖</h2><p>对于不知道详细信息的依赖可以到<a href="https://mvnrepository.com/%E7%BD%91%E7%AB%99%E6%9F%A5%E8%AF%A2%E3%80%82%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%88%97%E8%A1%A8%E4%B8%AD%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82">https://mvnrepository.com/网站查询。使用关键词搜索，然后在搜索结果列表中选择适合的使用。</a></p><p><img src="https://image.3001.net/images/20220926/16641622716724.png" alt="1"></p><p>比如，我们找到的 servlet-api 的依赖信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就可以把上面的信息加入 pom.xml。重新执行 mvn compile 命令。</p><h2 id="9、将-Web-工程打包为-war-包"><a href="#9、将-Web-工程打包为-war-包" class="headerlink" title="9、将 Web 工程打包为 war 包"></a>9、将 Web 工程打包为 war 包</h2><p>运行 mvn package 命令，生成 war 包的位置如下图所示：</p><p><img src="https://image.3001.net/images/20220926/16641622923622.png" alt="1"></p><h2 id="10、将-war-包部署到-Tomcat-上运行"><a href="#10、将-war-包部署到-Tomcat-上运行" class="headerlink" title="10、将 war 包部署到 Tomcat 上运行"></a>10、将 war 包部署到 Tomcat 上运行</h2><p>将 war 包复制到 Tomcat/webapps 目录下</p><p><img src="https://image.3001.net/images/20220926/16641623183227.png" alt="1"></p><p>启动 Tomcat：</p><p><img src="https://image.3001.net/images/20220926/16641623275450.png" alt="1"></p><p><img src="https://image.3001.net/images/20220926/1664162338482.png" alt="1"></p><p>通过浏览器尝试访问：<a href="http://localhost:8080/pro02-maven-web/index.jsp">http://localhost:8080/pro02-maven-web/index.jsp</a></p><h1 id="实验五：让-Web-工程依赖-Java-工程"><a href="#实验五：让-Web-工程依赖-Java-工程" class="headerlink" title="实验五：让 Web 工程依赖 Java 工程"></a>实验五：让 Web 工程依赖 Java 工程</h1><h2 id="1、观念"><a href="#1、观念" class="headerlink" title="1、观念"></a>1、观念</h2><p>明确一个意识：从来只有 Web 工程依赖 Java 工程，没有反过来 Java 工程依赖 Web 工程。本质上来说，Web 工程依赖的 Java 工程其实就是 Web 工程里导入的 jar 包。最终 Java 工程会变成 jar 包，放在 Web 工程的 WEB-INF/lib 目录下。</p><h2 id="2、操作-1"><a href="#2、操作-1" class="headerlink" title="2、操作"></a>2、操作</h2><p>在 pro02-maven-web 工程的 pom.xml 中，找到 dependencies 标签，在 dependencies 标签中做如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置对Java工程pro01-maven-java的依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体的配置方式：在dependency标签内使用坐标实现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、在-Web-工程中，编写测试代码"><a href="#3、在-Web-工程中，编写测试代码" class="headerlink" title="3、在 Web 工程中，编写测试代码"></a>3、在 Web 工程中，编写测试代码</h2><h3 id="①补充创建目录"><a href="#①补充创建目录" class="headerlink" title="①补充创建目录"></a>①补充创建目录</h3><p>pro02-maven-web<strong>\src\test\java\com\atguigu\maven</strong></p><h3 id="②确认-Web-工程依赖了-junit"><a href="#②确认-Web-工程依赖了-junit" class="headerlink" title="②确认 Web 工程依赖了 junit"></a>②确认 Web 工程依赖了 junit</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="③创建测试类"><a href="#③创建测试类" class="headerlink" title="③创建测试类"></a>③创建测试类</h3><p>把 Java 工程的 CalculatorTest.java 类复制到 pro02-maven-wb<strong>\src\test\java\com\atguigu\maven</strong> 目录下</p><h2 id="4、执行Maven命令"><a href="#4、执行Maven命令" class="headerlink" title="4、执行Maven命令"></a>4、执行Maven命令</h2><h3 id="①测试命令"><a href="#①测试命令" class="headerlink" title="①测试命令"></a>①测试命令</h3><p>mvn test</p><p>说明：测试操作中会提前自动执行编译操作，测试成功就说明编译也是成功的。</p><h3 id="②打包命令"><a href="#②打包命令" class="headerlink" title="②打包命令"></a>②打包命令</h3><p>mvn package</p><p><img src="https://image.3001.net/images/20220926/16641625319471.png" alt="1"></p><p>通过查看 war 包内的结构，我们看到被 Web 工程依赖的 Java 工程确实是会变成 Web 工程的 WEB-INF/lib 目录下的 jar 包。</p><p><img src="https://image.3001.net/images/20220926/16641625467445.png" alt="1"></p><h3 id="③查看当前-Web-工程所依赖的-jar-包的列表"><a href="#③查看当前-Web-工程所依赖的-jar-包的列表" class="headerlink" title="③查看当前 Web 工程所依赖的 jar 包的列表"></a>③查看当前 Web 工程所依赖的 jar 包的列表</h3><p>mvn dependency:list</p><p>:::TIP</p><p>[INFO] The following files have been resolved:<br>[INFO] org.hamcrest:hamcrest-core:jar:1.3:test<br>[INFO] javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>[INFO] junit:junit:jar:4.12:test</p><p>:::</p><p>说明：javax.servlet:javax.servlet-api:jar:3.1.0:provided 格式显示的是一个 jar 包的坐标信息。格式是：</p><p>:::TIP</p><p>groupId:artifactId:打包方式:version:依赖的范围</p><p>:::</p><p>这样的格式虽然和我们 XML 配置文件中坐标的格式不同，但是本质上还是坐标信息，大家需要能够认识这样的格式，将来从 Maven 命令的日志或错误信息中看到这样格式的信息，就能够识别出来这是坐标。进而根据坐标到Maven 仓库找到对应的jar包，用这样的方式解决我们遇到的报错的情况。</p><h3 id="④以树形结构查看当前-Web-工程的依赖信息"><a href="#④以树形结构查看当前-Web-工程的依赖信息" class="headerlink" title="④以树形结构查看当前 Web 工程的依赖信息"></a>④以树形结构查看当前 Web 工程的依赖信息</h3><p>mvn dependency:tree</p><p>:::TIP</p><p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>[INFO] +- junit:junit:jar:4.12:test<br>[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</p><p>:::</p><p>我们在 pom.xml 中并没有依赖 hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit 依赖了hamcrest-core，然后基于依赖的传递性，hamcrest-core 被传递到我们的工程了。</p><h1 id="实验六：测试依赖的范围"><a href="#实验六：测试依赖的范围" class="headerlink" title="实验六：测试依赖的范围"></a>实验六：测试依赖的范围</h1><h2 id="1、依赖范围"><a href="#1、依赖范围" class="headerlink" title="1、依赖范围"></a>1、依赖范围</h2><p>标签的位置：dependencies/dependency/<strong>scope</strong></p><p>标签的可选值：<strong>compile</strong>/<strong>test</strong>/<strong>provided</strong>/system/runtime/<strong>import</strong></p><h3 id="①compile-和-test-对比"><a href="#①compile-和-test-对比" class="headerlink" title="①compile 和 test 对比"></a>①compile 和 test 对比</h3><table><thead><tr><th></th><th>main目录（空间）</th><th>test目录（空间）</th><th>开发过程（时间）</th><th>部署到服务器（时间）</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><h3 id="②compile-和-provided-对比"><a href="#②compile-和-provided-对比" class="headerlink" title="②compile 和 provided 对比"></a>②compile 和 provided 对比</h3><table><thead><tr><th></th><th>main目录（空间）</th><th>test目录（空间）</th><th>开发过程（时间）</th><th>部署到服务器（时间）</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><h3 id="③结论"><a href="#③结论" class="headerlink" title="③结论"></a>③结论</h3><p>compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</p><h2 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h2><h3 id="①验证-compile-范围对-main-目录有效"><a href="#①验证-compile-范围对-main-目录有效" class="headerlink" title="①验证 compile 范围对 main 目录有效"></a>①验证 compile 范围对 main 目录有效</h3><p>:::TIP</p><p>main目录下的类：HelloServlet 使用compile范围导入的依赖：pro01-atguigu-maven</p><p>验证：使用compile范围导入的依赖对main目录下的类来说是有效的</p><p>有效：HelloServlet 能够使用 pro01-atguigu-maven 工程中的 Calculator 类</p><p>验证方式：在 HelloServlet 类中导入 Calculator 类，然后编译就说明有效。</p><p>:::</p><h3 id="②验证test范围对main目录无效"><a href="#②验证test范围对main目录无效" class="headerlink" title="②验证test范围对main目录无效"></a>②验证test范围对main目录无效</h3><p>测试方式：在主体程序中导入org.junit.Test这个注解，然后执行编译。</p><p>具体操作：在pro01-maven-java\src\main\java\com\atguigu\maven目录下修改Calculator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Maven编译命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] /D:/maven-workspace/space201026/pro01-maven-java/src/main/java/com/atguigu/maven/Calculator.java:[<span class="number">3</span>,<span class="number">17</span>] 程序包org.junit不存在</span><br></pre></td></tr></table></figure><h3 id="③验证test和provided范围不参与服务器部署"><a href="#③验证test和provided范围不参与服务器部署" class="headerlink" title="③验证test和provided范围不参与服务器部署"></a>③验证test和provided范围不参与服务器部署</h3><p>其实就是验证：通过compile范围依赖的jar包会放入war包，通过test范围依赖的jar包不会放入war包。</p><p><img src="https://image.3001.net/images/20220926/16641627486424.png" alt="1"></p><h3 id="④验证provided范围对测试程序有效"><a href="#④验证provided范围对测试程序有效" class="headerlink" title="④验证provided范围对测试程序有效"></a>④验证provided范围对测试程序有效</h3><p>测试方式是在pro02-maven-web的测试程序中加入servlet-api.jar包中的类。</p><p>修改：<strong>pro02-maven-web</strong>\src*<em>test**\java\com\atguigu\maven*<em>CalculatorTest.java</em></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.maven.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入的效果是将Assert类中的静态资源导入当前类</span></span><br><span class="line"><span class="comment">// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Calculator对象</span></span><br><span class="line">Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用Calculator对象的方法，获取到程序运行实际的结果</span></span><br><span class="line"><span class="keyword">int</span> actualResult = calculator.sum(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明一个变量，表示程序运行期待的结果</span></span><br><span class="line"><span class="keyword">int</span> expectedResult = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用断言来判断实际结果和期待结果是否一致</span></span><br><span class="line"><span class="comment">// 如果一致：测试通过，不会抛出异常</span></span><br><span class="line"><span class="comment">// 如果不一致：抛出异常，测试失败</span></span><br><span class="line">assertEquals(expectedResult, actualResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行Maven的编译命令：mvn compile</p><p>然后看到编译成功。</p><h1 id="实验七：测试依赖的传递性"><a href="#实验七：测试依赖的传递性" class="headerlink" title="实验七：测试依赖的传递性"></a>实验七：测试依赖的传递性</h1><h2 id="1、依赖的传递性"><a href="#1、依赖的传递性" class="headerlink" title="1、依赖的传递性"></a>1、依赖的传递性</h2><h3 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h3><p>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</p><h3 id="②传递的原则"><a href="#②传递的原则" class="headerlink" title="②传递的原则"></a>②传递的原则</h3><p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p><ul><li>B 依赖 C 时使用 compile 范围：可以传递</li><li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li></ul><h2 id="2、使用-compile-范围依赖-spring-core"><a href="#2、使用-compile-范围依赖-spring-core" class="headerlink" title="2、使用 compile 范围依赖 spring-core"></a>2、使用 compile 范围依赖 spring-core</h2><p>测试方式：让 pro01-maven-java 工程依赖 spring-core</p><p>具体操作：编辑 pro01-maven-java 工程根目录下 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 mvn dependency:tree 命令查看效果：</p><p>:::TIP</p><p>[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT<br>[INFO] +- junit:junit:jar:4.12:test<br>[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile<br>[INFO] - commons-logging:commons-logging:jar:1.1.1:compile</p><p>:::</p><p>还可以在 Web 工程中，使用 mvn dependency:tree 命令查看效果（需要重新将 pro01-maven-java 安装到仓库）：</p><p>:::TIP</p><p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>[INFO] +- junit:junit:jar:4.12:test<br>[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile<br>[INFO] - commons-logging:commons-logging:jar:1.1.1:compile</p><p>:::</p><h2 id="3、验证-test-和-provided-范围不能传递"><a href="#3、验证-test-和-provided-范围不能传递" class="headerlink" title="3、验证 test 和 provided 范围不能传递"></a>3、验证 test 和 provided 范围不能传递</h2><p>从上面的例子已经能够看到，pro01-maven-java 依赖了 junit，但是在 pro02-maven-web 工程中查看依赖树的时候并没有看到 junit。</p><p>要验证 provided 范围不能传递，可以在 pro01-maven-java 工程中加入 servlet-api 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果还是和之前一样：</p><p>:::TIP</p><p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>[INFO] +- junit:junit:jar:4.12:test<br>[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile<br>[INFO] - commons-logging:commons-logging:jar:1.1.1:compile</p><p>:::</p><h1 id="第八节-实验八：测试依赖的排除"><a href="#第八节-实验八：测试依赖的排除" class="headerlink" title="第八节 实验八：测试依赖的排除"></a>第八节 实验八：测试依赖的排除</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。</p><p><img src="https://image.3001.net/images/20220926/16641632919058.png" alt="1"></p><p>所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p><h2 id="2、配置方式"><a href="#2、配置方式" class="headerlink" title="2、配置方式"></a>2、配置方式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><p>测试的方式：在 pro02-maven-web 工程中配置对 commons-logging 的排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行 mvn dependency:tree 命令查看效果：</p><p>:::TIP</p><p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>[INFO] +- junit:junit:jar:4.12:test<br>[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile</p><p>:::</p><p>发现在 spring-core 下面就没有 commons-logging 了。</p><h1 id="第九节-实验九：继承"><a href="#第九节-实验九：继承" class="headerlink" title="第九节 实验九：继承"></a>第九节 实验九：继承</h1><h2 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h2><p>Maven工程之间，A 工程继承 B 工程</p><ul><li>B 工程：父工程</li><li>A 工程：子工程</li></ul><p>本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。</p><h2 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h2><p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p><p>它的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个 project 下面，创建了很多个 module。</li><li>每一个 module 都需要配置自己的依赖信息。</li></ul><p>它背后的需求是：</p><ul><li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li><li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li><li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</li></ul><p>通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力。</p><h2 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h2><p>在一个工程中依赖多个 Spring 的 jar 包</p><p>:::TIP</p><p>[INFO] +- org.springframework:<strong>spring-core</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>[INFO] | - commons-logging:commons-logging:jar:1.1.1:compile<br>[INFO] +- org.springframework:<strong>spring-beans</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>[INFO] +- org.springframework:<strong>spring-context</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>[INFO] +- org.springframework:<strong>spring-expression</strong>:jar:4.0.0.RELEASE:compile<br>[INFO] +- org.springframework:<strong>spring-aop</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>[INFO] | - aopalliance:aopalliance:jar:1.0:compile</p><p>:::</p><p>使用 Spring 时要求所有 Spring 自己的 jar 包版本必须一致。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。</p><h2 id="4、操作"><a href="#4、操作" class="headerlink" title="4、操作"></a>4、操作</h2><h3 id="①创建父工程"><a href="#①创建父工程" class="headerlink" title="①创建父工程"></a>①创建父工程</h3><p>创建的过程和前面创建 pro01-maven-java 一样。</p><p>工程名称：pro03-maven-parent</p><p>工程创建好之后，要修改它的打包方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</p><h3 id="②创建模块工程"><a href="#②创建模块工程" class="headerlink" title="②创建模块工程"></a>②创建模块工程</h3><p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入 pro03-maven-parent 工程的根目录</strong>，然后运行 mvn archetype:generate 命令来创建模块工程。</p><p>假设，我们创建三个模块工程：</p><p><img src="https://image.3001.net/images/20220926/16641634582883.png" alt="1"></p><h3 id="③查看被添加新内容的父工程-pom-xml"><a href="#③查看被添加新内容的父工程-pom-xml" class="headerlink" title="③查看被添加新内容的父工程 pom.xml"></a>③查看被添加新内容的父工程 pom.xml</h3><p>下面 modules 和 module 标签是聚合功能的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="④解读子工程的pom-xml"><a href="#④解读子工程的pom-xml" class="headerlink" title="④解读子工程的pom.xml"></a>④解读子工程的pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="⑤在父工程中配置依赖的统一管理"><a href="#⑤在父工程中配置依赖的统一管理" class="headerlink" title="⑤在父工程中配置依赖的统一管理"></a>⑤在父工程中配置依赖的统一管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="⑥子工程中引用那些被父工程管理的依赖"><a href="#⑥子工程中引用那些被父工程管理的依赖" class="headerlink" title="⑥子工程中引用那些被父工程管理的依赖"></a>⑥子工程中引用那些被父工程管理的依赖</h3><p>关键点：省略版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="⑦在父工程中升级依赖信息的版本"><a href="#⑦在父工程中升级依赖信息的版本" class="headerlink" title="⑦在父工程中升级依赖信息的版本"></a>⑦在父工程中升级依赖信息的版本</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>然后在子工程中运行mvn dependency:list，效果如下：</p><p>:::TIP</p><p>[INFO] org.springframework:spring-aop:jar:4.1.4.RELEASE:compile<br>[INFO] org.springframework:spring-core:jar:4.1.4.RELEASE:compile<br>[INFO] org.springframework:spring-context:jar:4.1.4.RELEASE:compile<br>[INFO] org.springframework:spring-beans:jar:4.1.4.RELEASE:compile<br>[INFO] org.springframework:spring-expression:jar:4.1.4.RELEASE:compile</p><p>:::</p><h3 id="⑧在父工程中声明自定义属性"><a href="#⑧在父工程中声明自定义属性" class="headerlink" title="⑧在父工程中声明自定义属性"></a>⑧在父工程中声明自定义属性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的地方使用${}的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>真正实现“一处修改，处处生效”。</p><h2 id="5、实际意义"><a href="#5、实际意义" class="headerlink" title="#5、实际意义"></a><a href="http://localhost:63342/code_heavy_industry/pro002-maven/chapter03/verse09.html#_5%E3%80%81%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89">#</a>5、实际意义</h2><p><img src="https://image.3001.net/images/20220926/16641633701327.png" alt="1"></p><p>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以使用工程继承的机制，让成熟的依赖组合方案能够保留下来。</p><p>如上图所示，公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可。</p><h1 id="实验十：聚合"><a href="#实验十：聚合" class="headerlink" title="实验十：聚合"></a>实验十：聚合</h1><h2 id="1、聚合本身的含义"><a href="#1、聚合本身的含义" class="headerlink" title="#1、聚合本身的含义"></a><a href="http://localhost:63342/code_heavy_industry/pro002-maven/chapter03/verse10.html#_1%E3%80%81%E8%81%9A%E5%90%88%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%90%AB%E4%B9%89">#</a>1、聚合本身的含义</h2><p>部分组成整体</p><p><img src="https://image.3001.net/images/20220926/1664163622182.png" alt="1"></p><p>动画片《战神金刚》中的经典台词：“我来组成头部！我来组成手臂！”就是聚合关系最生动的体现。</p><h2 id="2、Maven-中的聚合"><a href="#2、Maven-中的聚合" class="headerlink" title="2、Maven 中的聚合"></a>2、Maven 中的聚合</h2><p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p><ul><li>项目：整体</li><li>模块：部分</li></ul><p>:::TIP</p><p>概念的对应关系：</p><p>从继承关系角度来看：</p><ul><li>父工程</li><li>子工程</li></ul><p>从聚合关系角度来看：</p><ul><li>总工程</li><li>模块工程</li></ul><p>:::</p><h2 id="3、好处"><a href="#3、好处" class="headerlink" title="3、好处"></a>3、好处</h2><ul><li><p>一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。</p><p>以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。</p></li><li><p>配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然。</p></li></ul><h2 id="4、聚合的配置"><a href="#4、聚合的配置" class="headerlink" title="4、聚合的配置"></a>4、聚合的配置</h2><p>在总工程中配置 modules 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5、依赖循环问题"><a href="#5、依赖循环问题" class="headerlink" title="5、依赖循环问题"></a>5、依赖循环问题</h2><p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：</p><p>:::DANGER</p><p>[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:</p><p>:::</p><p>这个错误的含义是：循环引用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;第一节-实验一：根据坐标创建-Maven-工程&quot;&gt;&lt;a href=&quot;#第一节-实验一：根据坐标创建-Maven-工程&quot; class=&quot;headerlink&quot; title=&quot;第一节 实验一：根据坐标创建 Maven 工程&quot;&gt;&lt;/a&gt;第一节 实验一：根据坐标创建 Maven 工程&lt;/h1&gt;&lt;h2 id=&quot;1、Maven-核心概念：坐标&quot;&gt;&lt;a href=&quot;#1、Maven-核心概念：坐标&quot; class=&quot;headerlink&quot; title=&quot;1、Maven 核心概念：坐标&quot;&gt;&lt;/a&gt;1、Maven 核心概念：坐标&lt;/h2&gt;&lt;h3 id=&quot;①数学中的坐标&quot;&gt;&lt;a href=&quot;#①数学中的坐标&quot; class=&quot;headerlink&quot; title=&quot;①数学中的坐标&quot;&gt;&lt;/a&gt;①数学中的坐标&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20220926/16641606046087.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 x、y、z 三个&lt;strong&gt;『向量』&lt;/strong&gt;作为空间的坐标系，可以在&lt;strong&gt;『空间』&lt;/strong&gt;中唯一的定位到一个&lt;strong&gt;『点』&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="maven" scheme="https://yangmour.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="https://yangmour.github.io/2022/09/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/jdbc/JDBC/"/>
    <id>https://yangmour.github.io/2022/09/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/jdbc/JDBC/</id>
    <published>2022-09-18T05:06:17.000Z</published>
    <updated>2022-09-17T06:52:44.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><p>[TOC]</p><hr><h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul><li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p></li><li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p><p><img src="https://image.3001.net/images/20220905/16623565283254.png" alt="1566741430592"> </p></li></ul><span id="more"></span><h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul><li><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p>JDO (Java Data Object )技术</p></li><li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p></li></ul></li><li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p></li></ul><h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul><li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li></ul><p><img src="https://image.3001.net/images/20220905/1662356539320.png" alt="1555575760234"></p><hr><ul><li>有了JDBC，Java程序访问数据库时是这样的：</li></ul><p><img src="https://image.3001.net/images/20220905/16623565325781.png" alt="1555575981203"></p><hr><ul><li>总结如下：</li></ul><p><img src="https://image.3001.net/images/20220905/16623565381650.png" alt="1566741692804"></p><h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul><li>JDBC接口（API）包括两个层次：<ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul></li></ul><blockquote><p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p><p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p></blockquote><h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="https://image.3001.net/images/20220905/16623565354674.png" alt="1565969323908"></p><blockquote><p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul><li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li><li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li></ul></li></ul><p><img src="https://image.3001.net/images/20220905/16623565436628.png" alt="1555576157618"></p><p><img src="https://image.3001.net/images/20220905/16623565375776.png" alt="1555576170074"></p><ul><li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li></ul><p> <img src="https://image.3001.net/images/20220905/16623565279864.png" alt="1566134718955"></p><p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p><p> <img src="https://image.3001.net/images/20220905/16623565367762.png" alt="1566134781682"></p><p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p> <img src="https://image.3001.net/images/20220905/16623565341091.png" alt="1566135290460"></p><h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li></ul></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p><ul><li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p><p><img src="https://image.3001.net/images/20220905/16623565459645.png" alt="1566136831283"></p></li></ul></li></ul><h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul><li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p></li><li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p><ul><li><strong>jdbc:子协议:子名称</strong></li><li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li><li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li><li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li></ul></li><li><p>举例：</p><p><img src="https://image.3001.net/images/20220905/16623565333959.png" alt="1555576477107"></p></li><li><p><strong>几种常用数据库的 JDBC URL</strong></p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/atguigu</li><li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li><li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p></li><li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p></li></ul></li></ul></li></ul><h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul><li>user,password可以用“属性名=属性值”方式告诉数据库</li><li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li></ul><h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API</p></blockquote><h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p></blockquote><h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p><p><strong>使用配置文件的好处：</strong></p><p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p></blockquote><h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul><li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p></li><li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul><p><img src="https://image.3001.net/images/20220905/16623565327897.png" alt="1566573842140"></p></li></ul><h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul><li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p></li><li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure></li><li><p>但是使用Statement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul></li><li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p></li><li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p></li><li><p>代码演示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">String userName = scan.nextLine();</span><br><span class="line">System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">User user = get(sql, User.class);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line">String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上：</p><p><img src="https://image.3001.net/images/20220905/16623565407336.png" alt="1566569819744"></p><h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul><li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p></li><li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p></li><li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p></li></ul><h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul><li><p>代码的可读性和可维护性。</p></li><li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p><ul><li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li></ul></li><li><p>PreparedStatement 可以防止 SQL 注入 </p></li></ul><h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte   array</td><td>BINARY  ,    VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Object ... args)</span></span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取数据库的连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">T t = clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line">Object columnVal = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p></blockquote><h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul><li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p></li><li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p></li><li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p></li><li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p><ul><li>例如: getInt(1), getString(“name”)</li><li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li></ul></li><li><p>ResultSet 接口的常用方法：</p><ul><li><p>boolean next()</p></li><li><p>getString()</p></li><li><p>…</p></li></ul><p><img src="https://image.3001.net/images/20220905/16623565449040.png" alt="1555580152530"></p></li></ul><h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul><li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p></li><li><p>ResultSetMetaData meta = rs.getMetaData();</p><ul><li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p></li><li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p></li><li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p></li><li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p></li><li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p></li><li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p></li><li><p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p></li></ul></li></ul><p><img src="https://image.3001.net/images/20220905/16623565368126.png" alt="1555579494691"></p><p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p><p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p><p><strong>问题2：关于ResultSetMetaData</strong></p><ol><li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li><li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li><li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li></ol><p><img src="https://image.3001.net/images/20220905/1662356531419.png" alt="1555579816884"></p><h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul><li>释放ResultSet, Statement,Connection。</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li><li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul><li><p>两种思想</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想(object relational mapping)</p><ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。</p></blockquote></li><li><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li></ul><hr><h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p><p><img src="https://image.3001.net/images/20220905/16623565381837.png" alt="1555580275036"></p><p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p><p><img src="https://image.3001.net/images/20220905/16623565403789.png" alt="1555580735377"></p><p>向数据表中添加如下数据：</p><p><img src="https://image.3001.net/images/20220905/16623565413146.png" alt="1555580763636"></p><p><strong>代码实现1：插入一个新的student 信息</strong></p><p>请输入考生的详细信息</p><p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p><p>信息录入成功!</p><p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p><p><img src="https://image.3001.net/images/20220905/16623565399080.png" alt="1555580937490"></p><p><strong>代码实现3：完成学生信息的删除功能</strong></p><p><img src="https://image.3001.net/images/20220905/16623565438301.png" alt="1555580965019"></p><hr><h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li></ul><p><img src="https://image.3001.net/images/20220905/16623565294482.png" alt="1555581069798"></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">InputStream is = photo.getBinaryStream();</span><br><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(os !=  <span class="keyword">null</span>)&#123;</span><br><span class="line">os.close();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li><li><strong>executeBatch()：执行批量处理语句；</strong></li><li><strong>clearBatch():清空缓存的数据</strong></li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p><ul><li>数据库中提供一个goods表。创建如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure><h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> *  ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p></li><li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p></li><li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p></li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p><ul><li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li><li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><p>【案例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line">String sql1 = <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">String sql2 = <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> </span>&#123;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol><li><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（Isolation）</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ol><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul><li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li><li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li></ul></li><li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p></li><li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p></li></ul><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul><li><p>数据库提供的4种事务隔离级别：</p><p><img src="https://image.3001.net/images/20220905/16623565356187.png" alt="1555586275271"></p></li><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li></ul><ul><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure></li><li><p>设置当前 mySQL 连接的隔离级别:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>设置数据库系统的全局的隔离级别:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@&#x27;%&#x27;  identified by &#x27;abc123&#x27;; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul><li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li><li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li><li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li></ul><p><img src="https://image.3001.net/images/20220905/16623565301845.png" alt="1566726681515"></p><ul><li>层次结构：</li></ul><p><img src="https://image.3001.net/images/20220905/16623565313095.png" alt="1566745811244"></p><h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"><span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取子类的类型</span></span><br><span class="line">Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line"><span class="comment">// 获取父类的类型</span></span><br><span class="line"><span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line"><span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line"><span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line"><span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line"><span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line"><span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的增删改操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">count = queryRunner.update(conn, sql, params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">Object count = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">beanList = getBeanList(conn,sql);</span><br><span class="line"><span class="keyword">return</span> beanList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">update(conn,sql, bookId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">Book book = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">book = getBean(conn,sql, bookId);</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">String sql = <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">String sql = <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">User bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">User bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername());</span><br><span class="line"><span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">//写sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line"><span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line"><span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line"><span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line"><span class="keyword">private</span> String imgPath = <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line"><span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul><li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p><ul><li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li><li><strong>进行sql操作</strong></li><li><strong>断开数据库连接</strong></li></ul></li><li><p>这种模式开发，存在的问题:</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li><li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p></li><li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p></li><li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p></li><li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p></li></ul><p><img src="https://image.3001.net/images/20220905/16623565273973.png" alt="1555593464033"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="https://image.3001.net/images/20220905/16623565347513.png" alt="1555593598606"></p><ul><li><p><strong>数据库连接池技术的优点</strong></p><p><strong>1. 资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p><p><strong>2. 更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><p><strong>3. 新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p><p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li><li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul><li>获取连接方式一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpds.setMaxPoolSize(100);</span></span><br><span class="line"></span><br><span class="line">Connection conn = cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取连接方式二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">Connection conn = cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li>获取连接方式一：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line"></span><br><span class="line">source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">source.setInitialSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Connection conn = source.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取连接方式二：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Connection conn = source.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【dbcp.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure><h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th><strong>配置</strong></th><th><strong>缺省</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul><li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p></li><li><p>API介绍：</p><ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils   </li></ul></li><li><p>API包说明：</p></li></ul><p><img src="https://image.3001.net/images/20220905/16623565421879.png" alt="1555595163263"></p><p><img src="https://image.3001.net/images/20220905/16623565261892.png" alt="1555595198644"></p><h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul><li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul><li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p></li><li><p>QueryRunner类提供了两个构造器：</p><ul><li>默认的构造器</li><li>需要一个 javax.sql.DataSource 来作参数的构造器</li></ul></li><li><p>QueryRunner类的主要方法：</p><ul><li><strong>更新</strong><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul></li><li><strong>插入</strong><ul><li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</li><li>….</li></ul></li><li><strong>批处理</strong><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li><li>…..</li></ul></li><li><strong>查询</strong><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>…… </li></ul></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">String sql = <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">&quot;何成飞&quot;</span>, <span class="string">&quot;he@qq.com&quot;</span>, <span class="string">&quot;1992-09-08&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">String sql = <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul><li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p></li><li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p></li><li><p>接口的主要实现类：</p><ul><li><p>ArrayHandler：把结果集中的第一行数据转成对象数组。</p></li><li><p>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</p></li><li><p><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</p></li><li><p><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</p></li><li><p>ColumnListHandler：将结果集中某一列的数据存放到List中。</p></li><li><p>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</p></li><li><p><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</p></li><li><p><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</p></li><li><p><strong>ScalarHandler：</strong>查询单个值对象</p></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer.class);</span><br><span class="line">Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">System.out.println(customer);</span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer.class);</span><br><span class="line">List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"><span class="comment">//return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line"><span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">String email = rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">Date birth = rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(customer);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line"><span class="comment">//ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//System.out.println(count);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试二：</span></span><br><span class="line">String sql = <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">System.out.println(birth);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.获取连接的操作（</span></span><br><span class="line"><span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line"><span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line"><span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line"><span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//回滚数据</span></span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//3.关闭连接等操作</span></span><br><span class="line"><span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDBC核心技术&quot;&gt;&lt;a href=&quot;#JDBC核心技术&quot; class=&quot;headerlink&quot; title=&quot;JDBC核心技术&quot;&gt;&lt;/a&gt;JDBC核心技术&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第1章：JDBC概述&quot;&gt;&lt;a href=&quot;#第1章：JDBC概述&quot; class=&quot;headerlink&quot; title=&quot;第1章：JDBC概述&quot;&gt;&lt;/a&gt;第1章：JDBC概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-数据的持久化&quot;&gt;&lt;a href=&quot;#1-1-数据的持久化&quot; class=&quot;headerlink&quot; title=&quot;1.1 数据的持久化&quot;&gt;&lt;/a&gt;1.1 数据的持久化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;持久化(persistence)：&lt;strong&gt;把数据保存到可掉电式存储设备中以供之后使用&lt;/strong&gt;。大多数情况下，特别是企业级应用，&lt;strong&gt;数据持久化意味着将内存中的数据保存到硬盘&lt;/strong&gt;上加以”固化”&lt;strong&gt;，而持久化的实现过程大多通过各种关系数据库来完成&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20220905/16623565283254.png&quot; alt=&quot;1566741430592&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="数据库连接" scheme="https://yangmour.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yangmour.github.io/2022/09/08/hello-world/"/>
    <id>https://yangmour.github.io/2022/09/08/hello-world/</id>
    <published>2022-09-08T02:17:05.193Z</published>
    <updated>2022-09-08T02:17:05.193Z</updated>
    
    <content type="html"><![CDATA[<p>测试文档</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;测试文档&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://yangmour.github.io/2022/08/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/docker/docker/"/>
    <id>https://yangmour.github.io/2022/08/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/docker/docker/</id>
    <published>2022-08-25T01:06:17.000Z</published>
    <updated>2022-09-08T02:17:05.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker与微服务实战"><a href="#Docker与微服务实战" class="headerlink" title="Docker与微服务实战"></a>Docker与微服务实战</h1><p>[TOC]</p><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://image.3001.net/images/20220823/16612291781365.jpg" alt="img"></td></tr></tbody></table><span id="more"></span><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://image.3001.net/images/20220823/16612292872202.jpg" alt="img"></td></tr></tbody></table><p>\1.   基础篇(零基小白)………………………………. 1</p><p>1.1.   Docker简介………………………………… 2</p><p>1.2.   Docker安装………………………………. 15</p><p>1.3.   Docker常用命令…………………………. 29</p><p>1.4.   Docker镜像………………………………. 43</p><p>1.5.   本地镜像发布到阿里云…………………. 50</p><p>1.6.   本地镜像发布到私有库…………………. 57</p><p>1.7.   Docker容器数据卷……………………… 64</p><p>1.8.   Docker常规安装简介…………………… 70</p><p>\2.   高级篇(大厂进阶)……………………………. 115</p><p>2.1.   Docker复杂安装详说…………………. 115</p><p>2.2.   DockerFile解析…………………………. 149</p><p>2.3.   Docker微服务实战…………………….. 162</p><p>2.4.   Docker网络…………………………….. 169</p><p>2.5.   Docker-compose容器编排…………… 186</p><p>2.6.   Docker轻量级可视化工具Portainer.. 225</p><p>2.7.   Docker容器监控之 CAdvisor+InfluxDB+Granfana………………. 228</p><p>2.8.   终章の总结……………………………… 238</p><h2 id="1-基础篇-零基小白"><a href="#1-基础篇-零基小白" class="headerlink" title="1.      基础篇(零基小白)"></a>1.      基础篇(零基小白)</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://image.3001.net/images/20220823/16612292913373.jpg" alt="img"></td></tr></tbody></table><h3 id="1-1-Docker简介"><a href="#1-1-Docker简介" class="headerlink" title="1.1.       Docker简介"></a>1.1.       Docker简介</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://image.3001.net/images/20220823/16612292941119.jpg" alt="img"></td></tr></tbody></table><h4 id="1-1-1-前提知识-课程定位-开场闲聊"><a href="#1-1-1-前提知识-课程定位-开场闲聊" class="headerlink" title="1.1.1.       前提知识+课程定位+开场闲聊"></a>1.1.1.       前提知识+课程定位+开场闲聊</h4><h4 id="1-1-2-是什么"><a href="#1-1-2-是什么" class="headerlink" title="1.1.2.       是什么"></a>1.1.2.       <strong>是什么</strong></h4><p>·     问题：为什么会有docker出现</p><p>假定您在开发一个尚硅谷的谷粒商城，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境的开销。请问？</p><p>您要如何确保应用能够在这些环境中运行和通过质量检测？并且在部署过程中不出现令人头疼的版本、配置问题，也无需重新编写代码和进行故障修复？</p><p>答案就是使用容器。Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案—–系统平滑移植，容器虚拟化技术。</p><p>环境配置相当麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</p><p> <img src="https://image.3001.net/images/20220823/16612292965123.jpg" alt="graphic"></p><p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说，Java/RabbitMQ/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要<strong>移植</strong>应用也是非常麻烦的。</p><p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker的出现使得Docker得以打破过去「程序即应用」的观念。透过镜像(./images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</p><p>·     docker理念</p><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。</p><p><img src="https://image.3001.net/images/20220823/16612292993595.jpg" alt="graphic"></p><p>Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p>·     一句话</p><p>·     解决了运行环境和配置问题的软件容器， 方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h4 id="1-1-3-容器与虚拟机比较"><a href="#1-1-3-容器与虚拟机比较" class="headerlink" title="1.1.3.       容器与虚拟机比较"></a>1.1.3.       <strong>容器与虚拟机比较</strong></h4><p>·     容器发展简史</p><p><img src="https://image.3001.net/images/20220823/16612293016450.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612293043802.jpg" alt="graphic"></p><p>·     传统虚拟机技术</p><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p><p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 </p><table><thead><tr><th>Win10</th><th>VMWare</th><th>Centos7</th><th>各种cpu、内存网络额配置+各种软件</th><th>虚拟机实例</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p> <img src="https://image.3001.net/images/20220823/16612293094102.gif" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/1661229311733.gif" alt="graphic"></p><p>虚拟机的缺点：</p><p>1   资源占用多        2   冗余步骤多         3   启动慢</p><p>·     容器虚拟化技术</p><p>由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：</p><p>Linux容器(Linux Containers，缩写为 LXC)</p><p>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p><p> <img src="https://image.3001.net/images/20220823/16612293145536.gif" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612298038388.gif" alt="graphic"></p><p>·     对比</p><table><thead><tr><th>关系</th><th>对比 - 指向 <a href="#DsC1I8EsDk+9cwDs84NUPw==">底层原理</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p> <img src="https://image.3001.net/images/20220823/16612293184149.jpg" alt="graphic"></p><p>比较了 Docker 和传统虚拟化方式的不同之处：</p><p>*传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p>*容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p>* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h4 id="1-1-4-能干嘛"><a href="#1-1-4-能干嘛" class="headerlink" title="1.1.4.       能干嘛"></a><strong>1.1.4.</strong>       <strong>能干嘛</strong></h4><p>·     技术职级变化</p><p>·     coder</p><p>·     programmer</p><p>·     software engineer</p><p>·     DevOps engineer</p><p>·     开发/运维（DevOps）新一代开发工程师</p><p>·     一次构建、随处运行</p><p>·     更快速的应用交付和部署</p><p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p><p>·     更便捷的升级和扩缩容</p><p>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p><p>·     更简单的系统运维</p><p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p><p>·     更高效的计算资源利用</p><p>　Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p><p>·     · Docker应用场景</p><p><img src="https://image.3001.net/images/20220823/16612293227773.jpg" alt="graphic"></p><p>·     哪些企业在使用</p><p>·     新浪</p><p><img src="https://image.3001.net/images/20220823/16612293259209.jpg" alt="graphic"><img src="https://image.3001.net/images/20220823/16612293272836.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/166122932955.jpg" alt="graphic"><img src="https://image.3001.net/images/20220823/16612293319893.jpg" alt="graphic"></p><p>·     美团</p><p><img src="https://image.3001.net/images/20220823/16612293341238.jpg" alt="graphic"><img src="https://image.3001.net/images/20220823/16612293362254.jpg" alt="graphic"></p><p>·     蘑菇街</p><p><img src="https://image.3001.net/images/20220823/1661229338516.jpg" alt="graphic"><img src="https://image.3001.net/images/20220823/16612293411036.jpg" alt="graphic"></p><p>·     ……</p><h4 id="1-1-5-去哪下"><a href="#1-1-5-去哪下" class="headerlink" title="1.1.5.       去哪下"></a><strong>1.1.5.</strong>       <strong>去哪下</strong></h4><p>·     官网</p><p>·     docker官网：<a href="http://www.docker.com/">http://www.docker.com</a></p><p>·     仓库</p><p>·     Docker Hub官网: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h3 id="1-2-Docker安装"><a href="#1-2-Docker安装" class="headerlink" title="1.2.      Docker安装"></a>1.2.      Docker安装</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://image.3001.net/images/20220823/16612293437727.jpg" alt="img"></td></tr></tbody></table><h4 id="1-2-1-前提说明"><a href="#1-2-1-前提说明" class="headerlink" title="1.2.1.       前提说明"></a>1.2.1.       前提说明</h4><p><strong>CentOS Docker</strong> <strong>安装</strong></p><p><img src="https://image.3001.net/images/20220823/16612293469080.jpg" alt="graphic"></p><p><strong>前提条件</strong></p><p>目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在CentOS 7 (64-bit)上，</p><p>要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x</p><p><strong>查看自己的内核</strong></p><p>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p><p><img src="https://image.3001.net/images/20220823/16612293483897.jpg" alt="graphic"></p><h4 id="1-2-2-Docker的基本组成"><a href="#1-2-2-Docker的基本组成" class="headerlink" title="1.2.2.       Docker的基本组成"></a><strong>1.2.2.</strong>       <strong>Docker的基本组成</strong></h4><p>·     镜像(image)</p><p>Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</p><p>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。</p><p>相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。</p><p><img src="https://image.3001.net/images/20220823/16612293519486.gif" alt="graphic"></p><p>·     容器(container)</p><p>1 从面向对象角度</p><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</p><p>2 从镜像容器角度</p><p>*<strong>可以把容器看做是一个简易版的*</strong> *<strong>Linux*</strong> ***环境***（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>·     仓库(repository)</p><p>仓库（Repository）是集中存放镜像文件的场所。</p><p>类似于</p><p>Maven仓库，存放各种jar包的地方；</p><p>github仓库，存放各种git项目的地方；</p><p>Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)%EF%BC%8C">https://hub.docker.com/)，</a></p><p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</p><p>·     小总结</p><p>需要正确的理解仓库/镜像/容器这几个概念:</p><p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p><p>image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>镜像文件</p><p>*  image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p><p>容器实例</p><p>*  一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>仓库</p><p>* 就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。</p><h4 id="1-2-3-Docker平台架构图解-架构版"><a href="#1-2-3-Docker平台架构图解-架构版" class="headerlink" title="1.2.3.       Docker平台架构图解(架构版)"></a><strong>1.2.3.</strong>       <strong>Docker平台架构图解(架构版)</strong></h4><p>·     首次懵逼正常，后续深入，先有大概轮廓，混个眼熟</p><p>·     整体架构及底层通信原理简述</p><p>Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p><p><img src="https://image.3001.net/images/20220823/16612293543166.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612293605917.jpg" alt="graphic"></p><h4 id="1-2-4-安装步骤"><a href="#1-2-4-安装步骤" class="headerlink" title="1.2.4.       安装步骤"></a><strong>1.2.4.</strong>       <strong>安装步骤</strong></h4><p>·     CentOS7安装Docker</p><p>·     <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p>·     安装步骤</p><p>·     确定你是CentOS7及以上版本</p><p>·     cat /etc/redhat-release</p><p>·     卸载旧版本</p><p><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p> <img src="https://image.3001.net/images/20220823/16612293665933.jpg" alt="graphic"></p><p>·     yum安装gcc相关</p><p>·     CentOS7能上外网</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image060.jpg" alt="img"></td></tr></tbody></table><p>·     yum -y install gcc</p><p>·     yum -y install gcc-c++</p><p>·     安装需要的软件包</p><p>·     官网要求</p><p><img src="https://image.3001.net/images/20220823/16612293741804.jpg" alt="graphic"></p><p>·     执行命令</p><p>·     yum install -y yum-utils</p><p>·     设置stable镜像仓库</p><p>·     大坑</p><table><thead><tr><th>单图标</th><th><img src="https://image.3001.net/images/20220823/16612299473557.gif" alt="img"> CustomIcon-663735520; [“”, “4MyPJwAAAAAAAAAAAAAAAA==”]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     yum-config-manager –add-repo <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a></p><p><img src="https://image.3001.net/images/20220823/16612293815027.jpg" alt="graphic"> </p><p>报错：</p><p>1  [Errno 14] curl#35 - TCP connection reset by peer</p><p>2  [Errno 12] curl#35 - Timeout</p><p>·     官网要求</p><p><img src="https://image.3001.net/images/20220823/16612293851976.jpg" alt="graphic"> </p><p>报错：</p><p>1  [Errno 14] curl#35 - TCP connection reset by peer</p><p>2  [Errno 12] curl#35 - Timeout</p><p>·     推荐</p><table><thead><tr><th>单图标</th><th><img src="https://image.3001.net/images/20220823/16612320201175.gif" alt="img"> CustomIcon–1664269521; [“”,  “L0PNnAAAAAAAAAAAAAAAAA==”]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><p>·     我们自己</p><p><img src="https://image.3001.net/images/20220823/16612293893017.jpg" alt="graphic"></p><p>·     更新yum软件包索引</p><p>·     yum makecache fast</p><p>·     安装DOCKER CE</p><p>·     yum -y install docker-ce docker-ce-cli containerd.io</p><p>·     官网要求</p><p><img src="https://image.3001.net/images/20220823/16612293929743.jpg" alt="graphic"></p><p>·     执行结果</p><p><img src="https://image.3001.net/images/20220823/16612293953020.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612293971517.jpg" alt="graphic"></p><p>·     启动docker</p><p>·     systemctl start docker</p><p>·     测试</p><p>·     docker version</p><p>·     本次安装时间2021.11</p><p>本次安装时间2021.11</p><p><img src="https://image.3001.net/images/20220823/1661229399560.jpg" alt="graphic"></p><p>·     docker run hello-world</p><p><img src="https://image.3001.net/images/20220823/16612294045946.jpg" alt="graphic"></p><p>·     卸载</p><p><img src="https://image.3001.net/images/20220823/16612294072618.jpg" alt="graphic"></p><p>·     systemctl stop docker</p><p>·     yum remove docker-ce docker-ce-cli containerd.io</p><p>·     rm -rf /var/lib/docker</p><p>·     rm -rf /var/lib/containerd</p><h4 id="1-2-5-阿里云镜像加速"><a href="#1-2-5-阿里云镜像加速" class="headerlink" title="1.2.5.       阿里云镜像加速"></a><strong>1.2.5.</strong>       <strong>阿里云镜像加速</strong></h4><p>·     是什么</p><p>·     <a href="https://promotion.aliyun.com/ntms/act/kubernetes.html">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p><p>·     注册一个属于自己的阿里云账户(可复用淘宝账号)</p><p>·     获得加速器地址连接</p><p>·     登陆阿里云开发者平台</p><p><img src="https://image.3001.net/images/20220823/16612294116195.jpg" alt="graphic"></p><p>·     点击控制台</p><p><img src="https://image.3001.net/images/20220823/16612294133409.jpg" alt="graphic"></p><p>·     选择容器镜像服务</p><p><img src="https://image.3001.net/images/20220823/16612294154345.jpg" alt="graphic"></p><p>·     获取加速器地址</p><p><img src="https://image.3001.net/images/20220823/16612294293490.jpg" alt="graphic"></p><p>·     粘贴脚本直接执行</p><p>·     直接粘</p><table><thead><tr><th>mkdir -p /etc/docker</th></tr></thead><tbody><tr><td>tee /etc/docker/daemon.json  &lt;&lt;-‘EOF’  {   “registry-mirrors”: [“<a href="https://aa25jngu.mirror.aliyuncs.com&quot;]">https://aa25jngu.mirror.aliyuncs.com&quot;]</a>  }  EOF</td></tr></tbody></table><p><img src="https://image.3001.net/images/20220823/16612294325269.jpg" alt="graphic"></p><p>·     或者分步骤都行</p><p>·     mkdir -p /etc/docker</p><p>·     vim /etc/docker/daemon.json</p><p> #阿里云</p><p>{</p><p> “registry-mirrors”: [“https://｛自已的编码｝.mirror.aliyuncs.com”]</p><p>}</p><p>·     重启服务器</p><p>·     systemctl daemon-reload</p><p>·     systemctl restart docker</p><h4 id="1-2-6-永远的HelloWorld"><a href="#1-2-6-永远的HelloWorld" class="headerlink" title="1.2.6.       永远的HelloWorld"></a><strong>1.2.6.</strong>       <strong>永远的HelloWorld</strong></h4><p>·     启动Docker后台容器(测试运行 hello-world)</p><p>·     docker run hello-world</p><p><img src="https://image.3001.net/images/20220823/16612294361002.jpg" alt="graphic"></p><p>输出这段提示以后，hello world就会停止运行，容器自动终止。</p><p>·     run干了什么</p><p><img src="https://image.3001.net/images/20220823/16612294393837.jpg" alt="graphic"></p><h4 id="1-2-7-底层原理"><a href="#1-2-7-底层原理" class="headerlink" title="1.2.7.       底层原理"></a><strong>1.2.7.</strong>       <strong>底层原理</strong></h4><table><thead><tr><th>关系</th><th>对比 - 开始 <a href="#QcEpcVMaLU2pXBY2SvyWlA==">对比</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     为什么Docker会比VM虚拟机快</p><p>(1)docker有着比虚拟机更少的抽象层</p><p>  由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核</p><p>  当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p><p> <img src="https://image.3001.net/images/20220823/16612294431031.jpg" alt="graphic"></p><p> <img src="https://image.3001.net/images/20220823/16612294453826.gif" alt="graphic"></p><h3 id="1-3-Docker常用命令"><a href="#1-3-Docker常用命令" class="headerlink" title="1.3.      Docker常用命令"></a>1.3.      Docker常用命令</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image103.jpg" alt="img"></td></tr></tbody></table><h4 id="1-3-1-帮助启动类命令"><a href="#1-3-1-帮助启动类命令" class="headerlink" title="1.3.1.       帮助启动类命令"></a><strong>1.3.1.</strong>       <strong>帮助启动类命令</strong></h4><p>·     启动docker： systemctl start docker</p><p>·     停止docker： systemctl stop docker</p><p>·     重启docker： systemctl restart docker</p><p>·     查看docker状态： systemctl status docker</p><p>·     开机启动： systemctl enable docker</p><p>·     查看docker概要信息： docker info</p><p>·     查看docker总体帮助文档： docker –help</p><p>·     查看docker命令帮助文档： docker 具体命令 –help</p><h4 id="1-3-2-镜像命令"><a href="#1-3-2-镜像命令" class="headerlink" title="1.3.2.       镜像命令"></a><strong>1.3.2.</strong>       <strong>镜像命令</strong></h4><p>·     docker ./images</p><p>·     列出本地主机上的镜像</p><p><img src="https://image.3001.net/images/20220823/16612294494649.jpg" alt="graphic"></p><p>各个选项说明:</p><p>  REPOSITORY：表示镜像的仓库源  TAG：镜像的标签版本号  IMAGE ID：镜像ID  CREATED：镜像创建时间  SIZE：镜像大小  </p><p> 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</p><p>·     OPTIONS说明：</p><p>·     -a :列出本地所有的镜像（含历史映像层）</p><p>·     -q :只显示镜像ID。</p><p>·     docker search 某个XXX镜像名字</p><p>·     网站</p><p>·     <a href="https://hub.docker.com/">https://hub.docker.com</a></p><p>·     命令</p><p>·     docker search [OPTIONS] 镜像名字</p><p>·     案例</p><p><img src="https://image.3001.net/images/20220823/16612299788047.gif" alt="graphic"></p><p><img src="./images/clip_image109.jpg" alt="graphic"></p><p>·     OPTIONS说明：</p><p>·     –limit : 只列出N个镜像，默认25个</p><p>·     docker search –limit 5 redis</p><p>·     docker pull 某个XXX镜像名字</p><p>·     下载镜像</p><p>·     docker pull 镜像名字[:TAG]</p><p>·     docker pull 镜像名字</p><p>·     没有TAG就是最新版</p><p>·     等价于</p><p>·     docker pull 镜像名字:latest</p><p>·     docker pull ubuntu</p><p><img src="https://image.3001.net/images/20220823/16612320793368.jpg" alt="graphic"></p><p>·     docker system df 查看镜像/容器/数据卷所占的空间</p><p><img src="https://image.3001.net/images/20220823/16612320817761.jpg" alt="graphic"></p><p>·     docker rmi 某个XXX镜像名字ID</p><p>·     删除镜像</p><p>·     删除单个</p><p>·     docker rmi -f 镜像ID</p><p>·     删除多个</p><p>·     docker rmi -f 镜像名1:TAG 镜像名2:TAG</p><p>·     删除全部</p><p>·     docker rmi -f $(docker ./images -qa)</p><p>·     面试题：谈谈docker虚悬镜像是什么？</p><p>·     是什么</p><p>·     仓库名、标签都是<none>的镜像，俗称虚悬镜像dangling image</p><p>·     长什么样</p><p><img src="https://image.3001.net/images/20220823/1661232085789.gif" alt="graphic"></p><p>·     后续Dockerfile章节再介绍</p><p>·     思考</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image117.jpg" alt="img"></td></tr></tbody></table><p>·     结合我们Git的学习心得，大家猜猜是否会有 docker commit /docker push？？</p><h4 id="1-3-3-容器命令"><a href="#1-3-3-容器命令" class="headerlink" title="*1.3.3.*       *容器命令*"></a>*<strong>1.3.3.*</strong>       *<strong>容器命令*</strong></h4><p>·     <strong>有镜像才能创建容器， 这是根本前提(下载一个CentOS或者ubuntu镜像演示)</strong></p><p>·     说明</p><p><img src="https://image.3001.net/images/20220823/16612320892875.jpg" alt="graphic"></p><p>·     docker pull centos</p><p>·     docker pull ubuntu</p><p><img src="https://image.3001.net/images/20220823/1661232091553.jpg" alt="graphic"></p><p>·     本次演示用ubuntu演示</p><p>·     新建+启动容器</p><p>·     docker run [OPTIONS] <strong>IMAGE</strong> [COMMAND] [ARG…]</p><p>·     OPTIONS说明</p><p> OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p><p>–name=”容器新名字”    为容器指定一个名称；</p><p>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p><p>-i：以交互模式运行容器，通常与 -t 同时使用；</p><p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>也即启动交互式容器(前台有伪终端，等待交互)；</p><p>-P: 随机端口映射，大写P</p><p>-p: 指定端口映射，小写p</p><p><img src="https://image.3001.net/images/20220823/16612320936614.jpg" alt="graphic"></p><p>·     启动交互式容器(前台命令行)</p><table><thead><tr><th>关系</th><th>前后对比 - 开始 <a href="#QRvvQPSoeUSyQ50ciz6Q/g==">启动守护式容器(后台服务器)</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="https://image.3001.net/images/20220823/16612320951737.jpg" alt="graphic"></p><p>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p><p>docker run -it centos /bin/bash </p><p> <strong>docker运行报错</strong></p><p><strong>报错：</strong></p><ul><li>[root@localhost /]# <a href="https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020">docker</a> run -it ubuntu /bin/bash</li><li><em>WARNING: IPv4 forwarding is disabled. Networking will not work.</em></li></ul><p><img src="https://image.3001.net/images/20220825/16614065859806.png" alt="image-20220825134936405"></p><p>1.解决方式：</p><p>第一步：在宿主机上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">写入配置</span></span><br><span class="line">echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt;/usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">查看后添加的两条配置</span></span><br><span class="line">tail -2 /usr/lib/sysctl.d/00-system.conf </span><br><span class="line">net.bridge.bridge-nf-call-arptables = 0</span><br></pre></td></tr></table></figure><p>  <img src="images/image-20220825135325667.png" alt="image-20220825135325667"></p><p>2.第二步：重启network和docker服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure><p>3.第三步：验证是否成功</p><p><img src="images/fe9d3a924773707b13542350b4f77b2e.png" alt="img"></p><p>可见完美解决问题。</p><p>参数说明：  -i: 交互式操作。  -t: 终端。  centos : centos 镜像。  /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。  要退出终端，直接输入 exit:  </p><p>·     列出当前所有正在运行的容器</p><p>·     docker ps [OPTIONS]</p><p>·     OPTIONS说明</p><p>OPTIONS说明（常用）：</p><p>-a :列出当前所有正在运行的容器+历史上运行过的</p><p>-l :显示最近创建的容器。</p><p>-n：显示最近n个创建的容器。</p><p>-q :静默模式，只显示容器编号。</p><p>·     退出容器</p><table><thead><tr><th>关系</th><th align="left">指向 <a href="#vk3j/d/47E6/eS6lZsCBtw==">进入正在运行的容器并以命令行交互</a></th></tr></thead><tbody><tr><td></td><td align="left"></td></tr></tbody></table><p>·     两种退出方式</p><p>·     exit</p><p>·     run进去容器，exit退出，容器停止</p><p>·     ctrl+p+q</p><p>·     run进去容器，ctrl+p+q退出，容器不停止</p><p>·     启动已停止运行的容器</p><p>·     docker start 容器ID或者容器名</p><p>·     重启容器</p><p>·     docker restart 容器ID或者容器名</p><p>·     停止容器</p><p>·     docker stop 容器ID或者容器名</p><p>·     强制停止容器</p><p>·     docker kill 容器ID或容器名</p><p>·     删除已停止的容器</p><p>·     docker rm 容器ID</p><p>·     一次性删除多个容器实例</p><p>·     docker rm -f $(docker ps -a -q)</p><p>·     docker ps -a -q | xargs docker rm</p><p>·     <strong>重要</strong></p><p>·     <strong>有镜像才能创建容器，这是根本前提</strong><strong>(<strong><strong>下载一个Redis6.0.8镜像演示</strong></strong>)</strong></p><p>·     启动守护式容器(后台服务器)</p><table><thead><tr><th>关系</th><th>前后对比 - 指向 <a href="#suy8QK+FjE2usYWm/p04cg==">启动交互式容器(前台命令行)</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     在大部分的场景下，我们希望 docker 的服务是在后台运行的， 我们可以过 -d 指定容器的后台运行模式。</p><p>·     docker run -d 容器名</p><p>#使用镜像centos:latest以后台模式启动一个容器</p><p>docker run -d centos</p><p>问题：然后docker ps -a 进行查看, 会发现容器已经退出</p><p>很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.</p><p>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,</p><p>我们配置启动服务只需要启动响应的service即可。例如service nginx start</p><p>但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,</p><p>这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.</p><p>所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行，</p><p>常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~</p><p>·     redis 前后台启动演示case</p><p>·     前台交互式启动</p><p>·     docker run -it redis:6.0.8</p><p>·     后台守护式启动</p><p>·     docker run -d redis:6.0.8</p><p>·     查看容器日志</p><p>·     docker logs 容器ID</p><p>·     查看容器内运行的进程</p><p>·     docker top 容器ID</p><p>·     查看容器内部细节</p><p>·     docker inspect 容器ID</p><p>·     进入正在运行的容器并以命令行交互</p><table><thead><tr><th>关系</th><th>开始 <a href="#H51mnUNRmUykhMP+ErdHbA==">退出容器</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     docker exec -it 容器ID bashShell</p><p><img src="https://image.3001.net/images/20220823/16612321031811.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612321011106.jpg" alt="graphic"></p><p>·     重新进入docker attach 容器ID</p><p>·     案例演示，用centos或者unbuntu都可以</p><p>·     上述两个区别</p><p>·     attach 直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。</p><p><img src="https://image.3001.net/images/20220823/16612321053393.jpg" alt="graphic"></p><p>·     exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。</p><p><img src="https://image.3001.net/images/20220823/16612321079023.jpg" alt="graphic"></p><p>·     推荐大家使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。</p><p>·     用之前的redis容器实例进入试试</p><p>·     进入redis服务</p><p>·     docker exec -it 容器ID /bin/bash</p><p>·     docker exec -it 容器ID redis-cli</p><p>·     一般用-d后台启动的程序，再用exec进入对应容器实例</p><p>·     从容器内拷贝文件到主机上</p><p>·     容器→主机</p><p>·     docker cp 容器ID:容器内路径 目的主机路径</p><p><img src="https://image.3001.net/images/20220823/16612321108843.jpg" alt="graphic"></p><p>公式：docker cp  容器ID:容器内路径 目的主机路径</p><p>·     导入和导出容器</p><p>·     export 导出容器的内容留作为一个tar归档文件[对应import命令]</p><p>·     import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</p><p>·     案例</p><p>·     docker export 容器ID &gt; 文件名.tar</p><p><img src="https://image.3001.net/images/20220823/166123214719.jpg" alt="graphic"></p><p>·     cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</p><p><img src="https://image.3001.net/images/20220823/16612321528388.jpg" alt="graphic"></p><h4 id="1-3-4-小总结"><a href="#1-3-4-小总结" class="headerlink" title="1.3.4.       小总结"></a><strong>1.3.4.</strong>       <strong>小总结</strong></h4><p>·     常用命令</p><p>图片正下方还有命令</p><p><img src="https://image.3001.net/images/20220823/16612321567629.jpg" alt="graphic"></p><p>attach   Attach to a running container         # 当前 shell 下 attach 连接指定运行镜像</p><p>build   Build an image from a Dockerfile       # 通过 Dockerfile 定制镜像</p><p>commit   Create a new image from a container changes  # 提交当前容器为新的镜像</p><p>cp     Copy files/folders from the containers filesystem to the host path  #从容器中拷贝指定文件或者目录到宿主机中</p><p>create   Create a new container            # 创建一个新的容器，同 run，但不启动容器</p><p>diff    Inspect changes on a container’s filesystem  # 查看 docker 容器变化</p><p>events   Get real time events from the server      # 从 docker 服务获取容器实时事件</p><p>exec    Run a command in an existing container     # 在已存在的容器上运行命令</p><p>export   Stream the contents of a container as a tar archive  # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</p><p>history  Show the history of an image         # 展示一个镜像形成历史</p><p>./images   List ./images                  # 列出系统当前镜像</p><p>import   Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</p><p>info    Display system-wide information        # 显示系统相关信息</p><p>inspect  Return low-level information on a container  # 查看容器详细信息</p><p>kill    Kill a running container           # kill 指定 docker 容器</p><p>load    Load an image from a tar archive       # 从一个 tar 包中加载一个镜像[对应 save]</p><p>login   Register or Login to the docker registry server   # 注册或者登陆一个 docker 源服务器</p><p>logout   Log out from a Docker registry server      # 从当前 Docker registry 退出</p><p>logs    Fetch the logs of a container         # 输出当前容器日志信息</p><p>port    Lookup the public-facing port which is NAT-ed to PRIVATE_PORT   # 查看映射端口对应的容器内部源端口</p><p>pause   Pause all processes within a container     # 暂停容器</p><p>ps     List containers                # 列出容器列表</p><p>pull    Pull an image or a repository from the docker registry server  # 从docker镜像源服务器拉取指定镜像或者库镜像</p><p>push    Push an image or a repository to the docker registry server   # 推送指定镜像或者库镜像至docker源服务器</p><p>restart  Restart a running container          # 重启运行的容器</p><p>rm     Remove one or more containers         # 移除一个或者多个容器</p><p>rmi    Remove one or more ./images    # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</p><p>run    Run a command in a new container       # 创建一个新的容器并运行一个命令</p><p>save    Save an image to a tar archive        # 保存一个镜像为一个 tar 包[对应 load]</p><p>search   Search for an image on the Docker Hub     # 在 docker hub 中搜索镜像</p><p>start   Start a stopped containers          # 启动容器</p><p>stop    Stop a running containers           # 停止容器</p><p>tag    Tag an image into a repository        # 给源中镜像打标签</p><p>top    Lookup the running processes of a container  # 查看容器中运行的进程信息</p><p>unpause  Unpause a paused container          # 取消暂停容器</p><p>version  Show the docker version information      # 查看 docker 版本号</p><p>wait    Block until a container stops, then print its exit code  # 截取容器停止时的退出状态值</p><h3 id="1-4-Docker镜像"><a href="#1-4-Docker镜像" class="headerlink" title="1.4.      Docker镜像"></a>1.4.      Docker镜像</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image142.jpg" alt="img"></td></tr></tbody></table><h4 id="1-4-1-是什么"><a href="#1-4-1-是什么" class="headerlink" title="1.4.1.       是什么"></a><strong>1.4.1.</strong>       <strong>是什么</strong></h4><p>·     是什么</p><p><strong>镜像</strong></p><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><p>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p><p>·     分层的镜像</p><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p><p> <img src="https://image.3001.net/images/20220823/1661229993247.gif" alt="graphic"></p><p>·     UnionFS（联合文件系统）</p><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><img src="https://image.3001.net/images/20220823/16612321737109.jpg" alt="graphic"> </p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><p>·     Docker镜像加载原理</p><p> Docker镜像加载原理：</p><p>  docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p><p>。 <img src="https://image.3001.net/images/20220823/16612321703774.jpg" alt="graphic"></p><p> 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</p><p><img src="https://image.3001.net/images/20220823/1661232180224.jpg" alt="graphic"></p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><p>·     为什么 Docker 镜像要采用这种分层结构呢</p><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h4 id="1-4-2-重点理解"><a href="#1-4-2-重点理解" class="headerlink" title="1.4.2.       重点理解"></a><strong>1.4.2.</strong>       <strong>重点理解</strong></h4><p>·     Docker镜像层都是只读的，容器层是可写的 当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><img src="https://image.3001.net/images/20220823/16612321832243.jpg" alt="graphic"></p><h4 id="1-4-3-Docker镜像commit操作案例"><a href="#1-4-3-Docker镜像commit操作案例" class="headerlink" title="1.4.3.       Docker镜像commit操作案例"></a><strong>1.4.3.</strong>       <strong>Docker镜像commit操作案例</strong></h4><p>·     docker commit提交容器副本使之成为一个新的镜像</p><p>·     docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名]</p><p>·     案例演示ubuntu安装vim</p><p>·     从Hub上下载ubuntu镜像到本地并成功运行</p><p>·     原始的默认Ubuntu镜像是不带着vim命令的</p><p><img src="https://image.3001.net/images/20220823/16612321865672.jpg" alt="graphic"></p><p>·     外网连通的情况下，安装vim</p><p> <img src="https://image.3001.net/images/20220823/16612321881832.jpg" alt="graphic"></p><p>docker容器内执行上述两条命令：</p><p>apt-get update</p><p>apt-get -y install vim</p><p> <img src="https://image.3001.net/images/20220823/1661232190735.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612321926139.jpg" alt="graphic"></p><p>·     安装完成后，commit我们自己的新镜像</p><p><img src="https://image.3001.net/images/20220823/1661232194688.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612321953126.jpg" alt="graphic"></p><p>·     启动我们的新镜像并和原来的对比</p><p><img src="https://image.3001.net/images/20220823/16612321971662.jpg" alt="graphic"></p><p>1 官网是默认下载的Ubuntu没有vim命令</p><p>2我们自己commit构建的镜像，新增加了vim功能，可以成功使用。</p><p>·     小总结</p><p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p><p><img src="https://image.3001.net/images/20220823/1661232200982.jpg" alt="graphic"></p><h3 id="1-5-本地镜像发布到阿里云"><a href="#1-5-本地镜像发布到阿里云" class="headerlink" title="1.5.      本地镜像发布到阿里云"></a>1.5.      本地镜像发布到阿里云</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image168.jpg" alt="img"></td></tr></tbody></table><h4 id="1-5-1-本地镜像发布到阿里云流程"><a href="#1-5-1-本地镜像发布到阿里云流程" class="headerlink" title="1.5.1.       本地镜像发布到阿里云流程"></a><strong>1.5.1.</strong>       <strong>本地镜像发布到阿里云流程</strong></h4><p><img src="https://image.3001.net/images/20220823/16612322048689.jpg" alt="graphic"></p><h4 id="1-5-2-镜像的生成方法"><a href="#1-5-2-镜像的生成方法" class="headerlink" title="1.5.2.       镜像的生成方法"></a><strong>1.5.2.</strong>       <strong>镜像的生成方法</strong></h4><p>·     上一讲已经介绍过</p><p>·     基于当前容器创建一个新的镜像，新功能增强 docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</p><p>OPTIONS说明：</p><p>-a :提交的镜像作者；</p><p>-m :提交时的说明文字；</p><p>本次案例centos+ubuntu两个，当堂讲解一个，家庭作业一个，请大家务必动手，亲自实操。</p><p><img src="https://image.3001.net/images/20220823/16612322112814.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612322144993.jpg" alt="graphic"></p><p>·     后面的DockerFile章节，第2种方法</p><h4 id="1-5-3-将本地镜像推送到阿里云"><a href="#1-5-3-将本地镜像推送到阿里云" class="headerlink" title="1.5.3.       将本地镜像推送到阿里云"></a><strong>1.5.3.</strong>       <strong>将本地镜像推送到阿里云</strong></h4><p>·     本地镜像素材原型</p><p><img src="https://image.3001.net/images/20220823/16612322162638.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612322235453.jpg" alt="graphic"></p><p>·     阿里云开发者平台</p><p>·     <a href="https://promotion.aliyun.com/ntms/act/kubernetes.html">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p><p><img src="https://image.3001.net/images/20220823/16612322254480.jpg" alt="graphic"></p><p>·     创建仓库镜像</p><p><img src="https://image.3001.net/images/20220823/16612322278084.jpg" alt="graphic"></p><p>·     选择控制台，进入容器镜像服务</p><p><img src="https://image.3001.net/images/20220823/16612322297597.jpg" alt="graphic"></p><p>·     选择个人实例</p><p><img src="https://image.3001.net/images/20220823/16612322326009.jpg" alt="graphic"></p><p>·     命名空间</p><p><img src="https://image.3001.net/images/20220823/16612322348280.jpg" alt="graphic"></p><p>·     继续</p><p><img src="https://image.3001.net/images/20220823/16612322379.jpg" alt="graphic"></p><p>·     仓库名称</p><p> <img src="https://image.3001.net/images/20220823/16612322405919.jpg" alt="graphic"></p><p>·     继续</p><p><img src="https://image.3001.net/images/20220823/16612322421475.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612322461739.jpg" alt="graphic"></p><p>·     进入管理界面获得脚本</p><p><img src="https://image.3001.net/images/20220823/16612322483640.jpg" alt="graphic"></p><p>·     将镜像推送到阿里云</p><p>·     将镜像推送到阿里云registry</p><p>·     管理界面脚本</p><p><img src="https://image.3001.net/images/20220823/16612322525382.gif" alt="graphic"></p><p>·     脚本实例</p><table><thead><tr><th>docker login –username=zzyybuy registry.cn-hangzhou.aliyuncs.com</th></tr></thead><tbody><tr><td>docker tag cea1bb40441c  registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1</td></tr><tr><td>docker push  registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1</td></tr><tr><td>上面命令是阳哥自己本地的，你自己酌情处理，不要粘贴我的。</td></tr></tbody></table><p> <img src="https://image.3001.net/images/20220823/16612322587651.jpg" alt="graphic"></p><h4 id="1-5-4-将阿里云上的镜像下载到本地"><a href="#1-5-4-将阿里云上的镜像下载到本地" class="headerlink" title="1.5.4.       将阿里云上的镜像下载到本地"></a><strong>1.5.4.</strong>       <strong>将阿里云上的镜像下载到本地</strong></h4><p>·     下载到本地</p><p><img src="https://image.3001.net/images/20220823/16612322615706.jpg" alt="graphic"></p><p>docker pull registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1</p><h3 id="1-6-本地镜像发布到私有库"><a href="#1-6-本地镜像发布到私有库" class="headerlink" title="1.6.      本地镜像发布到私有库"></a>1.6.      本地镜像发布到私有库</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image206.jpg" alt="img"></td></tr></tbody></table><h4 id="1-6-1-本地镜像发布到私有库流程"><a href="#1-6-1-本地镜像发布到私有库流程" class="headerlink" title="1.6.1.       本地镜像发布到私有库流程"></a><strong>1.6.1.</strong>       <strong>本地镜像发布到私有库流程</strong></h4><p> <img src="https://image.3001.net/images/20220823/16612322648975.gif" alt="graphic"></p><h4 id="1-6-2-是什么"><a href="#1-6-2-是什么" class="headerlink" title="1.6.2.       是什么"></a><strong>1.6.2.</strong>       <strong>是什么</strong></h4><p>1 官方Docker Hub地址：<a href="https://hub.docker.com/%EF%BC%8C%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E8%AE%BF%E9%97%AE%E5%A4%AA%E6%85%A2%E4%BA%86%E4%B8%94%E5%87%86%E5%A4%87%E8%A2%AB%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%96%E4%BB%A3%E7%9A%84%E8%B6%8B%E5%8A%BF%EF%BC%8C%E4%B8%8D%E5%A4%AA%E4%B8%BB%E6%B5%81%E3%80%82">https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</a></p><p>2 Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</p><p>  Docker Registry是官方提供的工具，可以用于构建私有镜像仓库</p><p>·     Docker Registry</p><h4 id="1-6-3-将本地镜像推送到私有库"><a href="#1-6-3-将本地镜像推送到私有库" class="headerlink" title="1.6.3.       将本地镜像推送到私有库"></a><strong>1.6.3.</strong>       <strong>将本地镜像推送到私有库</strong></h4><p>·     下载镜像Docker Registry</p><p>docker pull registry </p><p><img src="https://image.3001.net/images/20220823/16612322683483.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/1661232270213.jpg" alt="graphic"></p><p>·     运行私有库Registry，相当于本地有个私有Docker hub</p><p>docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry –privileged=true registry</p><p>默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</p><p><img src="https://image.3001.net/images/20220823/16612322732280.jpg" alt="graphic"></p><p>·     案例演示创建一个新镜像，ubuntu安装ifconfig命令</p><p>·     从Hub上下载ubuntu镜像到本地并成功运行</p><p>·     原始的Ubuntu镜像是不带着ifconfig命令的</p><p><img src="https://image.3001.net/images/20220823/16612322774307.jpg" alt="graphic"></p><p>·     外网连通的情况下，安装ifconfig命令并测试通过</p><p>docker容器内执行上述两条命令：</p><p>apt-get update</p><p>apt-get install net-tools</p><p><img src="https://image.3001.net/images/20220823/16612322802792.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612322831850.jpg" alt="graphic"></p><p>·     安装完成后，commit我们自己的新镜像</p><p>公式：</p><p>docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名]</p><p>命令：在容器外执行，记得</p><p>docker commit -m=”ifconfig cmd add” -a=”zzyy” a69d7c825c4f zzyyubuntu:1.2</p><p><img src="https://image.3001.net/images/20220823/16612322868268.jpg" alt="graphic"></p><p>·     启动我们的新镜像并和原来的对比</p><p>1 官网是默认下载的Ubuntu没有ifconfig命令</p><p>2我们自己commit构建的新镜像，新增加了ifconfig功能，可以成功使用。</p><p><img src="https://image.3001.net/images/20220823/16612322888368.jpg" alt="graphic"></p><p>·     curl验证私服库上有什么镜像</p><p> curl -XGET <a href="http://192.168.111.162:5000/v2/_catalog">http://192.168.111.162:5000/v2/_catalog</a></p><p>可以看到，目前私服库没有任何镜像上传过。。。。。。</p><p><img src="https://image.3001.net/images/20220823/1661232292192.jpg" alt="graphic"></p><p>·     将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</p><p>按照公式： docker  tag  镜像:Tag  Host:Port/Repository:Tag</p><p>自己host主机IP地址，填写同学你们自己的，不要粘贴错误，O(∩_∩)O</p><p>使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.111.162:5000/zzyyubuntu:1.2</p><p>docker tag zzyyubuntu:1.2 192.168.111.162:5000/zzyyubuntu:1.2</p><p><img src="https://image.3001.net/images/20220823/16612322953183.jpg" alt="graphic"></p><p>·     修改配置文件使之支持http</p><p><img src="https://image.3001.net/images/20220823/16612322987450.jpg" alt="graphic"></p><p>  别无脑照着复制，registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。  ***2****<strong>个配置中间有个逗号*</strong> ***’,’******别漏了***，这个配置是json格式的。  ***2****<strong>个配置中间有个逗号*</strong> ***’,’******别漏了***，这个配置是json格式的。  ***2****<strong>个配置中间有个逗号*</strong> ***’,’******别漏了***，这个配置是json格式的。  </p><p>vim命令新增如下红色内容：vim /etc/docker/daemon.json</p><p>  {   “registry-mirrors”: [“<a href="https://aa25jngu.mirror.aliyuncs.com&quot;]">https://aa25jngu.mirror.aliyuncs.com&quot;]</a>,   “insecure-registries”:  [“192.168.111.162:5000”]  }  </p><p>上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt; 修改完后如果不生效，建议重启docker</p><p>·     push推送到私服库</p><p>docker push 192.168.111.162:5000/zzyyubuntu:1.2</p><p><img src="https://image.3001.net/images/20220823/16612323025640.jpg" alt="graphic"></p><p>·     curl验证私服库上有什么镜像2</p><p>curl -XGET <a href="http://192.168.111.162:5000/v2/_catalog">http://192.168.111.162:5000/v2/_catalog</a></p><p><img src="https://image.3001.net/images/20220823/16612323071442.jpg" alt="graphic"></p><p>·     pull到本地并运行</p><p>docker pull 192.168.111.162:5000/zzyyubuntu:1.2</p><p><img src="https://image.3001.net/images/20220823/16612323104433.jpg" alt="graphic"></p><p>docker run -it 镜像ID /bin/bash</p><p><img src="https://image.3001.net/images/20220823/16612323138556.jpg" alt="graphic"></p><h3 id="1-7-Docker容器数据卷"><a href="#1-7-Docker容器数据卷" class="headerlink" title="1.7.      Docker容器数据卷"></a>1.7.      Docker容器数据卷</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image240.jpg" alt="img"></td></tr></tbody></table><h4 id="1-7-1-坑：容器卷记得加入"><a href="#1-7-1-坑：容器卷记得加入" class="headerlink" title="1.7.1.       坑：容器卷记得加入"></a><strong>1.7.1.</strong>       <strong>坑：容器卷记得加入</strong></h4><table><thead><tr><th>单图标</th><th><img src="https://image.3001.net/images/20220823/16612323161521.gif" alt="img"> CustomIcon-663735520; [“”, “4MyPJwAAAAAAAAAAAAAAAA==”]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     –privileged=true</p><p>·     why</p><p> Docker挂载主机目录访问如果出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，</p><p>在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即</p><p>使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p><h4 id="1-7-2-回顾下上一讲的知识点，参数V"><a href="#1-7-2-回顾下上一讲的知识点，参数V" class="headerlink" title="1.7.2.       回顾下上一讲的知识点，参数V"></a><strong>1.7.2.</strong>       <strong>回顾下上一讲的知识点，参数V</strong></h4><p>还记得蓝色框框中的内容吗？</p><p><img src="https://image.3001.net/images/20220823/16612323208032.jpg" alt="graphic"></p><h4 id="1-7-3-是什么"><a href="#1-7-3-是什么" class="headerlink" title="1.7.3.       是什么"></a><strong>1.7.3.</strong>       <strong>是什么</strong></h4><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p><p>·     一句话：有点类似我们Redis里面的rdb和aof文件</p><p>·     将docker容器内的数据保存进宿主机的磁盘中</p><p>·     运行一个带有容器卷存储功能的容器实例</p><p>·     docker run -it –privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</p><h4 id="1-7-4-能干嘛"><a href="#1-7-4-能干嘛" class="headerlink" title="1.7.4.       能干嘛"></a><strong>1.7.4.</strong>       <strong>能干嘛</strong></h4><p>* 将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的</p><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p><p>为了能保存数据在docker中我们使用卷。</p><p>特点：</p><p>1：数据卷可在容器之间共享或重用数据</p><p>2：卷中的更改可以直接实时生效，爽</p><p>3：数据卷中的更改不会包含在镜像的更新中</p><p>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h4 id="1-7-5-数据卷案例"><a href="#1-7-5-数据卷案例" class="headerlink" title="1.7.5.       数据卷案例"></a><strong>1.7.5.</strong>       <strong>数据卷案例</strong></h4><p>·     宿主vs容器之间映射添加容器卷</p><p>·     直接命令添加</p><p>·     命令</p><p> 公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash</p><p>  docker run -it –name myu3 –privileged=true -v  /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash  </p><p> <img src="https://image.3001.net/images/20220823/16612323269266.jpg" alt="graphic"></p><p>·     docker run -it –privileged=true -v /宿主机绝对路径目录:/容器内目录   镜像名</p><p>·     查看数据卷是否挂载成功</p><p>docker inspect 容器ID</p><p><img src="https://image.3001.net/images/20220823/16612323328451.jpg" alt="graphic"></p><p>·     容器和宿主机之间数据共享</p><p>1 docker修改，主机同步获得 </p><p>2 主机修改，docker同步获得</p><p>3 docker容器stop，主机修改，docker容器重启看数据是否同步。</p><p><img src="https://image.3001.net/images/20220823/16612323342874.jpg" alt="graphic"></p><p>·     读写规则映射添加说明</p><p>·     读写(默认)</p><p><img src="https://image.3001.net/images/20220823/16612323369590.jpg" alt="graphic"></p><p> rw = read + write</p><p><img src="https://image.3001.net/images/20220823/16612323383280.jpg" alt="graphic"></p><p>·     docker run -it –privileged=true -v /宿主机绝对路径目录:/容器内目录:rw   镜像名</p><p>·     默认同上案例，默认就是rw</p><p>·     只读</p><p>·     容器实例内部被限制，只能读取不能写</p><p><img src="https://image.3001.net/images/20220823/16612323414175.jpg" alt="graphic"></p><p> /容器目录:ro 镜像名        就能完成功能，此时容器自己只能读取不能写 </p><p>ro = read only</p><p>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p><p>·     docker run -it –privileged=true -v /宿主机绝对路径目录:/容器内目录:ro   镜像名</p><p>·     卷的继承和共享</p><p>·     容器1完成和宿主机的映射</p><p>docker run -it –privileged=true -v /mydocker/u:/tmp –name u1 ubuntu</p><p><img src="https://image.3001.net/images/20220823/16612323449686.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612323466189.jpg" alt="graphic"></p><p>·     容器2继承容器1的卷规则</p><p><img src="https://image.3001.net/images/20220823/16612323486961.jpg" alt="graphic"></p><p>·     docker run -it –privileged=true –volumes-from 父类 –name u2 ubuntu</p><h3 id="1-8-Docker常规安装简介"><a href="#1-8-Docker常规安装简介" class="headerlink" title="1.8.      Docker常规安装简介"></a>1.8.      Docker常规安装简介</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image263.jpg" alt="img"></td></tr></tbody></table><h4 id="1-8-1-总体步骤"><a href="#1-8-1-总体步骤" class="headerlink" title="1.8.1.       总体步骤"></a><strong>1.8.1.</strong>       <strong>总体步骤</strong></h4><p>·     搜索镜像</p><p>·     拉取镜像</p><p>·     查看镜像</p><p>·     启动镜像</p><p>·     服务端口映射</p><p>·     停止容器</p><p>·     移除容器</p><h4 id="1-8-2-安装tomcat"><a href="#1-8-2-安装tomcat" class="headerlink" title="1.8.2.       安装tomcat"></a><strong>1.8.2.</strong>       <strong>安装tomcat</strong></h4><p>·     docker hub上面查找tomcat镜像</p><p>·     docker search tomcat</p><p><img src="https://image.3001.net/images/20220823/16612323511607.jpg" alt="graphic"></p><p>·     从docker hub上拉取tomcat镜像到本地</p><p>·     docker pull tomcat</p><p><img src="https://image.3001.net/images/20220823/16612323548895.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612323588363.jpg" alt="graphic"></p><p>·     docker ./images查看是否有拉取到的tomcat</p><p><img src="https://image.3001.net/images/20220823/16612323622050.jpg" alt="graphic"></p><p>·     使用tomcat镜像创建容器实例(也叫运行镜像)</p><p>·     docker run -it -p 8080:8080 tomcat</p><p>·     -p 小写，主机端口:docker容器端口</p><p>·     -P 大写，随机分配端口</p><p><img src="https://image.3001.net/images/20220823/16612323645720.jpg" alt="graphic"></p><p>·     i:交互</p><p>·     t:终端</p><p>·     d:后台</p><p>·     访问猫首页</p><p>·     问题</p><p><img src="https://image.3001.net/images/20220823/16612323667978.jpg" alt="graphic"></p><p>·     解决</p><p>·     可能没有映射端口或者没有关闭防火墙</p><p><img src="https://image.3001.net/images/20220823/16612323692072.jpg" alt="graphic"></p><p>·     把webapps.dist目录换成webapps</p><p>·     先成功启动tomcat</p><p><img src="https://image.3001.net/images/20220823/16612323714369.jpg" alt="graphic"></p><p>·     查看webapps 文件夹查看为空</p><p><img src="https://image.3001.net/images/20220823/16612323753933.jpg" alt="graphic"></p><p>·     免修改版说明</p><p>·     docker pull billygoo/tomcat8-jdk8</p><p>·     docker run -d -p 8080:8080 –name mytomcat8 billygoo/tomcat8-jdk8</p><p><img src="https://image.3001.net/images/20220823/16612323793169.jpg" alt="graphic"></p><h4 id="1-8-3-安装mysql"><a href="#1-8-3-安装mysql" class="headerlink" title="1.8.3.       安装mysql"></a><strong>1.8.3.</strong>       <strong>安装mysql</strong></h4><p>·     docker hub上面查找mysql镜像</p><p><img src="https://image.3001.net/images/20220823/16612323835962.jpg" alt="graphic"></p><p>·     从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.7</p><p><img src="https://image.3001.net/images/20220823/16612323845602.jpg" alt="graphic"></p><p>·     使用mysql5.7镜像创建容器(也叫运行镜像)</p><p>·     命令出处，哪里来的？</p><p><img src="https://image.3001.net/images/20220823/16612323875869.jpg" alt="graphic"></p><p>·     简单版</p><p>·     使用mysql镜像</p><table><thead><tr><th>docker run -p 3306:3306 -e  MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</th></tr></thead><tbody><tr><td>docker ps</td></tr><tr><td>docker exec -it 容器ID /bin/bash</td></tr><tr><td>mysql -uroot -p</td></tr></tbody></table><p><img src="https://image.3001.net/images/20220823/16612323913230.jpg" alt="graphic"></p><p>·     建库建表插入数据</p><p><img src="https://image.3001.net/images/20220823/16612323935339.jpg" alt="graphic"></p><p>·     外部Win10也来连接运行在dokcer上的mysql容器实例服务</p><p><img src="https://image.3001.net/images/20220823/16612323962976.jpg" alt="graphic"></p><p>·     问题</p><p>·     插入中文数据试试</p><p><img src="https://image.3001.net/images/20220823/166123239726.jpg" alt="graphic"></p><p>·     为什么报错?</p><p>·     docker上默认字符集编码隐患</p><p> docker里面的mysql容器实例查看，内容如下：</p><p> SHOW VARIABLES LIKE ‘character%’</p><p><img src="https://image.3001.net/images/20220823/16612324004677.jpg" alt="graphic"></p><p>·     删除容器后，里面的mysql数据如何办</p><p>·     容器实例一删除，你还有什么？ 删容器到跑路。。。。。？</p><p>·     实战版</p><p>·     新建mysql容器实例</p><p>  docker run -d -p 3306:3306 –privileged=true -v  /zzyyuse/mysql/log:/var/log/mysql -v /zzyyuse/mysql/data:/var/lib/mysql -v /zzyyuse/mysql/conf:/etc/mysql/conf.d  -e MYSQL_ROOT_PASSWORD=123456 –name mysql mysql:5.7  </p><p><img src="https://image.3001.net/images/20220823/16612324032320.jpg" alt="graphic"></p><p>·     新建my.cnf</p><p>·     通过容器卷同步给mysql容器实例</p><p>  [client]  default_character_set=utf8  [mysqld]  collation_server = utf8_general_ci  character_set_server = utf8  </p><p> <img src="https://image.3001.net/images/20220823/16612324112083.jpg" alt="graphic"></p><p>·     重新启动mysql容器实例再重新进入并查看字符编码</p><p> <img src="https://image.3001.net/images/20220823/16612324085997.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612324061278.jpg" alt="graphic"></p><p>·     再新建库新建表再插入中文测试</p><p><img src="https://image.3001.net/images/20220823/16612324154352.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612324175121.jpg" alt="graphic"></p><p>·     结论</p><p>之前的DB 无效</p><p>修改字符集操作+重启mysql容器实例</p><p>之后的DB 有效，需要新建</p><p>结论：docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据</p><p><img src="https://image.3001.net/images/20220823/16612324211737.jpg" alt="graphic"></p><p>·     假如将当前容器实例删除，再重新来一次，之前建的db01实例还有吗？trytry</p><h4 id="1-8-4-安装redis"><a href="#1-8-4-安装redis" class="headerlink" title="1.8.4.       安装redis"></a><strong>1.8.4.</strong>       <strong>安装redis</strong></h4><p>·     从docker hub上(阿里云加速器)拉取redis镜像到本地标签为6.0.8</p><p><img src="https://image.3001.net/images/20220823/16612324235923.jpg" alt="graphic"></p><p>·     入门命令</p><p><img src="https://image.3001.net/images/20220823/16612324253494.jpg" alt="graphic"></p><p>·     <strong>命令提醒：容器卷记得加入</strong>–privileged=true</p><p>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><p>·     在CentOS宿主机下新建目录/app/redis</p><p><img src="https://image.3001.net/images/20220823/16612324306078.jpg" alt="graphic"></p><p>1 建目录</p><p> mkdir -p /app/redis</p><p>·     mkdir -p /app/redis</p><p>·     将一个redis.conf文件模板拷贝进/app/redis目录下</p><p><img src="https://image.3001.net/images/20220823/16612324337150.jpg" alt="graphic"></p><p>2 拷贝配置文件</p><p> 将准备好的redis.conf文件放进/app/redis目录下</p><p>·     /app/redis目录下修改redis.conf文件</p><p>3 /app/redis目录下修改redis.conf文件</p><p> 3.1 开启redis验证  可选</p><p>  requirepass 123</p><p> 3.2 允许redis外地连接 必须</p><p>   注释掉 # bind 127.0.0.1</p><p><img src="https://image.3001.net/images/20220823/1661232436490.jpg" alt="graphic"></p><p> 3.3  daemonize no</p><p>   将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</p><p> <img src="https://image.3001.net/images/20220823/16612324397443.jpg" alt="graphic"></p><p> 3.4 开启redis数据持久化 appendonly yes 可选</p><p>·     默认出厂的原始redis.conf</p><p># Redis configuration file example.</p><p>#</p><p># Note that in order to read the configuration file, Redis must be</p><p># started with the file path as first argument:</p><p>#</p><p># ./redis-server /path/to/redis.conf</p><p># Note on units: when memory size is needed, it is possible to specify</p><p># it in the usual form of 1k 5GB 4M and so forth:</p><p>#</p><p># 1k =&gt; 1000 bytes</p><p># 1kb =&gt; 1024 bytes</p><p># 1m =&gt; 1000000 bytes</p><p># 1mb =&gt; 1024*1024 bytes</p><p># 1g =&gt; 1000000000 bytes</p><p># 1gb =&gt; 1024<em>1024</em>1024 bytes</p><p>#</p><p># units are case insensitive so 1GB 1Gb 1gB are all the same.</p><p>################################## INCLUDES ###################################</p><p># Include one or more other config files here. This is useful if you</p><p># have a standard template that goes to all Redis servers but also need</p><p># to customize a few per-server settings. Include files can include</p><p># other files, so use this wisely.</p><p>#</p><p># Notice option “include” won’t be rewritten by command “CONFIG REWRITE”</p><p># from admin or Redis Sentinel. Since Redis always uses the last processed</p><p># line as value of a configuration directive, you’d better put includes</p><p># at the beginning of this file to avoid overwriting config change at runtime.</p><p>#</p><p># If instead you are interested in using includes to override configuration</p><p># options, it is better to use include as the last line.</p><p>#</p><p># include /path/to/local.conf</p><p># include /path/to/other.conf</p><p>################################## MODULES #####################################</p><p># Load modules at startup. If the server is not able to load modules</p><p># it will abort. It is possible to use multiple loadmodule directives.</p><p>#</p><p># loadmodule /path/to/my_module.so</p><p># loadmodule /path/to/other_module.so</p><p>################################## NETWORK #####################################</p><p># By default, if no “bind” configuration directive is specified, Redis listens</p><p># for connections from all the network interfaces available on the server.</p><p># It is possible to listen to just one or multiple selected interfaces using</p><p># the “bind” configuration directive, followed by one or more IP addresses.</p><p>#</p><p># Examples:</p><p>#</p><p># bind 192.168.1.100 10.0.0.1</p><p># bind 127.0.0.1 ::1</p><p>#</p><p># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</p><p># internet, binding to all the interfaces is dangerous and will expose the</p><p># instance to everybody on the internet. So by default we uncomment the</p><p># following bind directive, that will force Redis to listen only into</p><p># the IPv4 loopback interface address (this means Redis will be able to</p><p># accept connections only from clients running into the same computer it</p><p># is running).</p><p>#</p><p># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</p><p># JUST COMMENT THE FOLLOWING LINE.</p><p># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>#bind 127.0.0.1</p><p># Protected mode is a layer of security protection, in order to avoid that</p><p># Redis instances left open on the internet are accessed and exploited.</p><p>#</p><p># When protected mode is on and if:</p><p>#</p><p># 1) The server is not binding explicitly to a set of addresses using the</p><p>#  “bind” directive.</p><p># 2) No password is configured.</p><p>#</p><p># The server only accepts connections from clients connecting from the</p><p># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</p><p># sockets.</p><p>#</p><p># By default protected mode is enabled. You should disable it only if</p><p># you are sure you want clients from other hosts to connect to Redis</p><p># even if no authentication is configured, nor a specific set of interfaces</p><p># are explicitly listed using the “bind” directive.</p><p>protected-mode no</p><p># Accept connections on the specified port, default is 6379 (IANA #815344).</p><p># If port 0 is specified Redis will not listen on a TCP socket.</p><p>port 6379</p><p># TCP listen() backlog.</p><p>#</p><p># In high requests-per-second environments you need an high backlog in order</p><p># to avoid slow clients connections issues. Note that the Linux kernel</p><p># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</p><p># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</p><p># in order to get the desired effect.</p><p>tcp-backlog 511</p><p># Unix socket.</p><p>#</p><p># Specify the path for the Unix socket that will be used to listen for</p><p># incoming connections. There is no default, so Redis will not listen</p><p># on a unix socket when not specified.</p><p>#</p><p># unixsocket /tmp/redis.sock</p><p># unixsocketperm 700</p><p># Close the connection after a client is idle for N seconds (0 to disable)</p><p>timeout 0</p><p># TCP keepalive.</p><p>#</p><p># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</p><p># of communication. This is useful for two reasons:</p><p>#</p><p># 1) Detect dead peers.</p><p># 2) Take the connection alive from the point of view of network</p><p>#  equipment in the middle.</p><p>#</p><p># On Linux, the specified value (in seconds) is the period used to send ACKs.</p><p># Note that to close the connection the double of the time is needed.</p><p># On other kernels the period depends on the kernel configuration.</p><p>#</p><p># A reasonable value for this option is 300 seconds, which is the new</p><p># Redis default starting with Redis 3.2.1.</p><p>tcp-keepalive 300</p><p>################################# GENERAL #####################################</p><p># By default Redis does not run as a daemon. Use ‘yes’ if you need it.</p><p># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</p><p>daemonize no</p><p># If you run Redis from upstart or systemd, Redis can interact with your</p><p># supervision tree. Options:</p><p>#  supervised no    - no supervision interaction</p><p>#  supervised upstart - signal upstart by putting Redis into SIGSTOP mode</p><p>#  supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</p><p>#  supervised auto   - detect upstart or systemd method based on</p><p>#             UPSTART_JOB or NOTIFY_SOCKET environment variables</p><p># Note: these supervision methods only signal “process is ready.”</p><p>#    They do not enable continuous liveness pings back to your supervisor.</p><p>supervised no</p><p># If a pid file is specified, Redis writes it where specified at startup</p><p># and removes it at exit.</p><p>#</p><p># When the server runs non daemonized, no pid file is created if none is</p><p># specified in the configuration. When the server is daemonized, the pid file</p><p># is used even if not specified, defaulting to “/var/run/redis.pid”.</p><p>#</p><p># Creating a pid file is best effort: if Redis is not able to create it</p><p># nothing bad happens, the server will start and run normally.</p><p>pidfile /var/run/redis_6379.pid</p><p># Specify the server verbosity level.</p><p># This can be one of:</p><p># debug (a lot of information, useful for development/testing)</p><p># verbose (many rarely useful info, but not a mess like the debug level)</p><p># notice (moderately verbose, what you want in production probably)</p><p># warning (only very important / critical messages are logged)</p><p>loglevel notice</p><p># Specify the log file name. Also the empty string can be used to force</p><p># Redis to log on the standard output. Note that if you use standard</p><p># output for logging but daemonize, logs will be sent to /dev/null</p><p>logfile “”</p><p># To enable logging to the system logger, just set ‘syslog-enabled’ to yes,</p><p># and optionally update the other syslog parameters to suit your needs.</p><p># syslog-enabled no</p><p># Specify the syslog identity.</p><p># syslog-ident redis</p><p># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</p><p># syslog-facility local0</p><p># Set the number of databases. The default database is DB 0, you can select</p><p># a different one on a per-connection basis using SELECT <dbid> where</p><p># dbid is a number between 0 and ‘databases’-1</p><p>databases 16</p><p># By default Redis shows an ASCII art logo only when started to log to the</p><p># standard output and if the standard output is a TTY. Basically this means</p><p># that normally a logo is displayed only in interactive sessions.</p><p>#</p><p># However it is possible to force the pre-4.0 behavior and always show a</p><p># ASCII art logo in startup logs by setting the following option to yes.</p><p>always-show-logo yes</p><p>################################ SNAPSHOTTING ################################</p><p>#</p><p># Save the DB on disk:</p><p>#</p><p>#  save <seconds> <changes></p><p>#</p><p>#  Will save the DB if both the given number of seconds and the given</p><p>#  number of write operations against the DB occurred.</p><p>#</p><p>#  In the example below the behaviour will be to save:</p><p>#  after 900 sec (15 min) if at least 1 key changed</p><p>#  after 300 sec (5 min) if at least 10 keys changed</p><p>#  after 60 sec if at least 10000 keys changed</p><p>#</p><p>#  Note: you can disable saving completely by commenting out all “save” lines.</p><p>#</p><p>#  It is also possible to remove all the previously configured save</p><p>#  points by adding a save directive with a single empty string argument</p><p>#  like in the following example:</p><p>#</p><p>#  save “”</p><p>save 900 1</p><p>save 300 10</p><p>save 60 10000</p><p># By default Redis will stop accepting writes if RDB snapshots are enabled</p><p># (at least one save point) and the latest background save failed.</p><p># This will make the user aware (in a hard way) that data is not persisting</p><p># on disk properly, otherwise chances are that no one will notice and some</p><p># disaster will happen.</p><p>#</p><p># If the background saving process will start working again Redis will</p><p># automatically allow writes again.</p><p>#</p><p># However if you have setup your proper monitoring of the Redis server</p><p># and persistence, you may want to disable this feature so that Redis will</p><p># continue to work as usual even if there are problems with disk,</p><p># permissions, and so forth.</p><p>stop-writes-on-bgsave-error yes</p><p># Compress string objects using LZF when dump .rdb databases?</p><p># For default that’s set to ‘yes’ as it’s almost always a win.</p><p># If you want to save some CPU in the saving child set it to ‘no’ but</p><p># the dataset will likely be bigger if you have compressible values or keys.</p><p>rdbcompression yes</p><p># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</p><p># This makes the format more resistant to corruption but there is a performance</p><p># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</p><p># for maximum performances.</p><p>#</p><p># RDB files created with checksum disabled have a checksum of zero that will</p><p># tell the loading code to skip the check.</p><p>rdbchecksum yes</p><p># The filename where to dump the DB</p><p>dbfilename dump.rdb</p><p># The working directory.</p><p>#</p><p># The DB will be written inside this directory, with the filename specified</p><p># above using the ‘dbfilename’ configuration directive.</p><p>#</p><p># The Append Only File will also be created inside this directory.</p><p>#</p><p># Note that you must specify a directory here, not a file name.</p><p>dir ./</p><p>################################# REPLICATION #################################</p><p># Master-Replica replication. Use replicaof to make a Redis instance a copy of</p><p># another Redis server. A few things to understand ASAP about Redis replication.</p><p>#</p><p>#  +——————+   +—————+</p><p>#  |   Master    | —&gt; |  Replica   |</p><p>#  | (receive writes) |    | (exact copy) |</p><p>#  +——————+    +—————+</p><p>#</p><p># 1) Redis replication is asynchronous, but you can configure a master to</p><p>#  stop accepting writes if it appears to be not connected with at least</p><p>#  a given number of replicas.</p><p># 2) Redis replicas are able to perform a partial resynchronization with the</p><p>#  master if the replication link is lost for a relatively small amount of</p><p>#  time. You may want to configure the replication backlog size (see the next</p><p>#  sections of this file) with a sensible value depending on your needs.</p><p># 3) Replication is automatic and does not need user intervention. After a</p><p>#  network partition replicas automatically try to reconnect to masters</p><p>#  and resynchronize with them.</p><p>#</p><p># replicaof <masterip> <masterport></p><p># If the master is password protected (using the “requirepass” configuration</p><p># directive below) it is possible to tell the replica to authenticate before</p><p># starting the replication synchronization process, otherwise the master will</p><p># refuse the replica request.</p><p>#</p><p># masterauth <master-password></p><p># When a replica loses its connection with the master, or when the replication</p><p># is still in progress, the replica can act in two different ways:</p><p>#</p><p># 1) if replica-serve-stale-data is set to ‘yes’ (the default) the replica will</p><p>#  still reply to client requests, possibly with out of date data, or the</p><p>#  data set may just be empty if this is the first synchronization.</p><p>#</p><p># 2) if replica-serve-stale-data is set to ‘no’ the replica will reply with</p><p>#  an error “SYNC with master in progress” to all the kind of commands</p><p>#  but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</p><p>#  SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</p><p>#  COMMAND, POST, HOST: and LATENCY.</p><p>#</p><p>replica-serve-stale-data yes</p><p># You can configure a replica instance to accept writes or not. Writing against</p><p># a replica instance may be useful to store some ephemeral data (because data</p><p># written on a replica will be easily deleted after resync with the master) but</p><p># may also cause problems if clients are writing to it because of a</p><p># misconfiguration.</p><p>#</p><p># Since Redis 2.6 by default replicas are read-only.</p><p>#</p><p># Note: read only replicas are not designed to be exposed to untrusted clients</p><p># on the internet. It’s just a protection layer against misuse of the instance.</p><p># Still a read only replica exports by default all the administrative commands</p><p># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</p><p># security of read only replicas using ‘rename-command’ to shadow all the</p><p># administrative / dangerous commands.</p><p>replica-read-only yes</p><p># Replication SYNC strategy: disk or socket.</p><p>#</p><p># ——————————————————-</p><p># WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY</p><p># ——————————————————-</p><p>#</p><p># New replicas and reconnecting replicas that are not able to continue the replication</p><p># process just receiving differences, need to do what is called a “full</p><p># synchronization”. An RDB file is transmitted from the master to the replicas.</p><p># The transmission can happen in two different ways:</p><p>#</p><p># 1) Disk-backed: The Redis master creates a new process that writes the RDB</p><p>#         file on disk. Later the file is transferred by the parent</p><p>#         process to the replicas incrementally.</p><p># 2) Diskless: The Redis master creates a new process that directly writes the</p><p>#       RDB file to replica sockets, without touching the disk at all.</p><p>#</p><p># With disk-backed replication, while the RDB file is generated, more replicas</p><p># can be queued and served with the RDB file as soon as the current child producing</p><p># the RDB file finishes its work. With diskless replication instead once</p><p># the transfer starts, new replicas arriving will be queued and a new transfer</p><p># will start when the current one terminates.</p><p>#</p><p># When diskless replication is used, the master waits a configurable amount of</p><p># time (in seconds) before starting the transfer in the hope that multiple replicas</p><p># will arrive and the transfer can be parallelized.</p><p>#</p><p># With slow disks and fast (large bandwidth) networks, diskless replication</p><p># works better.</p><p>repl-diskless-sync no</p><p># When diskless replication is enabled, it is possible to configure the delay</p><p># the server waits in order to spawn the child that transfers the RDB via socket</p><p># to the replicas.</p><p>#</p><p># This is important since once the transfer starts, it is not possible to serve</p><p># new replicas arriving, that will be queued for the next RDB transfer, so the server</p><p># waits a delay in order to let more replicas arrive.</p><p>#</p><p># The delay is specified in seconds, and by default is 5 seconds. To disable</p><p># it entirely just set it to 0 seconds and the transfer will start ASAP.</p><p>repl-diskless-sync-delay 5</p><p># Replicas send PINGs to server in a predefined interval. It’s possible to change</p><p># this interval with the repl_ping_replica_period option. The default value is 10</p><p># seconds.</p><p>#</p><p># repl-ping-replica-period 10</p><p># The following option sets the replication timeout for:</p><p>#</p><p># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</p><p># 2) Master timeout from the point of view of replicas (data, pings).</p><p># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</p><p>#</p><p># It is important to make sure that this value is greater than the value</p><p># specified for repl-ping-replica-period otherwise a timeout will be detected</p><p># every time there is low traffic between the master and the replica.</p><p>#</p><p># repl-timeout 60</p><p># Disable TCP_NODELAY on the replica socket after SYNC?</p><p>#</p><p># If you select “yes” Redis will use a smaller number of TCP packets and</p><p># less bandwidth to send data to replicas. But this can add a delay for</p><p># the data to appear on the replica side, up to 40 milliseconds with</p><p># Linux kernels using a default configuration.</p><p>#</p><p># If you select “no” the delay for data to appear on the replica side will</p><p># be reduced but more bandwidth will be used for replication.</p><p>#</p><p># By default we optimize for low latency, but in very high traffic conditions</p><p># or when the master and replicas are many hops away, turning this to “yes” may</p><p># be a good idea.</p><p>repl-disable-tcp-nodelay no</p><p># Set the replication backlog size. The backlog is a buffer that accumulates</p><p># replica data when replicas are disconnected for some time, so that when a replica</p><p># wants to reconnect again, often a full resync is not needed, but a partial</p><p># resync is enough, just passing the portion of data the replica missed while</p><p># disconnected.</p><p>#</p><p># The bigger the replication backlog, the longer the time the replica can be</p><p># disconnected and later be able to perform a partial resynchronization.</p><p>#</p><p># The backlog is only allocated once there is at least a replica connected.</p><p>#</p><p># repl-backlog-size 1mb</p><p># After a master has no longer connected replicas for some time, the backlog</p><p># will be freed. The following option configures the amount of seconds that</p><p># need to elapse, starting from the time the last replica disconnected, for</p><p># the backlog buffer to be freed.</p><p>#</p><p># Note that replicas never free the backlog for timeout, since they may be</p><p># promoted to masters later, and should be able to correctly “partially</p><p># resynchronize” with the replicas: hence they should always accumulate backlog.</p><p>#</p><p># A value of 0 means to never release the backlog.</p><p>#</p><p># repl-backlog-ttl 3600</p><p># The replica priority is an integer number published by Redis in the INFO output.</p><p># It is used by Redis Sentinel in order to select a replica to promote into a</p><p># master if the master is no longer working correctly.</p><p>#</p><p># A replica with a low priority number is considered better for promotion, so</p><p># for instance if there are three replicas with priority 10, 100, 25 Sentinel will</p><p># pick the one with priority 10, that is the lowest.</p><p>#</p><p># However a special priority of 0 marks the replica as not able to perform the</p><p># role of master, so a replica with priority of 0 will never be selected by</p><p># Redis Sentinel for promotion.</p><p>#</p><p># By default the priority is 100.</p><p>replica-priority 100</p><p># It is possible for a master to stop accepting writes if there are less than</p><p># N replicas connected, having a lag less or equal than M seconds.</p><p>#</p><p># The N replicas need to be in “online” state.</p><p>#</p><p># The lag in seconds, that must be &lt;= the specified value, is calculated from</p><p># the last ping received from the replica, that is usually sent every second.</p><p>#</p><p># This option does not GUARANTEE that N replicas will accept the write, but</p><p># will limit the window of exposure for lost writes in case not enough replicas</p><p># are available, to the specified number of seconds.</p><p>#</p><p># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</p><p>#</p><p># min-replicas-to-write 3</p><p># min-replicas-max-lag 10</p><p>#</p><p># Setting one or the other to 0 disables the feature.</p><p>#</p><p># By default min-replicas-to-write is set to 0 (feature disabled) and</p><p># min-replicas-max-lag is set to 10.</p><p># A Redis master is able to list the address and port of the attached</p><p># replicas in different ways. For example the “INFO replication” section</p><p># offers this information, which is used, among other tools, by</p><p># Redis Sentinel in order to discover replica instances.</p><p># Another place where this info is available is in the output of the</p><p># “ROLE” command of a master.</p><p>#</p><p># The listed IP and address normally reported by a replica is obtained</p><p># in the following way:</p><p>#</p><p>#  IP: The address is auto detected by checking the peer address</p><p>#  of the socket used by the replica to connect with the master.</p><p>#</p><p>#  Port: The port is communicated by the replica during the replication</p><p>#  handshake, and is normally the port that the replica is using to</p><p>#  listen for connections.</p><p>#</p><p># However when port forwarding or Network Address Translation (NAT) is</p><p># used, the replica may be actually reachable via different IP and port</p><p># pairs. The following two options can be used by a replica in order to</p><p># report to its master a specific set of IP and port, so that both INFO</p><p># and ROLE will report those values.</p><p>#</p><p># There is no need to use both the options if you need to override just</p><p># the port or the IP address.</p><p>#</p><p># replica-announce-ip 5.5.5.5</p><p># replica-announce-port 1234</p><p>################################## SECURITY ###################################</p><p># Require clients to issue AUTH <PASSWORD> before processing any other</p><p># commands. This might be useful in environments in which you do not trust</p><p># others with access to the host running redis-server.</p><p>#</p><p># This should stay commented out for backward compatibility and because most</p><p># people do not need auth (e.g. they run their own servers).</p><p>#</p><p># Warning: since Redis is pretty fast an outside user can try up to</p><p># 150k passwords per second against a good box. This means that you should</p><p># use a very strong password otherwise it will be very easy to break.</p><p>#</p><p># requirepass foobared</p><p># Command renaming.</p><p>#</p><p># It is possible to change the name of dangerous commands in a shared</p><p># environment. For instance the CONFIG command may be renamed into something</p><p># hard to guess so that it will still be available for internal-use tools</p><p># but not available for general clients.</p><p>#</p><p># Example:</p><p>#</p><p># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</p><p>#</p><p># It is also possible to completely kill a command by renaming it into</p><p># an empty string:</p><p>#</p><p># rename-command CONFIG “”</p><p>#</p><p># Please note that changing the name of commands that are logged into the</p><p># AOF file or transmitted to replicas may cause problems.</p><p>################################### CLIENTS ####################################</p><p># Set the max number of connected clients at the same time. By default</p><p># this limit is set to 10000 clients, however if the Redis server is not</p><p># able to configure the process file limit to allow for the specified limit</p><p># the max number of allowed clients is set to the current file limit</p><p># minus 32 (as Redis reserves a few file descriptors for internal uses).</p><p>#</p><p># Once the limit is reached Redis will close all the new connections sending</p><p># an error ‘max number of clients reached’.</p><p>#</p><p># maxclients 10000</p><p>############################## MEMORY MANAGEMENT ################################</p><p># Set a memory usage limit to the specified amount of bytes.</p><p># When the memory limit is reached Redis will try to remove keys</p><p># according to the eviction policy selected (see maxmemory-policy).</p><p>#</p><p># If Redis can’t remove keys according to the policy, or if the policy is</p><p># set to ‘noeviction’, Redis will start to reply with errors to commands</p><p># that would use more memory, like SET, LPUSH, and so on, and will continue</p><p># to reply to read-only commands like GET.</p><p>#</p><p># This option is usually useful when using Redis as an LRU or LFU cache, or to</p><p># set a hard memory limit for an instance (using the ‘noeviction’ policy).</p><p>#</p><p># WARNING: If you have replicas attached to an instance with maxmemory on,</p><p># the size of the output buffers needed to feed the replicas are subtracted</p><p># from the used memory count, so that network problems / resyncs will</p><p># not trigger a loop where keys are evicted, and in turn the output</p><p># buffer of replicas is full with DELs of keys evicted triggering the deletion</p><p># of more keys, and so forth until the database is completely emptied.</p><p>#</p><p># In short… if you have replicas attached it is suggested that you set a lower</p><p># limit for maxmemory so that there is some free RAM on the system for replica</p><p># output buffers (but this is not needed if the policy is ‘noeviction’).</p><p>#</p><p># maxmemory <bytes></p><p># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</p><p># is reached. You can select among five behaviors:</p><p>#</p><p># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</p><p># allkeys-lru -&gt; Evict any key using approximated LRU.</p><p># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</p><p># allkeys-lfu -&gt; Evict any key using approximated LFU.</p><p># volatile-random -&gt; Remove a random key among the ones with an expire set.</p><p># allkeys-random -&gt; Remove a random key, any key.</p><p># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</p><p># noeviction -&gt; Don’t evict anything, just return an error on write operations.</p><p>#</p><p># LRU means Least Recently Used</p><p># LFU means Least Frequently Used</p><p>#</p><p># Both LRU, LFU and volatile-ttl are implemented using approximated</p><p># randomized algorithms.</p><p>#</p><p># Note: with any of the above policies, Redis will return an error on write</p><p>#    operations, when there are no suitable keys for eviction.</p><p>#</p><p>#    At the date of writing these commands are: set setnx setex append</p><p>#    incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</p><p>#    sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</p><p>#    zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</p><p>#    getset mset msetnx exec sort</p><p>#</p><p># The default is:</p><p>#</p><p># maxmemory-policy noeviction</p><p># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</p><p># algorithms (in order to save memory), so you can tune it for speed or</p><p># accuracy. For default Redis will check five keys and pick the one that was</p><p># used less recently, you can change the sample size using the following</p><p># configuration directive.</p><p>#</p><p># The default of 5 produces good enough results. 10 Approximates very closely</p><p># true LRU but costs more CPU. 3 is faster but not very accurate.</p><p>#</p><p># maxmemory-samples 5</p><p># Starting from Redis 5, by default a replica will ignore its maxmemory setting</p><p># (unless it is promoted to master after a failover or manually). It means</p><p># that the eviction of keys will be just handled by the master, sending the</p><p># DEL commands to the replica as keys evict in the master side.</p><p>#</p><p># This behavior ensures that masters and replicas stay consistent, and is usually</p><p># what you want, however if your replica is writable, or you want the replica to have</p><p># a different memory setting, and you are sure all the writes performed to the</p><p># replica are idempotent, then you may change this default (but be sure to understand</p><p># what you are doing).</p><p>#</p><p># Note that since the replica by default does not evict, it may end using more</p><p># memory than the one set via maxmemory (there are certain buffers that may</p><p># be larger on the replica, or data structures may sometimes take more memory and so</p><p># forth). So make sure you monitor your replicas and make sure they have enough</p><p># memory to never hit a real out-of-memory condition before the master hits</p><p># the configured maxmemory setting.</p><p>#</p><p># replica-ignore-maxmemory yes</p><p>############################# LAZY FREEING ####################################</p><p># Redis has two primitives to delete keys. One is called DEL and is a blocking</p><p># deletion of the object. It means that the server stops processing new commands</p><p># in order to reclaim all the memory associated with an object in a synchronous</p><p># way. If the key deleted is associated with a small object, the time needed</p><p># in order to execute the DEL command is very small and comparable to most other</p><p># O(1) or O(log_N) commands in Redis. However if the key is associated with an</p><p># aggregated value containing millions of elements, the server can block for</p><p># a long time (even seconds) in order to complete the operation.</p><p>#</p><p># For the above reasons Redis also offers non blocking deletion primitives</p><p># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</p><p># FLUSHDB commands, in order to reclaim memory in background. Those commands</p><p># are executed in constant time. Another thread will incrementally free the</p><p># object in the background as fast as possible.</p><p>#</p><p># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</p><p># It’s up to the design of the application to understand when it is a good</p><p># idea to use one or the other. However the Redis server sometimes has to</p><p># delete keys or flush the whole database as a side effect of other operations.</p><p># Specifically Redis deletes objects independently of a user call in the</p><p># following scenarios:</p><p>#</p><p># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</p><p>#  in order to make room for new data, without going over the specified</p><p>#  memory limit.</p><p># 2) Because of expire: when a key with an associated time to live (see the</p><p>#  EXPIRE command) must be deleted from memory.</p><p># 3) Because of a side effect of a command that stores data on a key that may</p><p>#  already exist. For example the RENAME command may delete the old key</p><p>#  content when it is replaced with another one. Similarly SUNIONSTORE</p><p>#  or SORT with STORE option may delete existing keys. The SET command</p><p>#  itself removes any old content of the specified key in order to replace</p><p>#  it with the specified string.</p><p># 4) During replication, when a replica performs a full resynchronization with</p><p>#  its master, the content of the whole database is removed in order to</p><p>#  load the RDB file just transferred.</p><p>#</p><p># In all the above cases the default is to delete objects in a blocking way,</p><p># like if DEL was called. However you can configure each case specifically</p><p># in order to instead release memory in a non-blocking way like if UNLINK</p><p># was called, using the following configuration directives:</p><p>lazyfree-lazy-eviction no</p><p>lazyfree-lazy-expire no</p><p>lazyfree-lazy-server-del no</p><p>replica-lazy-flush no</p><p>############################## APPEND ONLY MODE ###############################</p><p># By default Redis asynchronously dumps the dataset on disk. This mode is</p><p># good enough in many applications, but an issue with the Redis process or</p><p># a power outage may result into a few minutes of writes lost (depending on</p><p># the configured save points).</p><p>#</p><p># The Append Only File is an alternative persistence mode that provides</p><p># much better durability. For instance using the default data fsync policy</p><p># (see later in the config file) Redis can lose just one second of writes in a</p><p># dramatic event like a server power outage, or a single write if something</p><p># wrong with the Redis process itself happens, but the operating system is</p><p># still running correctly.</p><p>#</p><p># AOF and RDB persistence can be enabled at the same time without problems.</p><p># If the AOF is enabled on startup Redis will load the AOF, that is the file</p><p># with the better durability guarantees.</p><p>#</p><p># Please check <a href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a> for more information.</p><p>appendonly no</p><p># The name of the append only file (default: “appendonly.aof”)</p><p>appendfilename “appendonly.aof”</p><p># The fsync() call tells the Operating System to actually write data on disk</p><p># instead of waiting for more data in the output buffer. Some OS will really flush</p><p># data on disk, some other OS will just try to do it ASAP.</p><p>#</p><p># Redis supports three different modes:</p><p>#</p><p># no: don’t fsync, just let the OS flush the data when it wants. Faster.</p><p># always: fsync after every write to the append only log. Slow, Safest.</p><p># everysec: fsync only one time every second. Compromise.</p><p>#</p><p># The default is “everysec”, as that’s usually the right compromise between</p><p># speed and data safety. It’s up to you to understand if you can relax this to</p><p># “no” that will let the operating system flush the output buffer when</p><p># it wants, for better performances (but if you can live with the idea of</p><p># some data loss consider the default persistence mode that’s snapshotting),</p><p># or on the contrary, use “always” that’s very slow but a bit safer than</p><p># everysec.</p><p>#</p><p># More details please check the following article:</p><p># <a href="http://antirez.com/post/redis-persistence-demystified.html">http://antirez.com/post/redis-persistence-demystified.html</a></p><p>#</p><p># If unsure, use “everysec”.</p><p># appendfsync always</p><p>appendfsync everysec</p><p># appendfsync no</p><p># When the AOF fsync policy is set to always or everysec, and a background</p><p># saving process (a background save or AOF log background rewriting) is</p><p># performing a lot of I/O against the disk, in some Linux configurations</p><p># Redis may block too long on the fsync() call. Note that there is no fix for</p><p># this currently, as even performing fsync in a different thread will block</p><p># our synchronous write(2) call.</p><p>#</p><p># In order to mitigate this problem it’s possible to use the following option</p><p># that will prevent fsync() from being called in the main process while a</p><p># BGSAVE or BGREWRITEAOF is in progress.</p><p>#</p><p># This means that while another child is saving, the durability of Redis is</p><p># the same as “appendfsync none”. In practical terms, this means that it is</p><p># possible to lose up to 30 seconds of log in the worst scenario (with the</p><p># default Linux settings).</p><p>#</p><p># If you have latency problems turn this to “yes”. Otherwise leave it as</p><p># “no” that is the safest pick from the point of view of durability.</p><p>no-appendfsync-on-rewrite no</p><p># Automatic rewrite of the append only file.</p><p># Redis is able to automatically rewrite the log file implicitly calling</p><p># BGREWRITEAOF when the AOF log size grows by the specified percentage.</p><p>#</p><p># This is how it works: Redis remembers the size of the AOF file after the</p><p># latest rewrite (if no rewrite has happened since the restart, the size of</p><p># the AOF at startup is used).</p><p>#</p><p># This base size is compared to the current size. If the current size is</p><p># bigger than the specified percentage, the rewrite is triggered. Also</p><p># you need to specify a minimal size for the AOF file to be rewritten, this</p><p># is useful to avoid rewriting the AOF file even if the percentage increase</p><p># is reached but it is still pretty small.</p><p>#</p><p># Specify a percentage of zero in order to disable the automatic AOF</p><p># rewrite feature.</p><p>auto-aof-rewrite-percentage 100</p><p>auto-aof-rewrite-min-size 64mb</p><p># An AOF file may be found to be truncated at the end during the Redis</p><p># startup process, when the AOF data gets loaded back into memory.</p><p># This may happen when the system where Redis is running</p><p># crashes, especially when an ext4 filesystem is mounted without the</p><p># data=ordered option (however this can’t happen when Redis itself</p><p># crashes or aborts but the operating system still works correctly).</p><p>#</p><p># Redis can either exit with an error when this happens, or load as much</p><p># data as possible (the default now) and start if the AOF file is found</p><p># to be truncated at the end. The following option controls this behavior.</p><p>#</p><p># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</p><p># the Redis server starts emitting a log to inform the user of the event.</p><p># Otherwise if the option is set to no, the server aborts with an error</p><p># and refuses to start. When the option is set to no, the user requires</p><p># to fix the AOF file using the “redis-check-aof” utility before to restart</p><p># the server.</p><p>#</p><p># Note that if the AOF file will be found to be corrupted in the middle</p><p># the server will still exit with an error. This option only applies when</p><p># Redis will try to read more data from the AOF file but not enough bytes</p><p># will be found.</p><p>aof-load-truncated yes</p><p># When rewriting the AOF file, Redis is able to use an RDB preamble in the</p><p># AOF file for faster rewrites and recoveries. When this option is turned</p><p># on the rewritten AOF file is composed of two different stanzas:</p><p>#</p><p>#  [RDB file][AOF tail]</p><p>#</p><p># When loading Redis recognizes that the AOF file starts with the “REDIS”</p><p># string and loads the prefixed RDB file, and continues loading the AOF</p><p># tail.</p><p>aof-use-rdb-preamble yes</p><p>################################ LUA SCRIPTING ###############################</p><p># Max execution time of a Lua script in milliseconds.</p><p>#</p><p># If the maximum execution time is reached Redis will log that a script is</p><p># still in execution after the maximum allowed time and will start to</p><p># reply to queries with an error.</p><p>#</p><p># When a long running script exceeds the maximum execution time only the</p><p># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</p><p># used to stop a script that did not yet called write commands. The second</p><p># is the only way to shut down the server in the case a write command was</p><p># already issued by the script but the user doesn’t want to wait for the natural</p><p># termination of the script.</p><p>#</p><p># Set it to 0 or a negative value for unlimited execution without warnings.</p><p>lua-time-limit 5000</p><p>################################ REDIS CLUSTER ###############################</p><p># Normal Redis instances can’t be part of a Redis Cluster; only nodes that are</p><p># started as cluster nodes can. In order to start a Redis instance as a</p><p># cluster node enable the cluster support uncommenting the following:</p><p>#</p><p># cluster-enabled yes</p><p># Every cluster node has a cluster configuration file. This file is not</p><p># intended to be edited by hand. It is created and updated by Redis nodes.</p><p># Every Redis Cluster node requires a different cluster configuration file.</p><p># Make sure that instances running in the same system do not have</p><p># overlapping cluster configuration file names.</p><p>#</p><p># cluster-config-file nodes-6379.conf</p><p># Cluster node timeout is the amount of milliseconds a node must be unreachable</p><p># for it to be considered in failure state.</p><p># Most other internal time limits are multiple of the node timeout.</p><p>#</p><p># cluster-node-timeout 15000</p><p># A replica of a failing master will avoid to start a failover if its data</p><p># looks too old.</p><p>#</p><p># There is no simple way for a replica to actually have an exact measure of</p><p># its “data age”, so the following two checks are performed:</p><p>#</p><p># 1) If there are multiple replicas able to failover, they exchange messages</p><p>#  in order to try to give an advantage to the replica with the best</p><p>#  replication offset (more data from the master processed).</p><p>#  Replicas will try to get their rank by offset, and apply to the start</p><p>#  of the failover a delay proportional to their rank.</p><p>#</p><p># 2) Every single replica computes the time of the last interaction with</p><p>#  its master. This can be the last ping or command received (if the master</p><p>#  is still in the “connected” state), or the time that elapsed since the</p><p>#  disconnection with the master (if the replication link is currently down).</p><p>#  If the last interaction is too old, the replica will not try to failover</p><p>#  at all.</p><p>#</p><p># The point “2” can be tuned by user. Specifically a replica will not perform</p><p># the failover if, since the last interaction with the master, the time</p><p># elapsed is greater than:</p><p>#</p><p>#  (node-timeout * replica-validity-factor) + repl-ping-replica-period</p><p>#</p><p># So for example if node-timeout is 30 seconds, and the replica-validity-factor</p><p># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</p><p># replica will not try to failover if it was not able to talk with the master</p><p># for longer than 310 seconds.</p><p>#</p><p># A large replica-validity-factor may allow replicas with too old data to failover</p><p># a master, while a too small value may prevent the cluster from being able to</p><p># elect a replica at all.</p><p>#</p><p># For maximum availability, it is possible to set the replica-validity-factor</p><p># to a value of 0, which means, that replicas will always try to failover the</p><p># master regardless of the last time they interacted with the master.</p><p># (However they’ll always try to apply a delay proportional to their</p><p># offset rank).</p><p>#</p><p># Zero is the only value able to guarantee that when all the partitions heal</p><p># the cluster will always be able to continue.</p><p>#</p><p># cluster-replica-validity-factor 10</p><p># Cluster replicas are able to migrate to orphaned masters, that are masters</p><p># that are left without working replicas. This improves the cluster ability</p><p># to resist to failures as otherwise an orphaned master can’t be failed over</p><p># in case of failure if it has no working replicas.</p><p>#</p><p># Replicas migrate to orphaned masters only if there are still at least a</p><p># given number of other working replicas for their old master. This number</p><p># is the “migration barrier”. A migration barrier of 1 means that a replica</p><p># will migrate only if there is at least 1 other working replica for its master</p><p># and so forth. It usually reflects the number of replicas you want for every</p><p># master in your cluster.</p><p>#</p><p># Default is 1 (replicas migrate only if their masters remain with at least</p><p># one replica). To disable migration just set it to a very large value.</p><p># A value of 0 can be set but is useful only for debugging and dangerous</p><p># in production.</p><p>#</p><p># cluster-migration-barrier 1</p><p># By default Redis Cluster nodes stop accepting queries if they detect there</p><p># is at least an hash slot uncovered (no available node is serving it).</p><p># This way if the cluster is partially down (for example a range of hash slots</p><p># are no longer covered) all the cluster becomes, eventually, unavailable.</p><p># It automatically returns available as soon as all the slots are covered again.</p><p>#</p><p># However sometimes you want the subset of the cluster which is working,</p><p># to continue to accept queries for the part of the key space that is still</p><p># covered. In order to do so, just set the cluster-require-full-coverage</p><p># option to no.</p><p>#</p><p># cluster-require-full-coverage yes</p><p># This option, when set to yes, prevents replicas from trying to failover its</p><p># master during master failures. However the master can still perform a</p><p># manual failover, if forced to do so.</p><p>#</p><p># This is useful in different scenarios, especially in the case of multiple</p><p># data center operations, where we want one side to never be promoted if not</p><p># in the case of a total DC failure.</p><p>#</p><p># cluster-replica-no-failover no</p><p># In order to setup your cluster make sure to read the documentation</p><p># available at <a href="http://redis.io/">http://redis.io</a> web site.</p><p>########################## CLUSTER DOCKER/NAT support ########################</p><p># In certain deployments, Redis Cluster nodes address discovery fails, because</p><p># addresses are NAT-ted or because ports are forwarded (the typical case is</p><p># Docker and other containers).</p><p>#</p><p># In order to make Redis Cluster working in such environments, a static</p><p># configuration where each node knows its public address is needed. The</p><p># following two options are used for this scope, and are:</p><p>#</p><p># * cluster-announce-ip</p><p># * cluster-announce-port</p><p># * cluster-announce-bus-port</p><p>#</p><p># Each instruct the node about its address, client port, and cluster message</p><p># bus port. The information is then published in the header of the bus packets</p><p># so that other nodes will be able to correctly map the address of the node</p><p># publishing the information.</p><p>#</p><p># If the above options are not used, the normal Redis Cluster auto-detection</p><p># will be used instead.</p><p>#</p><p># Note that when remapped, the bus port may not be at the fixed offset of</p><p># clients port + 10000, so you can specify any port and bus-port depending</p><p># on how they get remapped. If the bus-port is not set, a fixed offset of</p><p># 10000 will be used as usually.</p><p>#</p><p># Example:</p><p>#</p><p># cluster-announce-ip 10.1.1.5</p><p># cluster-announce-port 6379</p><p># cluster-announce-bus-port 6380</p><p>################################## SLOW LOG ###################################</p><p># The Redis Slow Log is a system to log queries that exceeded a specified</p><p># execution time. The execution time does not include the I/O operations</p><p># like talking with the client, sending the reply and so forth,</p><p># but just the time needed to actually execute the command (this is the only</p><p># stage of command execution where the thread is blocked and can not serve</p><p># other requests in the meantime).</p><p>#</p><p># You can configure the slow log with two parameters: one tells Redis</p><p># what is the execution time, in microseconds, to exceed in order for the</p><p># command to get logged, and the other parameter is the length of the</p><p># slow log. When a new command is logged the oldest one is removed from the</p><p># queue of logged commands.</p><p># The following time is expressed in microseconds, so 1000000 is equivalent</p><p># to one second. Note that a negative number disables the slow log, while</p><p># a value of zero forces the logging of every command.</p><p>slowlog-log-slower-than 10000</p><p># There is no limit to this length. Just be aware that it will consume memory.</p><p># You can reclaim memory used by the slow log with SLOWLOG RESET.</p><p>slowlog-max-len 128</p><p>################################ LATENCY MONITOR ##############################</p><p># The Redis latency monitoring subsystem samples different operations</p><p># at runtime in order to collect data related to possible sources of</p><p># latency of a Redis instance.</p><p>#</p><p># Via the LATENCY command this information is available to the user that can</p><p># print graphs and obtain reports.</p><p>#</p><p># The system only logs operations that were performed in a time equal or</p><p># greater than the amount of milliseconds specified via the</p><p># latency-monitor-threshold configuration directive. When its value is set</p><p># to zero, the latency monitor is turned off.</p><p>#</p><p># By default latency monitoring is disabled since it is mostly not needed</p><p># if you don’t have latency issues, and collecting data has a performance</p><p># impact, that while very small, can be measured under big load. Latency</p><p># monitoring can easily be enabled at runtime using the command</p><p># “CONFIG SET latency-monitor-threshold <milliseconds>“ if needed.</p><p>latency-monitor-threshold 0</p><p>############################# EVENT NOTIFICATION ##############################</p><p># Redis can notify Pub/Sub clients about events happening in the key space.</p><p># This feature is documented at <a href="http://redis.io/topics/notifications">http://redis.io/topics/notifications</a></p><p>#</p><p># For instance if keyspace events notification is enabled, and a client</p><p># performs a DEL operation on key “foo” stored in the Database 0, two</p><p># messages will be published via Pub/Sub:</p><p>#</p><p># PUBLISH <strong>keyspace@0</strong>:foo del</p><p># PUBLISH <strong>keyevent@0</strong>:del foo</p><p>#</p><p># It is possible to select the events that Redis will notify among a set</p><p># of classes. Every class is identified by a single character:</p><p>#</p><p># K   Keyspace events, published with <strong>keyspace@<db></strong> prefix.</p><p># E   Keyevent events, published with <strong>keyevent@<db></strong> prefix.</p><p># g   Generic commands (non-type specific) like DEL, EXPIRE, RENAME, …</p><p># $   String commands</p><p># l   List commands</p><p># s   Set commands</p><p># h   Hash commands</p><p># z   Sorted set commands</p><p># x   Expired events (events generated every time a key expires)</p><p># e   Evicted events (events generated when a key is evicted for maxmemory)</p><p># A   Alias for g$lshzxe, so that the “AKE” string means all the events.</p><p>#</p><p># The “notify-keyspace-events” takes as argument a string that is composed</p><p># of zero or multiple characters. The empty string means that notifications</p><p># are disabled.</p><p>#</p><p># Example: to enable list and generic events, from the point of view of the</p><p>#      event name, use:</p><p>#</p><p># notify-keyspace-events Elg</p><p>#</p><p># Example 2: to get the stream of the expired keys subscribing to channel</p><p>#       name <strong>keyevent@0</strong>:expired use:</p><p>#</p><p> notify-keyspace-events Ex</p><p>#</p><p># By default all notifications are disabled because most users don’t need</p><p># this feature and the feature has some overhead. Note that if you don’t</p><p># specify at least one of K or E, no events will be delivered.</p><p>#notify-keyspace-events “”</p><p>############################### ADVANCED CONFIG ###############################</p><p># Hashes are encoded using a memory efficient data structure when they have a</p><p># small number of entries, and the biggest entry does not exceed a given</p><p># threshold. These thresholds can be configured using the following directives.</p><p>hash-max-ziplist-entries 512</p><p>hash-max-ziplist-value 64</p><p># Lists are also encoded in a special way to save a lot of space.</p><p># The number of entries allowed per internal list node can be specified</p><p># as a fixed maximum size or a maximum number of elements.</p><p># For a fixed maximum size, use -5 through -1, meaning:</p><p># -5: max size: 64 Kb &lt;– not recommended for normal workloads</p><p># -4: max size: 32 Kb &lt;– not recommended</p><p># -3: max size: 16 Kb &lt;– probably not recommended</p><p># -2: max size: 8 Kb  &lt;– good</p><p># -1: max size: 4 Kb  &lt;– good</p><p># Positive numbers mean store up to <em>exactly</em> that number of elements</p><p># per list node.</p><p># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</p><p># but if your use case is unique, adjust the settings as necessary.</p><p>list-max-ziplist-size -2</p><p># Lists may also be compressed.</p><p># Compress depth is the number of quicklist ziplist nodes from <em>each</em> side of</p><p># the list to <em>exclude</em> from compression. The head and tail of the list</p><p># are always uncompressed for fast push/pop operations. Settings are:</p><p># 0: disable all list compression</p><p># 1: depth 1 means “don’t start compressing until after 1 node into the list,</p><p>#  going from either the head or tail”</p><p>#  So: [head]-&gt;node-&gt;node-&gt;…-&gt;node-&gt;[tail]</p><p>#  [head], [tail] will always be uncompressed; inner nodes will compress.</p><p># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;…-&gt;node-&gt;[prev]-&gt;[tail]</p><p>#  2 here means: don’t compress head or head-&gt;next or tail-&gt;prev or tail,</p><p>#  but compress all nodes between them.</p><p># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;…-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</p><p># etc.</p><p>list-compress-depth 0</p><p># Sets have a special encoding in just one case: when a set is composed</p><p># of just strings that happen to be integers in radix 10 in the range</p><p># of 64 bit signed integers.</p><p># The following configuration setting sets the limit in the size of the</p><p># set in order to use this special memory saving encoding.</p><p>set-max-intset-entries 512</p><p># Similarly to hashes and lists, sorted sets are also specially encoded in</p><p># order to save a lot of space. This encoding is only used when the length and</p><p># elements of a sorted set are below the following limits:</p><p>zset-max-ziplist-entries 128</p><p>zset-max-ziplist-value 64</p><p># HyperLogLog sparse representation bytes limit. The limit includes the</p><p># 16 bytes header. When an HyperLogLog using the sparse representation crosses</p><p># this limit, it is converted into the dense representation.</p><p>#</p><p># A value greater than 16000 is totally useless, since at that point the</p><p># dense representation is more memory efficient.</p><p>#</p><p># The suggested value is ~ 3000 in order to have the benefits of</p><p># the space efficient encoding without slowing down too much PFADD,</p><p># which is O(N) with the sparse encoding. The value can be raised to</p><p># ~ 10000 when CPU is not a concern, but space is, and the data set is</p><p># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</p><p>hll-sparse-max-bytes 3000</p><p># Streams macro node max size / items. The stream data structure is a radix</p><p># tree of big nodes that encode multiple items inside. Using this configuration</p><p># it is possible to configure how big a single node can be in bytes, and the</p><p># maximum number of items it may contain before switching to a new node when</p><p># appending new stream entries. If any of the following settings are set to</p><p># zero, the limit is ignored, so for instance it is possible to set just a</p><p># max entires limit by setting max-bytes to 0 and max-entries to the desired</p><p># value.</p><p>stream-node-max-bytes 4096</p><p>stream-node-max-entries 100</p><p># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</p><p># order to help rehashing the main Redis hash table (the one mapping top-level</p><p># keys to values). The hash table implementation Redis uses (see dict.c)</p><p># performs a lazy rehashing: the more operation you run into a hash table</p><p># that is rehashing, the more rehashing “steps” are performed, so if the</p><p># server is idle the rehashing is never complete and some more memory is used</p><p># by the hash table.</p><p>#</p><p># The default is to use this millisecond 10 times every second in order to</p><p># actively rehash the main dictionaries, freeing memory when possible.</p><p>#</p><p># If unsure:</p><p># use “activerehashing no” if you have hard latency requirements and it is</p><p># not a good thing in your environment that Redis can reply from time to time</p><p># to queries with 2 milliseconds delay.</p><p>#</p><p># use “activerehashing yes” if you don’t have such hard requirements but</p><p># want to free memory asap when possible.</p><p>activerehashing yes</p><p># The client output buffer limits can be used to force disconnection of clients</p><p># that are not reading data from the server fast enough for some reason (a</p><p># common reason is that a Pub/Sub client can’t consume messages as fast as the</p><p># publisher can produce them).</p><p>#</p><p># The limit can be set differently for the three different classes of clients:</p><p>#</p><p># normal -&gt; normal clients including MONITOR clients</p><p># replica -&gt; replica clients</p><p># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</p><p>#</p><p># The syntax of every client-output-buffer-limit directive is the following:</p><p>#</p><p># client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds></p><p>#</p><p># A client is immediately disconnected once the hard limit is reached, or if</p><p># the soft limit is reached and remains reached for the specified number of</p><p># seconds (continuously).</p><p># So for instance if the hard limit is 32 megabytes and the soft limit is</p><p># 16 megabytes / 10 seconds, the client will get disconnected immediately</p><p># if the size of the output buffers reach 32 megabytes, but will also get</p><p># disconnected if the client reaches 16 megabytes and continuously overcomes</p><p># the limit for 10 seconds.</p><p>#</p><p># By default normal clients are not limited because they don’t receive data</p><p># without asking (in a push way), but just after a request, so only</p><p># asynchronous clients may create a scenario where data is requested faster</p><p># than it can read.</p><p>#</p><p># Instead there is a default limit for pubsub and replica clients, since</p><p># subscribers and replicas receive data in a push fashion.</p><p>#</p><p># Both the hard or the soft limit can be disabled by setting them to zero.</p><p>client-output-buffer-limit normal 0 0 0</p><p>client-output-buffer-limit replica 256mb 64mb 60</p><p>client-output-buffer-limit pubsub 32mb 8mb 60</p><p># Client query buffers accumulate new commands. They are limited to a fixed</p><p># amount by default in order to avoid that a protocol desynchronization (for</p><p># instance due to a bug in the client) will lead to unbound memory usage in</p><p># the query buffer. However you can configure it here if you have very special</p><p># needs, such us huge multi/exec requests or alike.</p><p>#</p><p># client-query-buffer-limit 1gb</p><p># In the Redis protocol, bulk requests, that are, elements representing single</p><p># strings, are normally limited ot 512 mb. However you can change this limit</p><p># here.</p><p>#</p><p># proto-max-bulk-len 512mb</p><p># Redis calls an internal function to perform many background tasks, like</p><p># closing connections of clients in timeout, purging expired keys that are</p><p># never requested, and so forth.</p><p>#</p><p># Not all tasks are performed with the same frequency, but Redis checks for</p><p># tasks to perform according to the specified “hz” value.</p><p>#</p><p># By default “hz” is set to 10. Raising the value will use more CPU when</p><p># Redis is idle, but at the same time will make Redis more responsive when</p><p># there are many keys expiring at the same time, and timeouts may be</p><p># handled with more precision.</p><p>#</p><p># The range is between 1 and 500, however a value over 100 is usually not</p><p># a good idea. Most users should use the default of 10 and raise this up to</p><p># 100 only in environments where very low latency is required.</p><p>hz 10</p><p># Normally it is useful to have an HZ value which is proportional to the</p><p># number of clients connected. This is useful in order, for instance, to</p><p># avoid too many clients are processed for each background task invocation</p><p># in order to avoid latency spikes.</p><p>#</p><p># Since the default HZ value by default is conservatively set to 10, Redis</p><p># offers, and enables by default, the ability to use an adaptive HZ value</p><p># which will temporary raise when there are many connected clients.</p><p>#</p><p># When dynamic HZ is enabled, the actual configured HZ will be used as</p><p># as a baseline, but multiples of the configured HZ value will be actually</p><p># used as needed once more clients are connected. In this way an idle</p><p># instance will use very little CPU time while a busy instance will be</p><p># more responsive.</p><p>dynamic-hz yes</p><p># When a child rewrites the AOF file, if the following option is enabled</p><p># the file will be fsync-ed every 32 MB of data generated. This is useful</p><p># in order to commit the file to the disk more incrementally and avoid</p><p># big latency spikes.</p><p>aof-rewrite-incremental-fsync yes</p><p># When redis saves RDB file, if the following option is enabled</p><p># the file will be fsync-ed every 32 MB of data generated. This is useful</p><p># in order to commit the file to the disk more incrementally and avoid</p><p># big latency spikes.</p><p>rdb-save-incremental-fsync yes</p><p># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</p><p># idea to start with the default settings and only change them after investigating</p><p># how to improve the performances and how the keys LFU change over time, which</p><p># is possible to inspect via the OBJECT FREQ command.</p><p>#</p><p># There are two tunable parameters in the Redis LFU implementation: the</p><p># counter logarithm factor and the counter decay time. It is important to</p><p># understand what the two parameters mean before changing them.</p><p>#</p><p># The LFU counter is just 8 bits per key, it’s maximum value is 255, so Redis</p><p># uses a probabilistic increment with logarithmic behavior. Given the value</p><p># of the old counter, when a key is accessed, the counter is incremented in</p><p># this way:</p><p>#</p><p># 1. A random number R between 0 and 1 is extracted.</p><p># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</p><p># 3. The counter is incremented only if R &lt; P.</p><p>#</p><p># The default lfu-log-factor is 10. This is a table of how the frequency</p><p># counter changes with a different number of accesses with different</p><p># logarithmic factors:</p><p>#</p><p># +——–+————+————+————+————+————+</p><p># | factor | 100 hits  | 1000 hits | 100K hits | 1M hits   | 10M hits  |</p><p># +——–+————+————+————+————+————+</p><p># | 0   | 104     | 255    | 255     | 255     | 255    |</p><p># +——–+————+————+————+————+————+</p><p># | 1   | 18     | 49     | 255    | 255     | 255     |</p><p># +——–+————+————+————+————+————+</p><p># | 10   | 10     | 18     | 142    | 255     | 255     |</p><p># +——–+————+————+————+————+————+</p><p># | 100  | 8      | 11     | 49     | 143    | 255     |</p><p># +——–+————+————+————+————+————+</p><p>#</p><p># NOTE: The above table was obtained by running the following commands:</p><p>#</p><p>#  redis-benchmark -n 1000000 incr foo</p><p>#  redis-cli object freq foo</p><p>#</p><p># NOTE 2: The counter initial value is 5 in order to give new objects a chance</p><p># to accumulate hits.</p><p>#</p><p># The counter decay time is the time, in minutes, that must elapse in order</p><p># for the key counter to be divided by two (or decremented if it has a value</p><p># less &lt;= 10).</p><p>#</p><p># The default value for the lfu-decay-time is 1. A Special value of 0 means to</p><p># decay the counter every time it happens to be scanned.</p><p>#</p><p># lfu-log-factor 10</p><p># lfu-decay-time 1</p><p>########################### ACTIVE DEFRAGMENTATION #######################</p><p>#</p><p># WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested</p><p># even in production and manually tested by multiple engineers for some</p><p># time.</p><p>#</p><p># What is active defragmentation?</p><p># ——————————-</p><p>#</p><p># Active (online) defragmentation allows a Redis server to compact the</p><p># spaces left between small allocations and deallocations of data in memory,</p><p># thus allowing to reclaim back memory.</p><p>#</p><p># Fragmentation is a natural process that happens with every allocator (but</p><p># less so with Jemalloc, fortunately) and certain workloads. Normally a server</p><p># restart is needed in order to lower the fragmentation, or at least to flush</p><p># away all the data and create it again. However thanks to this feature</p><p># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</p><p># in an “hot” way, while the server is running.</p><p>#</p><p># Basically when the fragmentation is over a certain level (see the</p><p># configuration options below) Redis will start to create new copies of the</p><p># values in contiguous memory regions by exploiting certain specific Jemalloc</p><p># features (in order to understand if an allocation is causing fragmentation</p><p># and to allocate it in a better place), and at the same time, will release the</p><p># old copies of the data. This process, repeated incrementally for all the keys</p><p># will cause the fragmentation to drop back to normal values.</p><p>#</p><p># Important things to understand:</p><p>#</p><p># 1. This feature is disabled by default, and only works if you compiled Redis</p><p>#  to use the copy of Jemalloc we ship with the source code of Redis.</p><p>#  This is the default with Linux builds.</p><p>#</p><p># 2. You never need to enable this feature if you don’t have fragmentation</p><p>#  issues.</p><p>#</p><p># 3. Once you experience fragmentation, you can enable this feature when</p><p>#  needed with the command “CONFIG SET activedefrag yes”.</p><p>#</p><p># The configuration parameters are able to fine tune the behavior of the</p><p># defragmentation process. If you are not sure about what they mean it is</p><p># a good idea to leave the defaults untouched.</p><p># Enabled active defragmentation</p><p># activedefrag yes</p><p># Minimum amount of fragmentation waste to start active defrag</p><p># active-defrag-ignore-bytes 100mb</p><p># Minimum percentage of fragmentation to start active defrag</p><p># active-defrag-threshold-lower 10</p><p># Maximum percentage of fragmentation at which we use maximum effort</p><p># active-defrag-threshold-upper 100</p><p># Minimal effort for defrag in CPU percentage</p><p># active-defrag-cycle-min 5</p><p># Maximal effort for defrag in CPU percentage</p><p># active-defrag-cycle-max 75</p><p># Maximum number of set/hash/zset/list fields that will be processed from</p><p># the main dictionary scan</p><p># active-defrag-max-scan-fields 1000</p><p>·     使用redis6.0.8镜像创建容器(也叫运行镜像)</p><p>  docker run -p 6379:6379 –name myr3 –privileged=true  -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d  redis:6.0.8 redis-server /etc/redis/redis.conf  </p><p> <img src="https://image.3001.net/images/20220823/16612324588324.jpg" alt="graphic"></p><p>·     测试redis-cli连接上来</p><p><img src="https://image.3001.net/images/20220823/1661232460734.jpg" alt="graphic"></p><p> docker exec -it 运行着Rediis服务的容器ID redis-cli</p><p>·     请证明docker启动使用了我们自己指定的配置文件</p><p>·     修改前</p><p><img src="https://image.3001.net/images/20220823/16612324649301.jpg" alt="graphic"></p><p>我们用的配置文件，数据库默认是16个</p><p>·     修改后</p><p><img src="https://image.3001.net/images/20220823/16612324665522.jpg" alt="graphic"></p><p>宿主机的修改会同步给docker容器里面的配置。</p><p>·     记得重启服务</p><p>·     测试redis-cli连接上来第2次</p><p><img src="https://image.3001.net/images/20220823/16612324691879.jpg" alt="graphic"></p><h4 id="1-8-5-安装Nginx"><a href="#1-8-5-安装Nginx" class="headerlink" title="1.8.5.  安装Nginx"></a><strong>1.8.5.</strong>  <strong>安装Nginx</strong></h4><p>·     见高级篇Portainer</p><h2 id="2-高级篇-大厂进阶"><a href="#2-高级篇-大厂进阶" class="headerlink" title="2.      高级篇(大厂进阶)"></a>2.      高级篇(大厂进阶)</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image335.jpg" alt="img"></td></tr></tbody></table><h3 id="2-1-Docker复杂安装详说"><a href="#2-1-Docker复杂安装详说" class="headerlink" title="2.1.      Docker复杂安装详说"></a>2.1.      Docker复杂安装详说</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image337.jpg" alt="img"></td></tr></tbody></table><h4 id="2-1-1-安装mysql主从复制"><a href="#2-1-1-安装mysql主从复制" class="headerlink" title="2.1.1.       安装mysql主从复制"></a><strong>2.1.1.</strong>       <strong>安装mysql主从复制</strong></h4><p>·     主从复制原理</p><p>·     默认你懂</p><p>·     主从搭建步骤</p><p>·     新建主服务器容器实例3307</p><p>docker run -p 3307:3306 –name mysql-master \</p><p>-v /mydata/mysql-master/log:/var/log/mysql \</p><p>-v /mydata/mysql-master/data:/var/lib/mysql \</p><p>-v /mydata/mysql-master/conf:/etc/mysql \</p><p>-e MYSQL_ROOT_PASSWORD=root \</p><p>-d mysql:5.7</p><p>·     进入/mydata/mysql-master/conf目录下新建my.cnf</p><p>·     vim my.cnf</p><p>[mysqld]</p><p>## 设置server_id，同一局域网中需要唯一</p><p>server_id=101 </p><p>## 指定不需要同步的数据库名称</p><p>binlog-ignore-db=mysql  </p><p>## 开启二进制日志功能</p><p>log-bin=mall-mysql-bin  </p><p>## 设置二进制日志使用内存大小（事务）</p><p>binlog_cache_size=1M  </p><p>## 设置使用的二进制日志格式（mixed,statement,row）</p><p>binlog_format=mixed  </p><p>## 二进制日志过期清理时间。默认值为0，表示不自动清理。</p><p>expire_logs_days=7  </p><p>## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</p><p>## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</p><p>slave_skip_errors=1062</p><p>·     修改完配置后重启master实例</p><p>·     docker restart mysql-master</p><p>·     进入mysql-master容器</p><p>·     docker exec -it mysql-master /bin/bash</p><p>·     mysql -uroot -proot</p><p>·     master容器实例内创建数据同步用户</p><p>·     CREATE USER ‘slave‘@’%’ IDENTIFIED BY ‘123456’;</p><p>·     GRANT REPLICATION SLAVE, REPLICATION CLIENT ON <em>.</em> TO ‘slave‘@’%’;</p><p>·     新建从服务器容器实例3308</p><p>docker run -p 3308:3306 –name mysql-slave \</p><p>-v /mydata/mysql-slave/log:/var/log/mysql \</p><p>-v /mydata/mysql-slave/data:/var/lib/mysql \</p><p>-v /mydata/mysql-slave/conf:/etc/mysql \</p><p>-e MYSQL_ROOT_PASSWORD=root \</p><p>-d mysql:5.7</p><p>·     进入/mydata/mysql-slave/conf目录下新建my.cnf</p><p>·     vim my.cnf</p><p>[mysqld]</p><p>## 设置server_id，同一局域网中需要唯一</p><p>server_id=102</p><p>## 指定不需要同步的数据库名称</p><p>binlog-ignore-db=mysql  </p><p>## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</p><p>log-bin=mall-mysql-slave1-bin  </p><p>## 设置二进制日志使用内存大小（事务）</p><p>binlog_cache_size=1M  </p><p>## 设置使用的二进制日志格式（mixed,statement,row）</p><p>binlog_format=mixed  </p><p>## 二进制日志过期清理时间。默认值为0，表示不自动清理。</p><p>expire_logs_days=7  </p><p>## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</p><p>## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</p><p>slave_skip_errors=1062  </p><p>## relay_log配置中继日志</p><p>relay_log=mall-mysql-relay-bin  </p><p>## log_slave_updates表示slave将复制事件写进自己的二进制日志</p><p>log_slave_updates=1  </p><p>## slave设置为只读（具有super权限的用户除外）</p><p>read_only=1</p><p>·     修改完配置后重启slave实例</p><p>·     docker restart mysql-slave</p><p>·     在主数据库中查看主从同步状态</p><p>·     show master status;</p><p>·     进入mysql-slave容器</p><p>·     docker exec -it mysql-slave /bin/bash</p><p>·     mysql -uroot -proot</p><p>·     在从数据库中配置主从复制</p><p>  change master to master_host=’宿主机ip’, master_user=’slave’, master_password=’123456’,  master_port=3307, master_log_file=’mall-mysql-bin.000001’,  master_log_pos=617, master_connect_retry=30;  </p><p> <img src="https://image.3001.net/images/20220823/16612324766174.jpg" alt="graphic"></p><p>·     主从复制命令参数说明</p><p>master_host：主数据库的IP地址；</p><p>master_port：主数据库的运行端口；</p><p>master_user：在主数据库创建的用于同步数据的用户账号；</p><p>master_password：在主数据库创建的用于同步数据的用户密码；</p><p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</p><p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</p><p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p><p><img src="https://image.3001.net/images/20220823/16612324782357.gif" alt="graphic"></p><p>·     在从数据库中查看主从同步状态</p><p>·     show slave status \G;</p><p><img src="https://image.3001.net/images/20220823/16612324806793.gif" alt="graphic"></p><p>·     在从数据库中开启主从同步</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image344.jpg" alt="img"></td></tr></tbody></table><p>·     查看从数据库状态发现已经同步</p><p><img src="https://image.3001.net/images/20220823/16612324824175.jpg" alt="graphic"></p><p>·     主从复制测试</p><p>·     主机新建库-使用库-新建表-插入数据，ok</p><p>·     从机使用库-查看记录，ok</p><h4 id="2-1-2-安装redis集群-大厂面试题第4季-分布式存储案例真题"><a href="#2-1-2-安装redis集群-大厂面试题第4季-分布式存储案例真题" class="headerlink" title="2.1.2.       安装redis集群(大厂面试题第4季-分布式存储案例真题)"></a><strong>2.1.2.</strong>       <strong>安装redis集群(大厂面试题第4季-分布式存储案例真题)</strong></h4><p>·     cluster(集群)模式-docker版 哈希槽分区进行亿级数据存储</p><p>·     面试题</p><p>·     1~2亿条数据需要缓存，请问如何设计这个存储案例</p><p>·     回答</p><p>·     单机单台100%不可能，肯定是分布式存储，用redis如何落地？</p><p>·     上述问题阿里P6~P7工程案例和场景设计类必考题目， 一般业界有3种解决方案</p><p>·     哈希取余分区</p><p><img src="https://image.3001.net/images/20220823/16612324857578.gif" alt="graphic"></p><table><thead><tr><th>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：  hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</th></tr></thead><tbody><tr><td>优点：   简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</td></tr><tr><td>缺点：    原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)/3会变成Hash(key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。  某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</td></tr></tbody></table><p>·     缺点那？？？</p><p><img src="https://image.3001.net/images/20220823/16612324884854.gif" alt="graphic"></p><table><thead><tr><th></th></tr></thead><tbody><tr><td>缺点：</td></tr><tr><td>原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)/3会变成Hash(key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。  某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</td></tr></tbody></table><p>·     一致性哈希算法分区</p><p>·     是什么</p><p>一致性Hash算法背景</p><p>　　一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决</p><p>分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不OK了。</p><p>·     能干嘛</p><p>·     提出一致性Hash解决方案。 目的是当服务器个数发生变动时， 尽量减少影响客户端到服务器的映射关系</p><p>·     <strong>3大步骤</strong></p><p>·     算法构建一致性哈希环</p><p>一致性哈希环</p><p>  一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 = 2^32),这样让它逻辑上形成了一个环形空间。</p><p>  它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p><p><img src="https://image.3001.net/images/20220823/16612324932440.jpg" alt="graphic"></p><p>·     服务器IP节点映射</p><p>节点映射</p><p>  将集群中各个IP节点映射到环上的某一个位置。</p><p>  将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下： </p><p><img src="https://image.3001.net/images/20220823/16612324952344.jpg" alt="graphic"></p><p>·     key落到服务器的落键规则</p><p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针<strong><strong>“</strong></strong>行走****”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p><p>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p><p><img src="https://image.3001.net/images/20220823/16612324977386.jpg" alt="graphic"></p><p>·     优点</p><p>·     一致性哈希算法的容错性</p><p><strong>容错性</strong></p><p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p><p><img src="https://image.3001.net/images/20220823/1661232500557.jpg" alt="graphic"></p><p>·     一致性哈希算法的<strong>扩展性</strong></p><p> 扩展性</p><p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，</p><p>不会导致hash取余全部数据重新洗牌。</p><p><img src="https://image.3001.net/images/20220823/16612325037548.jpg" alt="graphic"></p><p>·     缺点</p><p>·     一致性哈希算法的数据倾斜问题</p><p>Hash环的数据倾斜问题</p><p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p><p>例如系统中只有两台服务器：</p><p> <img src="https://image.3001.net/images/20220823/16612325069585.jpg" alt="graphic"></p><p>·     小总结</p><p>为了在节点数目发生改变时尽可能少的迁移数据</p><p>将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。</p><p>而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。 </p><p>优点</p><p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p><p>缺点 </p><p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p><p>·     哈希槽分区</p><p>·     是什么</p><p>1 为什么出现</p><p><img src="https://image.3001.net/images/20220823/1661232508775.jpg" alt="graphic"></p><p>哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。</p><p>2 能干什么</p><p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p><p><img src="https://image.3001.net/images/20220823/16612325105343.jpg" alt="graphic"></p><p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p><p>哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p><p>3 多少个hash槽</p><p>一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot = CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p><p>·     哈希槽计算</p><p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上</p><p><img src="https://image.3001.net/images/20220823/16612325122917.jpg" alt="graphic"><img src="https://image.3001.net/images/20220823/16612325142536.jpg" alt="graphic"></p><p>·     3主3从redis集群扩缩容配置案例架构说明</p><p>·     见自己的processon笔记</p><p>·     开打步骤</p><p>·     3主3从redis集群配置</p><p>·     关闭防火墙+启动docker后台服务</p><p><img src="https://image.3001.net/images/20220823/16612325184155.jpg" alt="graphic"></p><p>·     systemctl start docker</p><p>·     新建6个docker容器redis实例</p><p>docker run -d –name redis-node-1 –net host –privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 –cluster-enabled yes –appendonly yes –port 6381</p><p>docker run -d –name redis-node-2 –net host –privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 –cluster-enabled yes –appendonly yes –port 6382</p><p>docker run -d –name redis-node-3 –net host –privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 –cluster-enabled yes –appendonly yes –port 6383</p><p>docker run -d –name redis-node-4 –net host –privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 –cluster-enabled yes –appendonly yes –port 6384</p><p>docker run -d –name redis-node-5 –net host –privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 –cluster-enabled yes –appendonly yes –port 6385</p><p>docker run -d –name redis-node-6 –net host –privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 –cluster-enabled yes –appendonly yes –port 6386</p><p><strong>如果运行成功，效果如下：</strong></p><p><img src="https://image.3001.net/images/20220823/16612325228128.jpg" alt="graphic"></p><p>·     命令分步解释</p><p>·     docker run</p><p>·     创建并运行docker容器实例</p><p>·     –name redis-node-6</p><p>·     容器名字</p><p>·     –net host</p><p>·     使用宿主机的IP和端口，默认</p><p>·     –privileged=true</p><p>·     获取宿主机root用户权限</p><p>·     -v /data/redis/share/redis-node-6:/data</p><p>·     容器卷，宿主机地址:docker内部地址</p><p>·     redis:6.0.8</p><p>·     redis镜像和版本号</p><p>·     –cluster-enabled yes</p><p>·     开启redis集群</p><p>·     –appendonly yes</p><p>·     开启持久化</p><p>·     –port 6386</p><p>·     redis端口号</p><p>·     进入容器redis-node-1并为6台机器构建集群关系</p><p>·     进入容器</p><p>·    docker exec -it redis-node-1 /bin/bash</p><p>·     构建主从关系</p><p>//注意，进入docker容器后才能执行一下命令，且注意自己的真实IP地址</p><p>  redis-cli –cluster create 192.168.111.147:6381  192.168.111.147:6382 192.168.111.147:6383 192.168.111.147:6384  192.168.111.147:6385 192.168.111.147:6386 –cluster-replicas 1  </p><p>–cluster-replicas 1 表示为每个master创建一个slave节点</p><p><img src="https://image.3001.net/images/20220823/16612325542903.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612325524352.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612325595281.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612325657054.jpg" alt="graphic"></p><p>·     一切OK的话，3主3从搞定</p><p>·     链接进入6381作为切入点，查看集群状态</p><p>·     链接进入6381作为切入点，查看节点状态</p><p> <img src="https://image.3001.net/images/20220823/16612326622902.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327074605.jpg" alt="graphic"></p><p>·     cluster info</p><p>·     cluster nodes</p><p>·     主从容错切换迁移案例</p><p>·     数据读写存储</p><p>·     启动6机构成的集群并通过exec进入</p><p>·     对6381新增两个key</p><p>·     防止路由失效加参数-c并新增两个key</p><p><img src="https://image.3001.net/images/20220823/16612327091291.jpg" alt="graphic"></p><p>加入参数-c，优化路由</p><p><img src="https://image.3001.net/images/20220823/16612327113276.jpg" alt="graphic"></p><p>·     查看集群信息</p><p>  redis-cli –cluster check 192.168.111.147:6381  </p><p><img src="https://image.3001.net/images/20220823/16612327148600.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327164157.jpg" alt="graphic"></p><p>·     容错切换迁移</p><p>·     主6381和从机切换，先停止主机6381</p><p>·     6381主机停了，对应的真实从机上位</p><p>·     6381作为1号主机分配的从机以实际情况为准，具体是几号机器就是几号</p><p>·     再次查看集群信息</p><p><img src="https://image.3001.net/images/20220823/16612327195335.jpg" alt="graphic"></p><p>6381宕机了，6385上位成为了新的master。</p><p>备注：本次脑图笔记6381为主下面挂从6385。</p><p>每次案例下面挂的从机以实际情况为准，具体是几号机器就是几号</p><p>·     先还原之前的3主3从</p><p><img src="https://image.3001.net/images/20220823/16612327212109.jpg" alt="graphic"></p><p>中间需要等待一会儿，docker集群重新响应。</p><p>·     先启6381</p><p><img src="https://image.3001.net/images/20220823/16612327237049.jpg" alt="graphic"></p><p>·     docker start redis-node-1</p><p>·     再停6385</p><p><img src="https://image.3001.net/images/20220823/16612327259337.jpg" alt="graphic"></p><p>·     docker stop redis-node-5</p><p>·     再启6385</p><p><img src="https://image.3001.net/images/20220823/16612327274606.jpg" alt="graphic"></p><p>·     docker start redis-node-5</p><p>·     主从机器分配情况以实际情况为准</p><p>·     查看集群状态</p><p>·     redis-cli –cluster check 自己IP:6381</p><p><img src="https://image.3001.net/images/20220823/16612327296984.jpg" alt="graphic"></p><p>·     主从扩容案例</p><p>·     新建6387、6388两个节点+新建后启动+查看是否8节点</p><table><thead><tr><th>docker run -d –name redis-node-7 –net host  –privileged=true -v /data/redis/share/redis-node-7:/data redis:6.0.8  –cluster-enabled yes –appendonly yes –port 6387</th></tr></thead><tbody><tr><td>docker run -d –name redis-node-8 –net host  –privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8  –cluster-enabled yes –appendonly yes –port 6388</td></tr><tr><td>docker ps</td></tr></tbody></table><p>·     进入6387容器实例内部</p><p>·     docker exec -it redis-node-7 /bin/bash</p><p>·     将新增的6387节点(空槽号)作为master节点加入原集群</p><p>  将新增的6387作为master节点加入集群  redis-cli –cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381  6387 就是将要作为master新增节点  6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群  </p><p><img src="https://image.3001.net/images/20220823/16612327623355.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327641505.jpg" alt="graphic"></p><p>·     检查集群情况第1次</p><p>  redis-cli –cluster check 真实ip地址:6381  </p><p><img src="https://image.3001.net/images/20220823/16612327668490.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327686681.jpg" alt="graphic"></p><p>·     重新分派槽号</p><p>  重新分派槽号  命令:redis-cli –cluster <strong>reshard</strong> IP地址:端口号  redis-cli –cluster reshard  192.168.111.147:6381  </p><p><img src="https://image.3001.net/images/20220823/16612327717948.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327732687.jpg" alt="graphic"></p><p>·     检查集群情况第2次</p><p>  redis-cli –cluster check 真实ip地址:6381  </p><p><img src="https://image.3001.net/images/20220823/16612327778232.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327791516.jpg" alt="graphic"></p><p>·     槽号分派说明</p><p>  为什么6387是3个新的区间，以前的还是连续？  重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387  </p><p><img src="https://image.3001.net/images/20220823/16612327828159.jpg" alt="graphic"></p><p>·     为主节点6387分配从节点6388</p><p>  命令：redis-cli –cluster add-node ip:新slave端口 ip:新master端口 –cluster-slave –cluster-master-id 新主机节点ID     redis-cli –cluster add-node 192.168.111.147:6388  192.168.111.147:6387 –cluster-slave –cluster-master-id  e4781f644d4a4e4d4b4d107157b9ba8144631451——-这个是6387的编号，按照自己实际情况  </p><p><img src="https://image.3001.net/images/20220823/16612327917968.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327934886.jpg" alt="graphic"></p><p>·     检查集群情况第3次</p><p>  redis-cli –cluster check 192.168.111.147:6382  </p><p><img src="https://image.3001.net/images/20220823/1661232795736.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612327984619.jpg" alt="graphic"></p><p>·     主从缩容案例</p><p>·     目的：6387和6388下线</p><p>·     检查集群情况1获得6388的节点ID</p><p>  redis-cli –cluster check 192.168.111.147:6382  </p><p><img src="https://image.3001.net/images/20220823/16612328008590.jpg" alt="graphic"></p><p>·     将6388删除 从集群中将4号从节点6388删除</p><p>  命令：redis-cli –cluster del-node ip:从机端口 从机6388节点ID     redis-cli –cluster del-node 192.168.111.147:6388  5d149074b7e57b802287d1797a874ed7a1a284a8  </p><p><img src="https://image.3001.net/images/20220823/16612328036764.jpg" alt="graphic"></p><p>  redis-cli –cluster check 192.168.111.147:6382  </p><p> 检查一下发现，6388被删除了，只剩下7台机器了。</p><p> <img src="https://image.3001.net/images/20220823/16612328058815.jpg" alt="graphic"></p><p>·     将6387的槽号清空，重新分配，本例将清出来的槽号都给6381</p><p>  redis-cli –cluster reshard 192.168.111.147:6381  </p><p> <img src="https://image.3001.net/images/20220823/16612328078415.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612328092118.jpg" alt="graphic"></p><p><img src="./images/clip_image440.jpg" alt="graphic"></p><p>·     检查集群情况第二次</p><p>  redis-cli –cluster check 192.168.111.147:6381     4096个槽位都指给6381，它变成了8192个槽位，相当于全部都给6381了，不然要输入3次，一锅端  </p><p><img src="https://image.3001.net/images/20220823/16612328125878.jpg" alt="graphic"></p><p>·     将6387删除</p><p>  命令：redis-cli –cluster del-node ip:端口 6387节点ID     redis-cli –cluster del-node 192.168.111.147:6387  e4781f644d4a4e4d4b4d107157b9ba8144631451  </p><p><img src="https://image.3001.net/images/20220823/16612328141590.jpg" alt="graphic"></p><p>·     检查集群情况第三次</p><p>  redis-cli –cluster check 192.168.111.147:6381  </p><p> <img src="https://image.3001.net/images/20220823/16612328174463.jpg" alt="graphic"></p><h3 id="2-2-DockerFile解析"><a href="#2-2-DockerFile解析" class="headerlink" title="2.2.      DockerFile解析"></a>2.2.      DockerFile解析</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image448.jpg" alt="img"></td></tr></tbody></table><h4 id="2-2-1-是什么"><a href="#2-2-1-是什么" class="headerlink" title="2.2.1.       是什么"></a><strong>2.2.1.</strong>       <strong>是什么</strong></h4><p>·     Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><p>·     概述</p><p><img src="https://image.3001.net/images/20220823/16612328204507.jpg" alt="graphic"></p><p>·     官网</p><p>·     <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>·     构建三步骤</p><p>·     编写Dockerfile文件</p><p>·     docker build命令构建镜像</p><p>·     docker run依镜像运行容器实例</p><h4 id="2-2-2-DockerFile构建过程解析"><a href="#2-2-2-DockerFile构建过程解析" class="headerlink" title="2.2.2.       DockerFile构建过程解析"></a><strong>2.2.2.</strong>       <strong>DockerFile构建过程解析</strong></h4><p>·     Dockerfile内容基础知识</p><p>·     1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p><p>·     2：指令按照从上到下，顺序执行</p><p>·     3：#表示注释</p><p>·     4：每条指令都会创建一个新的镜像层并对镜像进行提交</p><p>·     Docker执行Dockerfile的大致流程</p><p>·     （1）docker从基础镜像运行一个容器</p><p>·     （2）执行一条指令并对容器作出修改</p><p>·     （3）执行类似docker commit的操作提交一个新的镜像层</p><p>·     （4）docker再基于刚提交的镜像运行一个新容器</p><p>·     （5）执行dockerfile中的下一条指令直到所有指令都执行完成</p><p>·     <strong>小总结</strong></p><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><p>*  Dockerfile是软件的原材料</p><p>*  Docker镜像是软件的交付品</p><p>*  Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</p><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><p><img src="https://image.3001.net/images/20220823/16612328231816.jpg" alt="graphic"></p><p>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p><p>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</p><p>3 Docker容器，容器是直接提供服务的。</p><h4 id="2-2-3-DockerFile常用保留字指令"><a href="#2-2-3-DockerFile常用保留字指令" class="headerlink" title="2.2.3.       DockerFile常用保留字指令"></a><strong>2.2.3.</strong>       <strong>DockerFile常用保留字指令</strong></h4><p>·     参考tomcat8的dockerfile入门</p><p>·     <a href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p><p>·     FROM</p><p>·     基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><p>·     MAINTAINER</p><p>·     镜像维护者的姓名和邮箱地址</p><p>·     RUN</p><p>·     容器构建时需要运行的命令</p><p>·     两种格式</p><p>·     shell格式</p><p><img src="https://image.3001.net/images/20220823/1661232828278.jpg" alt="graphic"></p><p>RUN yum -y install vim</p><p>·     exec格式</p><p><img src="https://image.3001.net/images/20220823/16612328303688.jpg" alt="graphic"></p><p>·     RUN是在 docker build时运行</p><p>·     EXPOSE</p><p>·     当前容器对外暴露出的端口</p><p>·     WORKDIR</p><p>·     指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p><p>·     USER</p><p>·     指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p><p>·     ENV</p><p>·     用来在构建镜像过程中设置环境变量</p><p>ENV MY_PATH /usr/mytest</p><p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</p><p>也可以在其它指令中直接使用这些环境变量，</p><p>比如：WORKDIR $MY_PATH</p><p>·     ADD</p><p>·     将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p><p>·     COPY</p><p>·     类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p><p>·     COPY src dest</p><p>·     COPY [“src”, “dest”]</p><p>·     &lt;src源路径&gt;：源文件或者源目录</p><p>·     &lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><p>·     VOLUME</p><p>·     容器数据卷，用于数据保存和持久化工作</p><p>·     CMD</p><p>·     指定容器启动后的要干的事情</p><p><img src="https://image.3001.net/images/20220823/16612328347000.gif" alt="graphic"></p><p>·     注意</p><p>·     Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p><p>·     参考官网Tomcat的dockerfile演示讲解</p><p>·     官网最后一行命令</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image460.jpg" alt="img"></td></tr></tbody></table><p>·     我们演示自己的覆盖操作</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image462.jpg" alt="img"></td></tr></tbody></table><p>·     它和前面RUN命令的区别</p><p>·     CMD是在docker run 时运行。</p><p>·     RUN是在 docker build时运行。</p><p>·     ENTRYPOINT</p><p>·     也是用来指定一个容器启动时要运行的命令</p><p>·     类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</p><p>·     命令格式和案例说明</p><p>命令格式：<img src="https://image.3001.net/images/20220823/16612328389667.jpg" alt="graphic"></p><p>ENTRYPOINT可以和CMD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p><p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成<img src="https://image.3001.net/images/20220823/16612328409782.jpg" alt="graphic"></p><p>案例如下：假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><p><img src="https://image.3001.net/images/20220823/16612328432270.jpg" alt="graphic"></p><table><thead><tr><th>是否传参</th><th>按照dockerfile编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run nginx:test</td><td>docker run nginx:test -c /etc/nginx/new.conf</td></tr><tr><td>衍生出的实际命令</td><td>nginx -c /etc/nginx/nginx.conf</td><td>nginx -c /etc/nginx/new.conf</td></tr></tbody></table><p>·     优点</p><p>·     在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p>·     注意</p><p>·     如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>·     <strong>小总结</strong></p><p><img src="https://image.3001.net/images/20220823/16612328473459.jpg" alt="graphic"></p><h4 id="2-2-4-案例"><a href="#2-2-4-案例" class="headerlink" title="2.2.4.       案例"></a><strong>2.2.4.</strong>       <strong>案例</strong></h4><p>·     自定义镜像mycentosjava8</p><p>·     要求</p><p>·     Centos7镜像具备vim+ifconfig+jdk8</p><p>·     JDK的下载镜像地址</p><p>·     官网</p><p> 下载地址：</p><p><a href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a></p><p><img src="https://image.3001.net/images/20220823/16612328508628.jpg" alt="graphic"></p><p>·     <a href="https://mirrors.yangxingzhen.com/jdk/">https://mirrors.yangxingzhen.com/jdk/</a></p><p>·     编写</p><p>·     准备编写Dockerfile文件</p><p><img src="https://image.3001.net/images/20220823/16612328539832.jpg" alt="graphic"></p><p>  FROM centos  MAINTAINER zzyy<a href="mailto:&#122;&#x7a;&#121;&#121;&#98;&#115;&#64;&#x31;&#50;&#x36;&#x2e;&#x63;&#111;&#x6d;">&#122;&#x7a;&#121;&#121;&#98;&#115;&#64;&#x31;&#50;&#x36;&#x2e;&#x63;&#111;&#x6d;</a>     ENV MYPATH /usr/local  WORKDIR $MYPATH     #安装vim编辑器  RUN yum -y install vim  #安装ifconfig命令查看网络IP  RUN yum -y install net-tools  #安装java8及lib库  RUN yum -y install glibc.i686  RUN mkdir /usr/local/java  #ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置  ADD jdk-8u171-linux-x64.tar.gz  /usr/local/java/  #配置java环境变量  ENV JAVA_HOME /usr/local/java/jdk1.8.0_171  ENV JRE_HOME $JAVA_HOME/jre  ENV CLASSPATH  $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH  ENV PATH $JAVA_HOME/bin:$PATH     EXPOSE 80     CMD echo $MYPATH  CMD echo “success————–ok”  CMD /bin/bash  </p><p>·     大写字母D</p><p>·     构建</p><p>·     docker build -t 新镜像名字:TAG .</p><p>docker build -t centosjava8:1.5 .</p><p> <img src="https://image.3001.net/images/20220823/16612328556582.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612328587727.jpg" alt="graphic"></p><p>·     注意，上面TAG后面有个空格，有个点</p><p>·     运行</p><p>·     docker run -it 新镜像名字:TAG</p><p> docker run -it centosjava8:1.5 /bin/bash</p><p><img src="https://image.3001.net/images/20220823/16612328601319.jpg" alt="graphic"></p><p>·     再体会下UnionFS（联合文件系统）</p><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><img src="https://image.3001.net/images/20220823/16612328637768.jpg" alt="graphic"> </p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><p>·     虚悬镜像</p><p>·     是什么</p><p>·     仓库名、标签都是<none>的镜像，俗称dangling image</p><p>·     Dockerfile写一个</p><p>1 vim Dockerfile</p><p>  from ubuntu  CMD echo ‘action is success’  </p><p>2 docker build .</p><p><img src="https://image.3001.net/images/20220823/16612328685005.jpg" alt="graphic"></p><p>·     查看</p><p>·     docker image ls -f dangling=true</p><p>·     命令结果</p><p><img src="https://image.3001.net/images/20220823/16612328705976.jpg" alt="graphic"></p><p>·     删除</p><p>docker image prune</p><p>虚悬镜像已经失去存在价值，可以删除</p><p><img src="https://image.3001.net/images/20220823/16612328727140.jpg" alt="graphic"></p><p>·     家庭作业-自定义镜像myubuntu</p><p>·     编写</p><p>·     准备编写DockerFile文件</p><p><img src="https://image.3001.net/images/20220823/1661232874991.jpg" alt="graphic"></p><p>  FROM ubuntu  MAINTAINER zzyy<a href="mailto:&#x7a;&#122;&#x79;&#x79;&#98;&#x73;&#64;&#x31;&#x32;&#54;&#46;&#x63;&#111;&#109;">&#x7a;&#122;&#x79;&#x79;&#98;&#x73;&#64;&#x31;&#x32;&#54;&#46;&#x63;&#111;&#109;</a>     ENV MYPATH /usr/local  WORKDIR $MYPATH     RUN apt-get update  RUN apt-get install net-tools  #RUN apt-get install -y iproute2  #RUN apt-get install -y inetutils-ping     EXPOSE 80     CMD echo $MYPATH  CMD echo “install inconfig cmd into ubuntu  success————–ok”  CMD /bin/bash  </p><p>·     构建</p><p>·     docker build -t 新镜像名字:TAG .</p><p>·     运行</p><p>·     docker run -it 新镜像名字:TAG</p><p><strong>2.2.5.</strong>       <strong>小总结</strong></p><p><img src="https://image.3001.net/images/20220823/16612328769532.jpg" alt="graphic"></p><h3 id="2-3-Docker微服务实战"><a href="#2-3-Docker微服务实战" class="headerlink" title="2.3.      Docker微服务实战"></a>2.3.      Docker微服务实战</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image490.jpg" alt="img"></td></tr></tbody></table><h4 id="2-3-1-通过IDEA新建一个普通微服务模块"><a href="#2-3-1-通过IDEA新建一个普通微服务模块" class="headerlink" title="2.3.1.       通过IDEA新建一个普通微服务模块"></a>2.3.1.       通过IDEA新建一个普通微服务模块</h4><p>·     建Module</p><p>·    docker_boot</p><p>·     改POM</p><?xml version="1.0" encoding="UTF-8"?><p> <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">     <modelVersion>4.0.0</modelVersion>     <parent>         <groupId>org.springframework.boot</groupId>         <artifactId>spring-boot-starter-parent</artifactId>         <version>2.5.6</version>         <relativePath/>     </parent>      <groupId>com.atguigu.docker</groupId>     <artifactId>docker_boot</artifactId>     <version>0.0.1-SNAPSHOT</version>      <properties>         &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;         &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;         &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;         &lt;junit.version&gt;4.12&lt;/junit.version&gt;         &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;         &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;         &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;         &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;         &lt;mapper.version&gt;4.1.5&lt;/mapper.version&gt;         &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt;     </properties>      <dependencies>         <!--SpringBoot通用依赖模块-->         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-web</artifactId>         </dependency>         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-actuator</artifactId>         </dependency>         <!--test-->         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-test</artifactId>             <scope>test</scope>         </dependency>     </dependencies>      <build>         <plugins>             <plugin>                 <groupId>org.springframework.boot</groupId>                 <artifactId>spring-boot-maven-plugin</artifactId>             </plugin>             <plugin>                 <groupId>org.apache.maven.plugins</groupId>                 <artifactId>maven-resources-plugin</artifactId>                 <version>3.1.0</version>             </plugin>         </plugins>     </build>  </project>  </p><p>·     写YML</p><p><strong>server.port</strong>=<strong>6001</strong></p><p>·     主启动</p><p><strong>package</strong> com.atguigu.docker;</p><p> <strong>import</strong> org.springframework.boot.SpringApplication;<br> <strong>import</strong> org.springframework.boot.autoconfigure.SpringBootApplication;</p><p> @SpringBootApplication<br> <strong>public class</strong> DockerBootApplication<br> {<br>   <strong>public static void</strong> main(String[] args)<br>   {<br>     SpringApplication.<em>run</em>(DockerBootApplication.<strong>class</strong>, args);<br>   }</p><p> }</p><p>·     业务类</p><p><strong>package</strong> com.atguigu.docker.controller;</p><p> <strong>import</strong> org.springframework.beans.factory.annotation.Value;<br> <strong>import</strong> org.springframework.web.bind.annotation.RequestMapping;<br> <strong>import</strong> org.springframework.web.bind.annotation.RequestMethod;<br> <strong>import</strong> org.springframework.web.bind.annotation.RestController;</p><p> <strong>import</strong> java.util.UUID;</p><p> <em>/</em>*<br> * <strong>@auther</strong> zzyy<br> * <strong>@create</strong> 2021-10-25 17:43<br> */<br>* @RestController<br> <strong>public class</strong> OrderController<br> {<br>   @Value(<strong>“${server.port}”</strong>)<br>   <strong>private</strong> String <strong>port</strong>;</p><p>   @RequestMapping(<strong>“/order/docker”</strong>)<br>   <strong>public</strong> String helloDocker()<br>   {<br>     <strong>return</strong> <strong>“hello docker”</strong>+<strong>“<strong><strong>\t</strong></strong>“</strong>+<strong>port</strong>+<strong>“<strong><strong>\t</strong></strong>“</strong>+ UUID.<em>randomUUID</em>().toString();<br>   }</p><p>   @RequestMapping(value =<strong>“/order/index”</strong>,method = RequestMethod.<em><strong>GET*</strong>)<br>   <strong>public</strong> String index()<br>   {<br>     <strong>return</strong> <strong>“<strong><strong>服务端口号</strong></strong>: “</strong>+</em>*”<strong><strong>\t</strong></strong>“<strong>+<strong>port</strong>+</strong>“<strong><strong>\t</strong></strong>“**+UUID.<em>randomUUID</em>().toString();<br>   }<br> }</p><p>2.3.2.       通过dockerfile发布微服务部署到docker容器</p><p>·     IDEA工具里面搞定微服务jar包</p><p>docker_boot-0.0.1-SNAPSHOT.jar</p><p><img src="https://image.3001.net/images/20220823/16612328837149.jpg" alt="graphic"></p><p>·     编写Dockerfile</p><p>·     Dockerfile内容</p><p># 基础镜像使用java</p><p>FROM java:8</p><p># 作者</p><p>MAINTAINER zzyy</p><p># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</p><p>VOLUME /tmp</p><p># 将jar包添加到容器中并更名为zzyy_docker.jar</p><p>ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</p><p># 运行jar包</p><p>RUN bash -c ‘touch /zzyy_docker.jar’</p><p>ENTRYPOINT [“java”,”-jar”,”/zzyy_docker.jar”]</p><p>#暴露6001端口作为微服务</p><p>EXPOSE 6001</p><p>·     将微服务jar包和Dockerfile文件上传到同一个目录下/mydocker</p><p><img src="https://image.3001.net/images/20220823/16612328866323.jpg" alt="graphic"></p><p>docker build -t zzyy_docker:1.6 .</p><p>·     构建镜像</p><p><img src="https://image.3001.net/images/20220823/16612328885280.jpg" alt="graphic"></p><p>·     docker build -t zzyy_docker:1.6 .</p><p>·     打包成镜像文件</p><p><img src="https://image.3001.net/images/20220823/16612328902570.jpg" alt="graphic"></p><p>·     运行容器</p><p> docker run -d -p 6001:6001 zzyy_docker:1.6</p><p><img src="https://image.3001.net/images/20220823/1661232894316.jpg" alt="graphic"></p><p>·     访问测试</p><p><img src="https://image.3001.net/images/20220823/16612330467987.jpg" alt="graphic"></p><h3 id="2-4-Docker网络"><a href="#2-4-Docker网络" class="headerlink" title="2.4.      Docker网络"></a>2.4.      Docker网络</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image503.jpg" alt="img"></td></tr></tbody></table><h4 id="2-4-1-是什么"><a href="#2-4-1-是什么" class="headerlink" title="2.4.1.       是什么"></a>2.4.1.       是什么</h4><p>·     docker不启动，默认网络情况</p><p><img src="https://image.3001.net/images/20220823/16612330494712.jpg" alt="graphic"></p><p>·     ens33</p><p>·     lo</p><p>·     virbr0</p><p>在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。</p><p>我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，</p><p>yum remove libvirt-libs.x86_64</p><p>·     docker启动后，网络情况</p><p><strong>会产生一个名为<strong><strong>docker0</strong></strong>的虚拟网桥</strong></p><p><img src="https://image.3001.net/images/20220823/16612330529413.jpg" alt="graphic"></p><p>·     查看docker网络模式命令</p><p>默认创建3大网络模式</p><p><img src="https://image.3001.net/images/20220823/16612330566325.jpg" alt="graphic"></p><h4 id="2-4-2-常用基本命令"><a href="#2-4-2-常用基本命令" class="headerlink" title="2.4.2.       常用基本命令"></a>2.4.2.       常用基本命令</h4><p>·     All命令</p><p><img src="https://image.3001.net/images/20220823/16612330571137.jpg" alt="graphic"></p><p>·     查看网络</p><p>·     docker network ls</p><p>·     查看网络源数据</p><p>·     docker network inspect XXX网络名字</p><p>·     删除网络</p><p>·     docker network rm XXX网络名字</p><p>·     案例</p><p><img src="https://image.3001.net/images/20220823/16612330625999.jpg" alt="graphic"></p><h4 id="2-4-3-能干嘛"><a href="#2-4-3-能干嘛" class="headerlink" title="2.4.3.       能干嘛"></a>2.4.3.       能干嘛</h4><p>·     容器间的互联和通信以及端口映射</p><p>·     容器IP变动时候可以通过服务名直接网络通信而不受到影响</p><h4 id="2-4-4-网络模式"><a href="#2-4-4-网络模式" class="headerlink" title="2.4.4.  网络模式"></a><strong>2.4.4.</strong>  <strong>网络模式</strong></h4><p>·     总体介绍</p><p><img src="./images/clip_image515.jpg" alt="graphic"></p><p>·     bridge模式：使用–network bridge指定，默认使用docker0</p><p>·     host模式：使用–network host指定</p><p>·     none模式：使用–network none指定</p><p>·     container模式：使用–network container:NAME或者容器ID指定</p><p>·     容器实例内默认网络IP生产规则</p><p>·     说明</p><p>1 先启动两个ubuntu容器实例</p><p><img src="https://image.3001.net/images/20220823/16612330691145.jpg" alt="graphic"></p><p>2 docker inspect 容器ID or 容器名字</p><p> <img src="https://image.3001.net/images/20220823/16612330718558.jpg" alt="graphic"></p><p>3 关闭u2实例，新建u3，查看ip变化</p><p><img src="https://image.3001.net/images/20220823/16612330728121.jpg" alt="graphic"></p><p>·     结论</p><p>·     docker容器内部的ip是有可能会发生改变的</p><p>·     <strong>案例说明</strong></p><p>·     bridge</p><p>·     是什么</p><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p><p># 查看 bridge 网络的详细信息，并通过 grep 获取名称项</p><p>docker network inspect bridge | grep name</p><p><img src="https://image.3001.net/images/20220823/16612330768668.jpg" alt="graphic"></p><p>ifconfig</p><p><img src="https://image.3001.net/images/20220823/16612330782279.jpg" alt="graphic"></p><p>·     案例</p><p>·     说明</p><p>1 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p><p>2 docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</p><p>3 网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。</p><p>  3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</p><p>  3.2 每个容器实例内部也有一块网卡，每个接口叫eth0；</p><p>  3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</p><p> 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p><p><img src="https://image.3001.net/images/20220823/16612330821268.jpg" alt="graphic"></p><p>·     代码</p><p>·     docker run -d -p 8081:8080  –name tomcat81 billygoo/tomcat8-jdk8</p><p>·     docker run -d -p 8082:8080  –name tomcat82 billygoo/tomcat8-jdk8</p><p>·     两两匹配验证</p><p><img src="https://image.3001.net/images/20220823/16612330845158.jpg" alt="graphic"></p><p>·     host</p><p>·     是什么</p><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p><p>·     案例</p><p>·     说明</p><p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p><p><img src="https://image.3001.net/images/20220823/16612330862395.jpg" alt="graphic"></p><p>·     代码</p><p>·     警告</p><p>·     docker run -d -p 8083:8080 –network host –name tomcat83 billygoo/tomcat8-jdk8</p><p><img src="https://image.3001.net/images/20220823/16612330909874.jpg" alt="graphic"></p><p>问题：</p><p>   docke启动时总是遇见标题中的警告</p><p>原因：</p><p>  docker启动时指定–network=host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告，</p><p>并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</p><p>解决:</p><p>  解决的办法就是使用docker的其他网络模式，例如–network=bridge，这样就可以解决问题，或者直接无视。。。。O(∩_∩)O哈哈~</p><p>·     正确</p><p>·     docker run -d             –network host –name tomcat83 billygoo/tomcat8-jdk8</p><p>·     无之前的配对显示了，看容器实例内部</p><p><img src="https://image.3001.net/images/20220823/16612330926647.jpg" alt="graphic"></p><p>·     没有设置-p的端口映射了，如何访问启动的tomcat83？？</p><p>http://宿主机IP:8080/</p><p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，</p><p>所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p><p>·     none</p><p>·     是什么</p><p>在none模式下，并不为Docker容器进行任何网络配置。 </p><p>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo</p><p>需要我们自己为Docker容器添加网卡、配置IP等。</p><p>·    禁用网络功能，只有lo标识(就是127.0.0.1表示本地回环)</p><p>·     案例</p><p>docker run -d -p 8084:8080 –network none –name tomcat84 billygoo/tomcat8-jdk8</p><p> 进入容器内部查看</p><p><img src="https://image.3001.net/images/20220823/16612330979324.jpg" alt="graphic"></p><p>在容器外部查看</p><p><img src="https://image.3001.net/images/20220823/16612331006227.jpg" alt="graphic"></p><p>·     docker run -d -p 8084:8080 –network none –name tomcat84 billygoo/tomcat8-jdk8</p><p>·     container</p><p>·     是什么</p><p>container⽹络模式 </p><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><p><img src="https://image.3001.net/images/20220823/16612331041407.jpg" alt="graphic"></p><p>·     案例</p><table><thead><tr><th>单图标</th><th><img src="https://image.3001.net/images/20220823/16612334343148.gif" alt="img"> CustomIcon-663735520; [“”, “4MyPJwAAAAAAAAAAAAAAAA==”]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     docker run -d -p 8085:8080                   –name tomcat85 billygoo/tomcat8-jdk8</p><p>·     docker run -d -p 8086:8080 –network container:tomcat85 –name tomcat86 billygoo/tomcat8-jdk8</p><p>·     运行结果</p><p><img src="https://image.3001.net/images/20220823/1661233439812.jpg" alt="graphic"></p><p># 相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突</p><p>本案例用tomcat演示不合适。。。演示坑。。。。。。o(╥﹏╥)o</p><p>换一个镜像给大家演示，</p><p>·     案例2</p><table><thead><tr><th>单图标</th><th><img src="https://image.3001.net/images/20220823/16612334425973.gif" alt="img"> CustomIcon–1664269521; [“”,  “L0PNnAAAAAAAAAAAAAAAAA==”]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>·     Alpine操作系统是一个面向安全的轻型 Linux发行版</p><p>Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版本，但是经常用 Docker 的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到 6M的大小，所以特别适合容器打包。</p><p>·     docker run -it                          –name alpine1 alpine /bin/sh</p><p>·     docker run -it –network container:alpine1 –name alpine2 alpine /bin/sh</p><p>·     运行结果，验证共用搭桥</p><p><img src="https://image.3001.net/images/20220823/16612334459875.jpg" alt="graphic"></p><p>·     假如此时关闭alpine1，再看看alpine2</p><p><img src="https://image.3001.net/images/20220823/16612334472920.jpg" alt="graphic"></p><p>15: eth0@if16: 消失了。。。。。。关闭alpine1，再看看alpine2</p><p><img src="https://image.3001.net/images/20220823/16612334494827.jpg" alt="graphic"></p><p>·     自定义网络</p><p>·     过时的link</p><p><img src="https://image.3001.net/images/20220823/16612334514151.jpg" alt="graphic"></p><p>·     是什么</p><p>·     案例</p><p>·     before</p><p>·     案例</p><p>·     docker run -d -p 8081:8080  –name tomcat81 billygoo/tomcat8-jdk8</p><p>·     docker run -d -p 8082:8080  –name tomcat82 billygoo/tomcat8-jdk8</p><p>·     上述成功启动并用docker exec进入各自容器实例内部</p><p>·     问题</p><p>·     按照IP地址ping是OK的</p><p><img src="https://image.3001.net/images/20220823/16612334561177.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612334548831.jpg" alt="graphic"></p><p>·     按照服务名ping结果???</p><p><img src="https://image.3001.net/images/20220823/1661233459164.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612334613339.jpg" alt="graphic"></p><p>·     after</p><p>·     案例</p><p>·     自定义桥接网络,自定义网络默认使用的是桥接网络bridge</p><p>·     新建自定义网络</p><p><img src="https://image.3001.net/images/20220823/16612334633318.jpg" alt="graphic"></p><p>·     新建容器加入上一步新建的自定义网络</p><p>·     docker run -d -p 8081:8080 –network zzyy_network –name tomcat81 billygoo/tomcat8-jdk8</p><p>·     docker run -d -p 8082:8080 –network zzyy_network –name tomcat82 billygoo/tomcat8-jdk8</p><p>·     互相ping测试</p><p><img src="https://image.3001.net/images/20220823/16612334652212.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612334673922.jpg" alt="graphic"></p><p>·     问题结论</p><p>·     自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><p>·     自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><p>·     自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><p>2.4.5.       Docker平台架构图解</p><p>·     整体说明</p><p>从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p><p>Docker 运行的基本流程为：</p><p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p><p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p><p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p><p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</p><p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p><p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p><p>7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</p><p>·     整体架构</p><p><img src="https://image.3001.net/images/20220823/16612334703610.jpg" alt="graphic"></p><h3 id="2-5-Docker-compose容器编排"><a href="#2-5-Docker-compose容器编排" class="headerlink" title="2.5.      Docker-compose容器编排"></a>2.5.      Docker-compose容器编排</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image570.jpg" alt="img"></td></tr></tbody></table><h4 id="2-5-1-是什么"><a href="#2-5-1-是什么" class="headerlink" title="2.5.1.       是什么"></a>2.5.1.       是什么</h4><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器</p><p>·     Docker-Compose是Docker官方的开源项目， 负责实现对Docker容器集群的快速编排。</p><h4 id="2-5-2-能干嘛"><a href="#2-5-2-能干嘛" class="headerlink" title="2.5.2.       能干嘛"></a>2.5.2.       能干嘛</h4><p> docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p><p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具</p><p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p><p>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><h4 id="2-5-3-去哪下"><a href="#2-5-3-去哪下" class="headerlink" title="2.5.3.       去哪下"></a>2.5.3.       去哪下</h4><p>·     官网</p><p>·     <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>·     官网下载</p><p>·     <a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p><p>·     安装步骤</p><table><thead><tr><th>curl -L “<a href="https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$">https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$</a>(uname  -s)-$(uname -m)” -o /usr/local/bin/docker-compose</th></tr></thead><tbody><tr><td>chmod +x /usr/local/bin/docker-compose</td></tr><tr><td>docker-compose –version</td></tr></tbody></table><p><img src="https://image.3001.net/images/20220823/16612334771525.jpg" alt="graphic"></p><p>·     卸载步骤</p><p><img src="https://image.3001.net/images/20220823/16612334796101.jpg" alt="graphic"></p><h4 id="2-5-4-Compose核心概念"><a href="#2-5-4-Compose核心概念" class="headerlink" title="2.5.4.       Compose核心概念"></a>2.5.4.       Compose核心概念</h4><p>·     一文件</p><p>·    docker-compose.yml</p><p>·     两要素</p><p>·     服务（service）</p><p>·     一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</p><p>·     工程（project）</p><p>·     由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p><h4 id="2-5-5-Compose使用的三个步骤"><a href="#2-5-5-Compose使用的三个步骤" class="headerlink" title="2.5.5.       Compose使用的三个步骤"></a>2.5.5.       Compose使用的三个步骤</h4><p>·     编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</p><p>·     使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</p><p>·     最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</p><h4 id="2-5-6-Compose常用命令"><a href="#2-5-6-Compose常用命令" class="headerlink" title="2.5.6.       Compose常用命令"></a>2.5.6.       Compose常用命令</h4><p><strong>Compose****常用命令</strong></p><p>docker-compose -h              # 查看帮助</p><p>docker-compose up              # 启动所有docker-compose服务</p><p>docker-compose up -d            # 启动所有docker-compose服务并后台运行</p><p>docker-compose down             # 停止并删除容器、网络、卷、镜像。</p><p>docker-compose exec  yml里面的服务id         # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</p><p>docker-compose ps           # 展示当前docker-compose编排过的运行的所有容器</p><p>docker-compose top           # 展示当前docker-compose编排过的容器进程</p><p>docker-compose logs  yml里面的服务id   # 查看容器输出日志</p><p>docker-compose config   # 检查配置</p><p>docker-compose config -q # 检查配置，有问题才有输出</p><p>docker-compose restart  # 重启服务</p><p>docker-compose start   # 启动服务</p><p>docker-compose stop    # 停止服务</p><h4 id="2-5-7-Compose编排微服务"><a href="#2-5-7-Compose编排微服务" class="headerlink" title="2.5.7.       Compose编排微服务"></a>2.5.7.       Compose编排微服务</h4><p>·     改造升级微服务工程docker_boot</p><p>·     以前的基础版</p><p><img src="https://image.3001.net/images/20220823/16612334822466.jpg" alt="graphic"></p><p>·     SQL建表建库</p><p>CREATE TABLE <code>t_user</code> (</p><p> <code>id</code> int(10) unsigned NOT NULL AUTO_INCREMENT,</p><p> <code>username</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘用户名’,</p><p> <code>password</code> varchar(50) NOT NULL DEFAULT ‘’ COMMENT ‘密码’,</p><p> <code>sex</code> tinyint(4) NOT NULL DEFAULT ‘0’ COMMENT ‘性别 0=女 1=男 ‘,</p><p> <code>deleted</code> tinyint(4) unsigned NOT NULL DEFAULT ‘0’ COMMENT ‘删除标志，默认0不删除，1删除’,</p><p> <code>update_time</code> timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘更新时间’,</p><p> <code>create_time</code> timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘创建时间’,</p><p> PRIMARY KEY (<code>id</code>)</p><p>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=’用户表’</p><p>·     一键生成说明</p><p>·     改POM</p><?xml version="1.0" encoding="UTF-8"?><p> <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">     <modelVersion>4.0.0</modelVersion>     <parent>         <groupId>org.springframework.boot</groupId>         <artifactId>spring-boot-starter-parent</artifactId>         <version>2.5.6</version>         <!--<version>2.3.10.RELEASE</version>-->         <relativePath/> <!-- lookup parent from repository -->     </parent>      <groupId>com.atguigu.docker</groupId>     <artifactId>docker_boot</artifactId>     <version>0.0.1-SNAPSHOT</version>      <properties>         &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;         &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;         &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;         &lt;junit.version&gt;4.12&lt;/junit.version&gt;         &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;         &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;         &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;         &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;         &lt;mapper.version&gt;4.1.5&lt;/mapper.version&gt;         &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt;     </properties>      <dependencies>         <!--guava Google 开源的 Guava 中自带的布隆过滤器-->         <dependency>             <groupId>com.google.guava</groupId>             <artifactId>guava</artifactId>             <version>23.0</version>         </dependency>         <!-- redisson -->         <dependency>             <groupId>org.redisson</groupId>             <artifactId>redisson</artifactId>             <version>3.13.4</version>         </dependency>         <!--SpringBoot通用依赖模块-->         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-web</artifactId>         </dependency>         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-actuator</artifactId>         </dependency>         <!--swagger2-->         <dependency>             <groupId>io.springfox</groupId>             <artifactId>springfox-swagger2</artifactId>             <version>2.9.2</version>         </dependency>         <dependency>             <groupId>io.springfox</groupId>             <artifactId>springfox-swagger-ui</artifactId>             <version>2.9.2</version>         </dependency>         <!--SpringBoot与Redis整合依赖-->         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-data-redis</artifactId>         </dependency>         <!--springCache-->         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-cache</artifactId>         </dependency>         <!--springCache连接池依赖包-->         <dependency>             <groupId>org.apache.commons</groupId>             <artifactId>commons-pool2</artifactId>         </dependency>         <!-- jedis -->         <dependency>             <groupId>redis.clients</groupId>             <artifactId>jedis</artifactId>             <version>3.1.0</version>         </dependency>         <!--Mysql数据库驱动-->         <dependency>             <groupId>mysql</groupId>             <artifactId>mysql-connector-java</artifactId>             <version>5.1.47</version>         </dependency>         <!--SpringBoot集成druid连接池-->         <dependency>             <groupId>com.alibaba</groupId>             <artifactId>druid-spring-boot-starter</artifactId>             <version>1.1.10</version>         </dependency>         <dependency>             <groupId>com.alibaba</groupId>             <artifactId>druid</artifactId>             <version>${druid.version}</version>         </dependency>         <!--mybatis和springboot整合-->         <dependency>             <groupId>org.mybatis.spring.boot</groupId>             <artifactId>mybatis-spring-boot-starter</artifactId>             <version>${mybatis.spring.boot.version}</version>         </dependency>         <!-- 添加springboot对amqp的支持 -->         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-amqp</artifactId>         </dependency>         <dependency>             <groupId>commons-codec</groupId>             <artifactId>commons-codec</artifactId>             <version>1.10</version>         </dependency>         <!--通用基础配置junit/devtools/test/log4j/lombok/hutool-->         <!--hutool-->         <dependency>             <groupId>cn.hutool</groupId>             <artifactId>hutool-all</artifactId>             <version>5.2.3</version>         </dependency>         <dependency>             <groupId>junit</groupId>             <artifactId>junit</artifactId>             <version>${junit.version}</version>         </dependency>         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-devtools</artifactId>             <scope>runtime</scope>             <optional>true</optional>         </dependency>         <dependency>             <groupId>org.springframework.boot</groupId>             <artifactId>spring-boot-starter-test</artifactId>             <scope>test</scope>         </dependency>         <dependency>             <groupId>log4j</groupId>             <artifactId>log4j</artifactId>             <version>${log4j.version}</version>         </dependency>         <dependency>             <groupId>org.projectlombok</groupId>             <artifactId>lombok</artifactId>             <version>${lombok.version}</version>             <optional>true</optional>         </dependency>         <!--persistence-->         <dependency>             <groupId>javax.persistence</groupId>             <artifactId>persistence-api</artifactId>             <version>1.0.2</version>         </dependency>         <!--通用Mapper-->         <dependency>             <groupId>tk.mybatis</groupId>             <artifactId>mapper</artifactId>             <version>${mapper.version}</version>         </dependency>     </dependencies>      <build>         <plugins>             <plugin>                 <groupId>org.springframework.boot</groupId>                 <artifactId>spring-boot-maven-plugin</artifactId>             </plugin>             <plugin>                 <groupId>org.apache.maven.plugins</groupId>                 <artifactId>maven-resources-plugin</artifactId>                 <version>3.1.0</version>             </plugin>         </plugins>     </build>  </project>  </p><p>·     写YML</p><p><strong>server.port</strong>=**6001</p><p>** <em># ========================alibaba.druid*<em>相关配置</em></em>=====================<br>* <strong>spring.datasource.type</strong>=**com.alibaba.druid.pool.DruidDataSource</p><p>** <strong>spring.datasource.driver-class-name</strong>=**com.mysql.jdbc.Driver</p><p>** <strong>spring.datasource.url</strong>=**jdbc:mysql://<strong><strong>192.168.111.169</strong></strong>:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false<br>** <strong>spring.datasource.username</strong>=**root</p><p>** <strong>spring.datasource.password</strong>=**123456</p><p>** <strong>spring.datasource.druid.test-while-idle</strong>=**false</p><p>** <em># ========================redis*<em>相关配置</em></em>=====================<br>* <strong>spring.redis.database</strong>=**0</p><p>** <strong>spring.redis.host</strong>=**192.168.111.169</p><p>** <strong>spring.redis.port</strong>=**6379</p><p>** <strong>spring.redis.password</strong>=<br> <strong>spring.redis.lettuce.pool.max-active</strong>=**8</p><p>** <strong>spring.redis.lettuce.pool.max-wait</strong>=**-1ms</p><p>** <strong>spring.redis.lettuce.pool.max-idle</strong>=**8</p><p>** <strong>spring.redis.lettuce.pool.min-idle</strong>=**0</p><p>** <em># ========================mybatis*<em>相关配置</em></em>===================<br>* <strong>mybatis.mapper-locations</strong>=**classpath:mapper/*.xml</p><p>** <strong>mybatis.type-aliases-package</strong>=**com.atguigu.docker.entities</p><p>** *# ========================swagger=====================<br>* <strong>spring.swagger2.enabled</strong>=<strong>true</strong></p><p>·     主启动</p><p><strong>package</strong> com.atguigu.docker;</p><p> <strong>import</strong> org.springframework.boot.SpringApplication;<br> <strong>import</strong> org.springframework.boot.autoconfigure.SpringBootApplication;<br> <strong>import</strong> tk.mybatis.spring.annotation.MapperScan;</p><p> @SpringBootApplication<br> @MapperScan(<strong>“com.atguigu.docker.mapper”</strong>) *//import tk.mybatis.spring.annotation.MapperScan;<br>* <strong>public class</strong> DockerBootApplication<br> {<br>   <strong>public static void</strong> main(String[] args)<br>   {<br>     SpringApplication.<em>run</em>(DockerBootApplication.<strong>class</strong>, args);<br>   }</p><p> }</p><p>·     业务类</p><p>·     config配置类</p><p>·    RedisConfig</p><p><strong>package</strong> com.atguigu.docker.config;</p><p> <strong>import</strong> lombok.extern.slf4j.Slf4j;<br> <strong>import</strong> org.springframework.context.annotation.Bean;<br> <strong>import</strong> org.springframework.context.annotation.Configuration;<br> <strong>import</strong> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;<br> <strong>import</strong> org.springframework.data.redis.core.RedisTemplate;<br> <strong>import</strong> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;<br> <strong>import</strong> org.springframework.data.redis.serializer.StringRedisSerializer;</p><p> <strong>import</strong> java.io.Serializable;</p><p> <em>/</em>*<br> * <strong>@auther</strong> zzyy<br> * <strong>@create</strong> 2021-10-27 17:19<br> */</p><p>* @Configuration<br> @Slf4j<br> <strong>public class</strong> RedisConfig<br> {<br>   <em>/</em>*<br>   * <strong>@param</strong>* *<strong>lettuceConnectionFactory<br>*</strong>   ** **@return</p><p>**   *<br>   * redis*<em>序列化的工具配置类，下面这个请一定开启配置<br>*   ** 127.0.0.1:6379&gt; keys *<br>   * 1) “ord:102”</em>  <em>序列化过<br>*   ** 2) “\xac\xed\x00\x05t\x00\aord:102”</em>  *野生，没有序列化过<br>*   **/<br>*   @Bean<br>   <strong>public</strong> RedisTemplate&lt;String,Serializable&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory)<br>   {<br>     RedisTemplate&lt;String,Serializable&gt; redisTemplate = <strong>new</strong> RedisTemplate&lt;&gt;();</p><pre><code> redisTemplate.setConnectionFactory(lettuceConnectionFactory); *//**设置**key**序列化方式**string</code></pre><p>*     redisTemplate.setKeySerializer(<strong>new</strong> StringRedisSerializer());<br>     *//<strong>设置</strong>value<strong>的序列化方式</strong>json<br>*     redisTemplate.setValueSerializer(<strong>new</strong> GenericJackson2JsonRedisSerializer());</p><pre><code> redisTemplate.setHashKeySerializer(**new** StringRedisSerializer()); redisTemplate.setHashValueSerializer(**new** GenericJackson2JsonRedisSerializer());  redisTemplate.afterPropertiesSet();  **return** redisTemplate;</code></pre><p>   }</p><p> }</p><p>·    SwaggerConfig</p><p><strong>package</strong> com.atguigu.docker.config;</p><p> <strong>import</strong> org.springframework.beans.factory.annotation.Value;<br> <strong>import</strong> org.springframework.context.annotation.Bean;<br> <strong>import</strong> org.springframework.context.annotation.Configuration;<br> <strong>import</strong> springfox.documentation.builders.ApiInfoBuilder;<br> <strong>import</strong> springfox.documentation.builders.PathSelectors;<br> <strong>import</strong> springfox.documentation.builders.RequestHandlerSelectors;<br> <strong>import</strong> springfox.documentation.service.ApiInfo;<br> <strong>import</strong> springfox.documentation.spi.DocumentationType;<br> <strong>import</strong> springfox.documentation.spring.web.plugins.Docket;<br> <strong>import</strong> springfox.documentation.swagger2.annotations.EnableSwagger2;</p><p> <strong>import</strong> java.text.SimpleDateFormat;<br> <strong>import</strong> java.util.Date;</p><p> <em>/</em>*<br> * <strong>@auther</strong> zzyy<br> * <strong>@create</strong> 2021-05-01 16:18<br> */<br>* @Configuration<br> @EnableSwagger2<br> <strong>public class</strong> SwaggerConfig<br> {<br>   @Value(<strong>“${spring.swagger2.enabled}”</strong>)<br>   <strong>private</strong> Boolean <strong>enabled</strong>;</p><p>   @Bean<br>   <strong>public</strong> Docket createRestApi() {<br>     <strong>return new</strong> Docket(DocumentationType.<em><strong>SWAGGER_2*</strong>)<br>         .apiInfo(apiInfo())<br>         .enable(<strong>enabled</strong>)<br>         .select()<br>         .apis(RequestHandlerSelectors.<em>basePackage</em>(</em>*”com.atguigu.docker”**)) *//<strong>你自己的</strong>package<br>*         .paths(PathSelectors.<em>any</em>())<br>         .build();<br>   }</p><p>   <strong>public</strong> ApiInfo apiInfo() {<br>     <strong>return new</strong> ApiInfoBuilder()<br>         .title(<strong>“<strong><strong>尚硅谷</strong></strong>Java<strong><strong>大厂技术</strong></strong>“</strong>+<strong>“<strong><strong>\t</strong></strong>“</strong>+<strong>new</strong> SimpleDateFormat(<strong>“yyyy-MM-dd”</strong>).format(<strong>new</strong> Date()))<br>         .description(<strong>“docker-compose”</strong>)<br>         .version(<strong>“1.0”</strong>)<br>         .termsOfServiceUrl(<strong>“<a href="https://www.atguigu.com/&quot;">https://www.atguigu.com/&quot;</a></strong>)<br>         .build();<br>   }<br> }</p><p>·     新建entity</p><p>·    User</p><p><strong>package</strong> com.atguigu.docker.entities;</p><p> <strong>import</strong> javax.persistence.Column;<br> <strong>import</strong> javax.persistence.GeneratedValue;<br> <strong>import</strong> javax.persistence.Id;<br> <strong>import</strong> javax.persistence.Table;<br> <strong>import</strong> java.util.Date;</p><p> @Table(name = <strong>“t_user”</strong>)<br> <strong>public class</strong> User<br> {<br>   @Id<br>   @GeneratedValue(generator = <strong>“JDBC”</strong>)<br>   <strong>private</strong> Integer <strong>id</strong>;</p><p>   <em>/</em>*<br>   ** *用户名<br>*   **/<br>*   <strong>private</strong> String <strong>username</strong>;</p><p>   <em>/</em>*<br>   ** *密码<br>*   **/<br>*   <strong>private</strong> String <strong>password</strong>;</p><p>   <em>/</em>*<br>   ** <em>性别</em> *0=*<em>女</em> *1=**男<br>*   **/<br>*   <strong>private</strong> Byte <strong>sex</strong>;</p><p>   <em>/</em>*<br>   ** *删除标志，默认<strong>0</strong>不删除，<strong>1</strong>删除<br>*   **/<br>*   <strong>private</strong> Byte <strong>deleted</strong>;</p><p>   <em>/</em>*<br>   ** *更新时间<br>*   **/<br>*   @Column(name = <strong>“update_time”</strong>)<br>   <strong>private</strong> Date <strong>updateTime</strong>;</p><p>   <em>/</em>*<br>   ** *创建时间<br>*   **/<br>*   @Column(name = <strong>“create_time”</strong>)<br>   <strong>private</strong> Date <strong>createTime</strong>;</p><p>   <em>/</em>*<br>   * <strong>@return</strong> id<br>   */<br>*   <strong>public</strong> Integer getId() {<br>     <strong>return</strong> <strong>id</strong>;<br>   }</p><p>   <em>/</em>*<br>   * <strong>@param</strong>* *<strong>id<br>*</strong>   **/<br>*   <strong>public void</strong> setId(Integer id) {<br>     <strong>this</strong>.<strong>id</strong> = id;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取用户名<br>*   **<br>   * <strong>@return</strong> username -</em> *用户名<br>*   **/<br>*   <strong>public</strong> String getUsername() {<br>     <strong>return</strong> <strong>username</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置用户名<br>*   **<br>   * <strong>@param</strong></em> *<strong>username*</strong> *用户名<br>*   **/<br>*   <strong>public void</strong> setUsername(String username) {<br>     <strong>this</strong>.<strong>username</strong> = username;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取密码<br>*   **<br>   * <strong>@return</strong> password -</em> *密码<br>*   **/<br>*   <strong>public</strong> String getPassword() {<br>     <strong>return</strong> <strong>password</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置密码<br>*   **<br>   * <strong>@param</strong></em> *<strong>password*</strong> *密码<br>*   **/<br>*   <strong>public void</strong> setPassword(String password) {<br>     <strong>this</strong>.<strong>password</strong> = password;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取性别</em> *0=*<em>女</em> *1=*<em>男<br>*   **<br>   * <strong>@return</strong> sex -</em> <em>性别</em> *0=*<em>女</em> *1=**男<br>*   **/<br>*   <strong>public</strong> Byte getSex() {<br>     <strong>return</strong> <strong>sex</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置性别</em> *0=*<em>女</em> *1=*<em>男<br>*   **<br>   * <strong>@param</strong></em> *<strong>sex*</strong> <em>性别</em> *0=*<em>女</em> *1=**男<br>*   **/<br>*   <strong>public void</strong> setSex(Byte sex) {<br>     <strong>this</strong>.<strong>sex</strong> = sex;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取删除标志，默认<strong>0</strong>不删除，<strong>1</strong>删除<br>*   **<br>   * <strong>@return</strong> deleted -</em> *删除标志，默认<strong>0</strong>不删除，<strong>1</strong>删除<br>*   **/<br>*   <strong>public</strong> Byte getDeleted() {<br>     <strong>return</strong> <strong>deleted</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置删除标志，默认<strong>0</strong>不删除，<strong>1</strong>删除<br>*   **<br>   * <strong>@param</strong></em> <strong><em>deleted*</em>* *删除标志，默认</strong>0<strong>不删除，</strong>1**删除<br>*   **/<br>*   <strong>public void</strong> setDeleted(Byte deleted) {<br>     <strong>this</strong>.<strong>deleted</strong> = deleted;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取更新时间<br>*   **<br>   * <strong>@return</strong> update_time -</em> *更新时间<br>*   **/<br>*   <strong>public</strong> Date getUpdateTime() {<br>     <strong>return</strong> <strong>updateTime</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置更新时间<br>*   **<br>   * <strong>@param</strong></em> *<strong>updateTime*</strong> *更新时间<br>*   **/<br>*   <strong>public void</strong> setUpdateTime(Date updateTime) {<br>     <strong>this</strong>.<strong>updateTime</strong> = updateTime;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取创建时间<br>*   **<br>   * <strong>@return</strong> create_time -</em> *创建时间<br>*   **/<br>*   <strong>public</strong> Date getCreateTime() {<br>     <strong>return</strong> <strong>createTime</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置创建时间<br>*   **<br>   * <strong>@param</strong></em> *<strong>createTime*</strong> *创建时间<br>*   **/<br>*   <strong>public void</strong> setCreateTime(Date createTime) {<br>     <strong>this</strong>.<strong>createTime</strong> = createTime;<br>   }<br> }</p><p>·    UserDTO</p><p><strong>package</strong> com.atguigu.docker.entities;</p><p> <strong>import</strong> io.swagger.annotations.ApiModel;<br> <strong>import</strong> io.swagger.annotations.ApiModelProperty;<br> <strong>import</strong> lombok.AllArgsConstructor;<br> <strong>import</strong> lombok.Data;<br> <strong>import</strong> lombok.NoArgsConstructor;</p><p> <strong>import</strong> java.io.Serializable;<br> <strong>import</strong> java.util.Date;</p><p> @NoArgsConstructor<br> @AllArgsConstructor<br> @Data<br> @ApiModel(value = <strong>“<strong><strong>用户信息</strong></strong>“</strong>)<br> <strong>public class</strong> UserDTO <strong>implements</strong> Serializable<br> {<br>   @ApiModelProperty(value = **”<strong><strong>用户</strong></strong>ID”**)<br>   <strong>private</strong> Integer <strong>id</strong>;</p><p>   @ApiModelProperty(value = <strong>“<strong><strong>用户名</strong></strong>“</strong>)<br>   <strong>private</strong> String <strong>username</strong>;</p><p>   @ApiModelProperty(value = <strong>“<strong><strong>密码</strong></strong>“</strong>)<br>   <strong>private</strong> String <strong>password</strong>;</p><p>   @ApiModelProperty(value = **”**<strong>性别</strong> **0=**<strong>女</strong> **1=**<strong>男</strong> <strong>“</strong>)<br>   <strong>private</strong> Byte <strong>sex</strong>;</p><p>   @ApiModelProperty(value = <strong>“<strong><strong>删除标志，默认</strong></strong>0<strong><strong>不删除，</strong></strong>1<strong><strong>删除</strong></strong>“</strong>)<br>   <strong>private</strong> Byte <strong>deleted</strong>;</p><p>   @ApiModelProperty(value = <strong>“<strong><strong>更新时间</strong></strong>“</strong>)<br>   <strong>private</strong> Date <strong>updateTime</strong>;</p><p>   @ApiModelProperty(value = <strong>“<strong><strong>创建时间</strong></strong>“</strong>)<br>   <strong>private</strong> Date <strong>createTime</strong>;</p><p>   <em>/</em>*<br>   * <strong>@return</strong> id<br>   */<br>*   <strong>public</strong> Integer getId() {<br>     <strong>return</strong> <strong>id</strong>;<br>   }</p><p>   <em>/</em>*<br>   * <strong>@param</strong>* *<strong>id<br>*</strong>   **/<br>*   <strong>public void</strong> setId(Integer id) {<br>     <strong>this</strong>.<strong>id</strong> = id;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取用户名<br>*   **<br>   * <strong>@return</strong> username -</em> *用户名<br>*   **/<br>*   <strong>public</strong> String getUsername() {<br>     <strong>return</strong> <strong>username</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置用户名<br>*   **<br>   * <strong>@param</strong></em> *<strong>username*</strong> *用户名<br>*   **/<br>*   <strong>public void</strong> setUsername(String username) {<br>     <strong>this</strong>.<strong>username</strong> = username;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取密码<br>*   **<br>   * <strong>@return</strong> password -</em> *密码<br>*   **/<br>*   <strong>public</strong> String getPassword() {<br>     <strong>return</strong> <strong>password</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置密码<br>*   **<br>   * <strong>@param</strong></em> *<strong>password*</strong> *密码<br>*   **/<br>*   <strong>public void</strong> setPassword(String password) {<br>     <strong>this</strong>.<strong>password</strong> = password;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取性别</em> *0=*<em>女</em> *1=*<em>男<br>*   **<br>   * <strong>@return</strong> sex -</em> <em>性别</em> *0=*<em>女</em> *1=**男<br>*   **/<br>*   <strong>public</strong> Byte getSex() {<br>     <strong>return</strong> <strong>sex</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置性别</em> *0=*<em>女</em> *1=*<em>男<br>*   **<br>   * <strong>@param</strong></em> *<strong>sex*</strong> <em>性别</em> *0=*<em>女</em> *1=**男<br>*   **/<br>*   <strong>public void</strong> setSex(Byte sex) {<br>     <strong>this</strong>.<strong>sex</strong> = sex;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取删除标志，默认<strong>0</strong>不删除，<strong>1</strong>删除<br>*   **<br>   * <strong>@return</strong> deleted -</em> *删除标志，默认<strong>0</strong>不删除，<strong>1</strong>删除<br>*   **/<br>*   <strong>public</strong> Byte getDeleted() {<br>     <strong>return</strong> <strong>deleted</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置删除标志，默认<strong>0</strong>不删除，<strong>1</strong>删除<br>*   **<br>   * <strong>@param</strong></em> <strong><em>deleted*</em>* *删除标志，默认</strong>0<strong>不删除，</strong>1**删除<br>*   **/<br>*   <strong>public void</strong> setDeleted(Byte deleted) {<br>     <strong>this</strong>.<strong>deleted</strong> = deleted;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取更新时间<br>*   **<br>   * <strong>@return</strong> update_time -</em> *更新时间<br>*   **/<br>*   <strong>public</strong> Date getUpdateTime() {<br>     <strong>return</strong> <strong>updateTime</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置更新时间<br>*   **<br>   * <strong>@param</strong></em> *<strong>updateTime*</strong> *更新时间<br>*   **/<br>*   <strong>public void</strong> setUpdateTime(Date updateTime) {<br>     <strong>this</strong>.<strong>updateTime</strong> = updateTime;<br>   }</p><p>   <em>/</em>*<br>   ** <em>获取创建时间<br>*   **<br>   * <strong>@return</strong> create_time -</em> *创建时间<br>*   **/<br>*   <strong>public</strong> Date getCreateTime() {<br>     <strong>return</strong> <strong>createTime</strong>;<br>   }</p><p>   <em>/</em>*<br>   ** <em>设置创建时间<br>*   **<br>   * <strong>@param</strong></em> *<strong>createTime*</strong> *创建时间<br>*   **/<br>*   <strong>public void</strong> setCreateTime(Date createTime) {<br>     <strong>this</strong>.<strong>createTime</strong> = createTime;<br>   }</p><p>   @Override<br>   <strong>public</strong> String toString() {<br>     <strong>return</strong> <strong>“User{“</strong> +<br>         <strong>“id=”</strong> + <strong>id</strong> +<br>         <strong>“, username=’”</strong> + <strong>username</strong> + **’<strong><strong>&#39;</strong></strong>‘** +<br>         <strong>“, password=’”</strong> + <strong>password</strong> + **’<strong><strong>&#39;</strong></strong>‘** +<br>         <strong>“, sex=”</strong> + <strong>sex</strong> +<br>         <strong>‘}’</strong>;<br>   }<br> }</p><p>·     新建mapper</p><p>·     新建接口UserMapper</p><p><strong>package</strong> com.atguigu.docker.mapper;</p><p> <strong>import</strong> com.atguigu.docker.entities.User;<br> <strong>import</strong> tk.mybatis.mapper.common.Mapper;</p><p> <strong>public interface</strong> UserMapper <strong>extends</strong> Mapper<User> {<br> }</p><p>·     src\main\resources路径下新建mapper文件夹并新增UserMapper.xml</p><?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><p> <mapper namespace="com.atguigu.docker.mapper.UserMapper">   <resultMap id="BaseResultMap" type="com.atguigu.docker.entities.User">     <!--       WARNING - @mbg.generated     -->     <id column="id" jdbcType="INTEGER" property="id" />     <result column="username" jdbcType="VARCHAR" property="username" />     <result column="password" jdbcType="VARCHAR" property="password" />     <result column="sex" jdbcType="TINYINT" property="sex" />     <result column="deleted" jdbcType="TINYINT" property="deleted" />     <result column="update_time" jdbcType="TIMESTAMP" property="updateTime" />     <result column="create_time" jdbcType="TIMESTAMP" property="createTime" />   </resultMap> </mapper></p><p>·     新建service</p><p><strong>package</strong> com.atguigu.docker.service;</p><p> <strong>import</strong> com.atguigu.docker.entities.User;<br> <strong>import</strong> com.atguigu.docker.mapper.UserMapper;<br> <strong>import</strong> lombok.extern.slf4j.Slf4j;<br> <strong>import</strong> org.slf4j.Logger;<br> <strong>import</strong> org.slf4j.LoggerFactory;<br> <strong>import</strong> org.springframework.beans.factory.annotation.Autowired;<br> <strong>import</strong> org.springframework.data.redis.core.RedisTemplate;<br> <strong>import</strong> org.springframework.data.redis.core.ValueOperations;<br> <strong>import</strong> org.springframework.stereotype.Service;<br> <strong>import</strong> org.springframework.web.bind.annotation.PathVariable;</p><p> <strong>import</strong> javax.annotation.Resource;<br> <strong>import</strong> java.util.concurrent.TimeUnit;</p><p> <em>/</em>*<br> * <strong>@auther</strong> zzyy<br> * <strong>@create</strong> 2021-05-01 14:58<br> */<br>* @Service<br> @Slf4j<br> <strong>public class</strong> UserService {</p><p>   <strong>public static final</strong> String *<strong>CACHE_KEY_USER*</strong> = <strong>“user:”</strong>;</p><p>   @Resource<br>   <strong>private</strong> UserMapper <strong>userMapper</strong>;<br>   @Resource<br>   <strong>private</strong> RedisTemplate <strong>redisTemplate</strong>;</p><p>   <em>/</em>*<br>   * addUser<br>   * <strong>@param</strong>* <strong><em>user<br>*</em>*   **/<br>*   <strong>public void</strong> addUser(User user)<br>   {<br>     <em>//1</em> *先插入**mysql</strong>并成功<br>*     <strong>int</strong> i = <strong>userMapper</strong>.insertSelective(user);</p><pre><code> **if**(i &gt; 0) &#123;   *//2* *需要再次查询一下**mysql**将数据捞回来并**ok</code></pre><p>*       user = <strong>userMapper</strong>.selectByPrimaryKey(user.getId());<br>       <em>//3</em> *将捞出来的<strong>user</strong>存进<strong>redis</strong>，完成新增功能的数据一致性。<br>*       String key = *<strong>CACHE_KEY_USER*</strong>+user.getId();<br>       <strong>redisTemplate</strong>.opsForValue().set(key,user);<br>     }<br>   }</p><p>   <em>/</em>*<br>   * findUserById<br>   * <strong>@param</strong>* *<strong>id<br>*</strong>   ** **@return</p><p>**   */<br>*   <strong>public</strong> User findUserById(Integer id)<br>   {<br>     User user = <strong>null</strong>;<br>     String key = *<strong>CACHE_KEY_USER*</strong>+id;</p><pre><code> *//1* *先从**redis**里面查询，如果有直接返回结果，如果没有再去查询**mysql</code></pre><p>*     user = (User) <strong>redisTemplate</strong>.opsForValue().get(key);</p><pre><code> **if**(user == **null**) &#123;   *//2 redis**里面无，继续查询**mysql</code></pre><p>*       user = <strong>userMapper</strong>.selectByPrimaryKey(id);<br>       <strong>if</strong>(user == <strong>null</strong>)<br>       {<br>         <em>//3.1 redis+mysql</em> *都无数据<br>*         *//<strong>你具体细化，防止多次穿透，我们规定，记录下导致穿透的这个</strong>key<strong>回写</strong>redis<br>*         <strong>return</strong> user;<br>       }<strong>else</strong>{<br>         *//3.2 mysql<strong>有，需要将数据写回</strong>redis**，保证下一次的缓存命中率<br>*         <strong>redisTemplate</strong>.opsForValue().set(key,user);<br>       }<br>     }<br>     <strong>return</strong> user;<br>   }<br> }</p><p>·     新建controller</p><p><strong>package</strong> com.atguigu.docker.controller;</p><p> <strong>import</strong> cn.hutool.core.util.IdUtil;<br> <strong>import</strong> cn.hutool.core.util.ReferenceUtil;<br> <strong>import</strong> com.atguigu.docker.entities.User;<br> <strong>import</strong> com.atguigu.docker.entities.UserDTO;<br> <strong>import</strong> com.atguigu.docker.service.UserService;<br> <strong>import</strong> io.swagger.annotations.Api;<br> <strong>import</strong> io.swagger.annotations.ApiOperation;<br> <strong>import</strong> io.swagger.models.auth.In;<br> <strong>import</strong> lombok.extern.slf4j.Slf4j;<br> <strong>import</strong> org.springframework.beans.BeanUtils;<br> <strong>import</strong> org.springframework.beans.factory.annotation.Autowired;<br> <strong>import</strong> org.springframework.web.bind.annotation.*;</p><p> <strong>import</strong> javax.annotation.Resource;<br> <strong>import</strong> java.util.Random;</p><p> <em>/</em>*<br> * <strong>@auther</strong> zzyy<br> * <strong>@create</strong> 2021-05-01 15:02<br> */<br>* @Api(description = <strong>“<strong><strong>用户</strong></strong>User<strong><strong>接口</strong></strong>“</strong>)<br> @RestController<br> @Slf4j<br> <strong>public class</strong> UserController<br> {<br>   @Resource<br>   <strong>private</strong> UserService <strong>userService</strong>;</p><p>   @ApiOperation(<strong>“<strong><strong>数据库新增</strong></strong>3<strong><strong>条记录</strong></strong>“</strong>)<br>   @RequestMapping(value = <strong>“/user/add”</strong>,method = RequestMethod.*<strong>POST*</strong>)<br>   <strong>public void</strong> addUser()<br>   {<br>     <strong>for</strong> (<strong>int</strong> i = 1; i &lt;=3; i++) {<br>       User user = <strong>new</strong> User();</p><pre><code>   user.setUsername(**&quot;zzyy&quot;**+i);   user.setPassword(IdUtil.*simpleUUID*().substring(0,6));   user.setSex((**byte**) **new** Random().nextInt(2));    **userService**.addUser(user); &#125;</code></pre><p>   }</p><p>   @ApiOperation(<strong>“<strong><strong>删除</strong></strong>1<strong><strong>条记录</strong></strong>“</strong>)<br>   @RequestMapping(value = <strong>“/user/delete/{id}”</strong>,method = RequestMethod.*<strong>POST*</strong>)<br>   <strong>public void</strong> deleteUser(@PathVariable Integer id)<br>   {<br>     <strong>userService</strong>.deleteUser(id);<br>   }</p><p>   @ApiOperation(<strong>“<strong><strong>修改</strong></strong>1<strong><strong>条记录</strong></strong>“</strong>)<br>   @RequestMapping(value = <strong>“/user/update”</strong>,method = RequestMethod.*<strong>POST*</strong>)<br>   <strong>public void</strong> updateUser(@RequestBody UserDTO userDTO)<br>   {<br>     User user = <strong>new</strong> User();<br>     BeanUtils.<em>copyProperties</em>(userDTO,user);<br>     <strong>userService</strong>.updateUser(user);<br>   }</p><p>   @ApiOperation(<strong>“<strong><strong>查询</strong></strong>1<strong><strong>条记录</strong></strong>“</strong>)<br>   @RequestMapping(value = <strong>“/user/find/{id}”</strong>,method = RequestMethod.*<strong>GET*</strong>)<br>   <strong>public</strong> User findUserById(@PathVariable Integer id)<br>   {<br>     <strong>return</strong> <strong>userService</strong>.findUserById2(id);<br>   }<br> }</p><p>·     mvn package命令将微服务形成新的jar包 并上传到Linux服务器/mydocker目录下</p><p>·     编写Dockerfile</p><p># 基础镜像使用java</p><p>FROM java:8</p><p># 作者</p><p>MAINTAINER zzyy</p><p># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</p><p>VOLUME /tmp</p><p># 将jar包添加到容器中并更名为zzyy_docker.jar</p><p>ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</p><p># 运行jar包</p><p>RUN bash -c ‘touch /zzyy_docker.jar’</p><p>ENTRYPOINT [“java”,”-jar”,”/zzyy_docker.jar”]</p><p>#暴露6001端口作为微服务</p><p>EXPOSE 6001</p><p>·     构建镜像</p><p>·     docker build -t zzyy_docker:1.6 .</p><p>·     不用<strong>Compose</strong></p><p>·     单独的mysql容器实例</p><p>·     新建mysql容器实例</p><p>  docker run -p 3306:3306 –name mysql57  –privileged=true -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -v  /zzyyuse/mysql/logs:/logs -v /zzyyuse/mysql/data:/var/lib/mysql -e  MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7  </p><p>·     进入mysql容器实例并新建库db2021+新建表t_user</p><table><thead><tr><th>docker exec -it mysql57 /bin/bash</th></tr></thead><tbody><tr><td>mysql -uroot -p</td></tr><tr><td>create database db2021;</td></tr><tr><td>use db2021;</td></tr><tr><td>CREATE TABLE <code>t_user</code> (   <code>id</code> INT(10) UNSIGNED NOT NULL  AUTO_INCREMENT,   <code>username</code> VARCHAR(50) NOT NULL DEFAULT ‘’  COMMENT ‘用户名’,   <code>password</code> VARCHAR(50) NOT NULL DEFAULT ‘’  COMMENT ‘密码’,   <code>sex</code> TINYINT(4) NOT NULL DEFAULT ‘0’ COMMENT  ‘性别 0=女 1=男 ‘,   <code>deleted</code> TINYINT(4) UNSIGNED NOT NULL  DEFAULT ‘0’ COMMENT ‘删除标志，默认0不删除，1删除’,   <code>update_time</code> TIMESTAMP NOT NULL DEFAULT  CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘更新时间’,   <code>create_time</code> TIMESTAMP NOT NULL DEFAULT  CURRENT_TIMESTAMP COMMENT ‘创建时间’,   PRIMARY KEY (<code>id</code>)  ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT  CHARSET=utf8mb4 COMMENT=’用户表’;</td></tr></tbody></table><p>·     单独的redis容器实例</p><p>docker run -p 6379:6379 –name redis608 –privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf</p><p>·     微服务工程</p><p> docker run -d -p 6001:6001 zzyy_docker:1.6</p><p>·     上面三个容器实例依次顺序启动成功</p><p><img src="https://image.3001.net/images/20220823/16612335009727.jpg" alt="graphic"></p><p>·     swagger测试</p><p>·     <a href="http://localhost:你的微服务端口/swagger-ui.html#/">http://localhost:你的微服务端口/swagger-ui.html#/</a></p><p>·     上面成功了，有哪些问题?</p><p>·     先后顺序要求固定，先mysql+redis才能微服务访问成功</p><p>·     多个run命令……</p><p>·     容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错， 要么生产IP写死(可以但是不推荐)，要么通过服务调用</p><p>·     使用<strong>Compose</strong></p><p>·     服务编排，一套带走，安排</p><p>·     编写docker-compose.yml文件</p><p>version: “3”</p><p>services:</p><p> microService:</p><p>  image: zzyy_docker:1.6</p><p>  container_name: ms01</p><p>  ports:</p><p>   - “6001:6001”</p><p>  volumes:</p><p>   - /app/microService:/data</p><p>  networks: </p><p>   - atguigu_net </p><p>  depends_on: </p><p>   - redis</p><p>   - mysql</p><p> redis:</p><p>  image: redis:6.0.8</p><p>  ports:</p><p>   - “6379:6379”</p><p>  volumes:</p><p>   - /app/redis/redis.conf:/etc/redis/redis.conf</p><p>   - /app/redis/data:/data</p><p>  networks: </p><p>   - atguigu_net</p><p>  command: redis-server /etc/redis/redis.conf</p><p> mysql:</p><p>  image: mysql:5.7</p><p>  environment:</p><p>   MYSQL_ROOT_PASSWORD: ‘123456’</p><p>   MYSQL_ALLOW_EMPTY_PASSWORD: ‘no’</p><p>   MYSQL_DATABASE: ‘db2021’</p><p>   MYSQL_USER: ‘zzyy’</p><p>   MYSQL_PASSWORD: ‘zzyy123’</p><p>  ports:</p><p>​    - “3306:3306”</p><p>  volumes:</p><p>​    - /app/mysql/db:/var/lib/mysql</p><p>​    - /app/mysql/conf/my.cnf:/etc/my.cnf</p><p>​    - /app/mysql/init:/docker-entrypoint-initdb.d</p><p>  networks:</p><p>   - atguigu_net</p><p>  command: –default-authentication-plugin=mysql_native_password #解决外部无法访问</p><p>networks: </p><p>  atguigu_net: </p><p>·     第二次修改微服务工程docker_boot</p><p>·     写YML</p><p><strong>server.port</strong>=**6001</p><p>** <em># ========================alibaba.druid*<em>相关配置</em></em>=====================<br>* <strong>spring.datasource.type</strong>=**com.alibaba.druid.pool.DruidDataSource</p><p>** <strong>spring.datasource.driver-class-name</strong>=**com.mysql.jdbc.Driver</p><p>** *#spring.datasource.url=jdbc:mysql://192.168.111.169:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false<br>* <strong>spring.datasource.url</strong>=**jdbc:mysql://mysql:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</p><p>** <strong>spring.datasource.username</strong>=**root</p><p>** <strong>spring.datasource.password</strong>=**123456</p><p>** <strong>spring.datasource.druid.test-while-idle</strong>=**false</p><p>** <em># ========================redis*<em>相关配置</em></em>=====================<br>* <strong>spring.redis.database</strong>=**0</p><p>** *#spring.redis.host=192.168.111.169<br>* <strong>spring.redis.host</strong>=**redis</p><p>** <strong>spring.redis.port</strong>=**6379</p><p>** <strong>spring.redis.password</strong>=<br> <strong>spring.redis.lettuce.pool.max-active</strong>=**8</p><p>** <strong>spring.redis.lettuce.pool.max-wait</strong>=**-1ms</p><p>** <strong>spring.redis.lettuce.pool.max-idle</strong>=**8</p><p>** <strong>spring.redis.lettuce.pool.min-idle</strong>=**0</p><p>** <em># ========================mybatis*<em>相关配置</em></em>===================<br>* <strong>mybatis.mapper-locations</strong>=**classpath:mapper/*.xml</p><p>** <strong>mybatis.type-aliases-package</strong>=**com.atguigu.docker.entities</p><p>** *# ========================swagger=====================<br>* <strong>spring.swagger2.enabled</strong>=<strong>true</strong></p><p>·     通过服务名访问，IP无关</p><p>·     mvn package命令将微服务形成新的jar包 并上传到Linux服务器/mydocker目录下</p><p>·     编写Dockerfile</p><p># 基础镜像使用java</p><p>FROM java:8</p><p># 作者</p><p>MAINTAINER zzyy</p><p># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</p><p>VOLUME /tmp</p><p># 将jar包添加到容器中并更名为zzyy_docker.jar</p><p>ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</p><p># 运行jar包</p><p>RUN bash -c ‘touch /zzyy_docker.jar’</p><p>ENTRYPOINT [“java”,”-jar”,”/zzyy_docker.jar”]</p><p>#暴露6001端口作为微服务</p><p>EXPOSE 6001</p><p>·     构建镜像</p><p>·     docker build -t zzyy_docker:1.6 .</p><p>·     执行 docker-compose up 或者 执行 docker-compose up -d</p><p><img src="https://image.3001.net/images/20220823/16612335061798.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612335081497.jpg" alt="graphic"></p><p>·     进入mysql容器实例并新建库db2021+新建表t_user</p><table><thead><tr><th>docker exec -it 容器实例id /bin/bash</th></tr></thead><tbody><tr><td>mysql -uroot -p</td></tr><tr><td>create database db2021;</td></tr><tr><td>use db2021;</td></tr><tr><td>CREATE TABLE <code>t_user</code> (   <code>id</code> INT(10) UNSIGNED NOT NULL  AUTO_INCREMENT,   <code>username</code> VARCHAR(50) NOT NULL DEFAULT ‘’  COMMENT ‘用户名’,   <code>password</code> VARCHAR(50) NOT NULL DEFAULT ‘’ COMMENT  ‘密码’,   <code>sex</code> TINYINT(4) NOT NULL DEFAULT ‘0’ COMMENT  ‘性别 0=女 1=男 ‘,   <code>deleted</code> TINYINT(4) UNSIGNED NOT NULL  DEFAULT ‘0’ COMMENT ‘删除标志，默认0不删除，1删除’,   <code>update_time</code> TIMESTAMP NOT NULL DEFAULT  CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘更新时间’,   <code>create_time</code> TIMESTAMP NOT NULL DEFAULT  CURRENT_TIMESTAMP COMMENT ‘创建时间’,   PRIMARY KEY (<code>id</code>)  ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT  CHARSET=utf8mb4 COMMENT=’用户表’;</td></tr></tbody></table><p>·     测试通过</p><p>·     Compose常用命令</p><p><strong>Compose****常用命令</strong></p><p>docker-compose -h              # 查看帮助</p><p>docker-compose up              # 启动所有docker-compose服务</p><p>docker-compose up -d            # 启动所有docker-compose服务并后台运行</p><p>docker-compose down             # 停止并删除容器、网络、卷、镜像。</p><p>docker-compose exec  yml里面的服务id         # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</p><p>docker-compose ps           # 展示当前docker-compose编排过的运行的所有容器</p><p>docker-compose top           # 展示当前docker-compose编排过的容器进程</p><p>docker-compose logs  yml里面的服务id   # 查看容器输出日志</p><p>dokcer-compose config   # 检查配置</p><p>dokcer-compose config -q # 检查配置，有问题才有输出</p><p>docker-compose restart  # 重启服务</p><p>docker-compose start   # 启动服务</p><p>docker-compose stop    # 停止服务</p><p>·     关停</p><p><img src="https://image.3001.net/images/20220823/16612335129340.jpg" alt="graphic"></p><h3 id="2-6-Docker轻量级可视化工具Portainer"><a href="#2-6-Docker轻量级可视化工具Portainer" class="headerlink" title="2.6.      Docker轻量级可视化工具Portainer"></a>2.6.      Docker轻量级可视化工具Portainer</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image584.jpg" alt="img"></td></tr></tbody></table><h4 id="2-6-1-是什么"><a href="#2-6-1-是什么" class="headerlink" title="2.6.1.       是什么"></a>2.6.1.       是什么</h4><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><h4 id="2-6-2-安装"><a href="#2-6-2-安装" class="headerlink" title="2.6.2.       安装"></a>2.6.2.       安装</h4><p>·     官网</p><p>·     <a href="https://www.portainer.io/">https://www.portainer.io/</a></p><p>·     <a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p><p>·     步骤</p><p>·     docker命令安装</p><p>  docker run -d -p 8000:8000 -p 9000:9000 –name  portainer   –restart=always   -v  /var/run/docker.sock:/var/run/docker.sock   -v  portainer_data:/data   portainer/portainer  </p><p><img src="https://image.3001.net/images/20220823/16612335161831.jpg" alt="graphic"></p><p>·     第一次登录需创建admin，访问地址：xxx.xxx.xxx.xxx:9000</p><table><thead><tr><th>用户名，直接用默认admin</th></tr></thead><tbody><tr><td>密码记得8位，随便你写</td></tr></tbody></table><p><img src="https://image.3001.net/images/20220823/16612335186344.jpg" alt="graphic"></p><p>·     设置admin用户和密码后首次登陆</p><p><img src="https://image.3001.net/images/20220823/16612335216331.jpg" alt="graphic"></p><p>·     选择local选项卡后本地docker详细信息展示</p><p><img src="https://image.3001.net/images/20220823/16612335231674.jpg" alt="graphic"></p><p>·     上一步的图形展示，能想得起对应命令吗？</p><p><img src="https://image.3001.net/images/20220823/16612335249246.jpg" alt="graphic"></p><h4 id="2-6-3-登陆并演示介绍常用操作case"><a href="#2-6-3-登陆并演示介绍常用操作case" class="headerlink" title="2.6.3.       登陆并演示介绍常用操作case"></a>2.6.3.       登陆并演示介绍常用操作case</h4><h3 id="2-7-Docker容器监控之-CAdvisor-InfluxDB-Granfana"><a href="#2-7-Docker容器监控之-CAdvisor-InfluxDB-Granfana" class="headerlink" title="2.7.      Docker容器监控之 CAdvisor+InfluxDB+Granfana"></a>2.7.      Docker容器监控之 CAdvisor+InfluxDB+Granfana</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image596.jpg" alt="img"></td></tr></tbody></table><h4 id="2-7-1-原生命令"><a href="#2-7-1-原生命令" class="headerlink" title="2.7.1.       原生命令"></a>2.7.1.       原生命令</h4><p>·     操作</p><p><img src="https://image.3001.net/images/20220823/16612335282191.jpg" alt="graphic"></p><p><strong>docker stats****命令的结果</strong></p><p><img src="https://image.3001.net/images/20220823/16612335302559.jpg" alt="graphic"></p><p>·     问题</p><p>通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据，一般小公司够用了。。。。</p><p>但是，</p><p>docker stats统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能</p><h4 id="2-7-2-是什么"><a href="#2-7-2-是什么" class="headerlink" title="2.7.2.       是什么"></a>2.7.2.       是什么</h4><p>·     容器监控3剑客</p><p>·     一句话</p><p><img src="https://image.3001.net/images/20220823/16612335335501.jpg" alt="graphic"></p><p>·     CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</p><p>·     CAdvisor</p><p><img src="https://image.3001.net/images/20220823/16612335435070.jpg" alt="graphic"></p><p>·     InfluxDB</p><p><img src="https://image.3001.net/images/20220823/16612335468020.jpg" alt="graphic"></p><p>·     Granfana</p><p><img src="https://image.3001.net/images/20220823/16612335553834.jpg" alt="graphic"></p><p>·     总结</p><p><img src="https://image.3001.net/images/20220823/16612335606909.jpg" alt="graphic"></p><h4 id="2-7-3-compose容器编排，一套带走"><a href="#2-7-3-compose容器编排，一套带走" class="headerlink" title="2.7.3.       compose容器编排，一套带走"></a>2.7.3.       compose容器编排，一套带走</h4><p>·     新建目录</p><p><img src="https://image.3001.net/images/20220823/16612335634267.jpg" alt="graphic"></p><p>·     新建3件套组合的 docker-compose.yml</p><p>version: ‘3.1’</p><p>volumes:</p><p> grafana_data: {}</p><p>services:</p><p> influxdb:</p><p> image: tutum/influxdb:0.9</p><p> restart: always</p><p> environment:</p><p>  - PRE_CREATE_DB=cadvisor</p><p> ports:</p><p>  - “8083:8083”</p><p>  - “8086:8086”</p><p> volumes:</p><p>  - ./data/influxdb:/data</p><p> cadvisor:</p><p> image: google/cadvisor</p><p> links:</p><p>  - influxdb:influxsrv</p><p> command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086</p><p> restart: always</p><p> ports:</p><p>  - “8080:8080”</p><p> volumes:</p><p>  - /:/rootfs:ro</p><p>  - /var/run:/var/run:rw</p><p>  - /sys:/sys:ro</p><p>  - /var/lib/docker/:/var/lib/docker:ro</p><p> grafana:</p><p> user: “104”</p><p> image: grafana/grafana</p><p> user: “104”</p><p> restart: always</p><p> links:</p><p>  - influxdb:influxsrv</p><p> ports:</p><p>  - “3000:3000”</p><p> volumes:</p><p>  - grafana_data:/var/lib/grafana</p><p> environment:</p><p>  - HTTP_USER=admin</p><p>  - HTTP_PASS=admin</p><p>  - INFLUXDB_HOST=influxsrv</p><p>  - INFLUXDB_PORT=8086</p><p>  - INFLUXDB_NAME=cadvisor</p><p>  - INFLUXDB_USER=root</p><p>  - INFLUXDB_PASS=root</p><p>·     启动docker-compose文件</p><p>·     docker-compose up</p><p><img src="https://image.3001.net/images/20220823/16612335688634.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612335707394.jpg" alt="graphic"></p><p>·     查看三个服务容器是否启动</p><p><img src="https://image.3001.net/images/20220823/16612335767822.jpg" alt="graphic"></p><p>·     测试</p><p>·     浏览cAdvisor收集服务，<a href="http://ip:8080/">http://ip:8080/</a></p><p><img src="https://image.3001.net/images/20220823/16612335789921.jpg" alt="graphic"></p><p>·     第一次访问慢，请稍等</p><p>·     cadvisor也有基础的图形展现功能，这里主要用它来作数据采集</p><p>·     浏览influxdb存储服务，<a href="http://ip:8083/">http://ip:8083/</a></p><p>·     浏览grafana展现服务，<a href="http://ip:3000/">http://ip:3000</a></p><p>·     ip+3000端口的方式访问,默认帐户密码（admin/admin）</p><p><img src="https://image.3001.net/images/20220823/16612335812912.jpg" alt="graphic"></p><p>·     配置步骤</p><p>·     配置数据源</p><p><img src="https://image.3001.net/images/20220823/16612335833175.jpg" alt="graphic"></p><p>·     选择influxdb数据源</p><p><img src="https://image.3001.net/images/20220823/16612335864395.jpg" alt="graphic"></p><p>·     配置细节</p><p>·     1</p><p><img src="https://image.3001.net/images/20220823/16612335882833.jpg" alt="graphic"></p><p>·     2</p><p><img src="https://image.3001.net/images/20220823/16612335909025.jpg" alt="graphic"></p><p><img src="https://image.3001.net/images/20220823/16612335926704.jpg" alt="graphic"></p><p>·     配置面板panel</p><p>·     1</p><p><img src="https://image.3001.net/images/20220823/16612336006999.jpg" alt="graphic"></p><p>·     2</p><p><img src="https://image.3001.net/images/20220823/16612336025388.jpg" alt="graphic"></p><p>·     3</p><p><img src="https://image.3001.net/images/20220823/16612336048497.jpg" alt="graphic"></p><p>·     4</p><p><img src="https://image.3001.net/images/20220823/16612336079110.jpg" alt="graphic"></p><p>·     5</p><p><img src="https://image.3001.net/images/20220823/1661233609720.jpg" alt="graphic"></p><p>·     6</p><p><img src="https://image.3001.net/images/20220823/16612336111962.jpg" alt="graphic"></p><p>·     到这里cAdvisor+InfluxDB+Grafana容器监控系统就部署完成了</p><h3 id="2-8-终章の总结"><a href="#2-8-终章の总结" class="headerlink" title="2.8.      终章の总结"></a>2.8.      终章の总结</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="./images/clip_image645.jpg" alt="img"></td></tr></tbody></table><h4 id="2-8-1-知识回顾简单串讲和总结"><a href="#2-8-1-知识回顾简单串讲和总结" class="headerlink" title="2.8.1.       知识回顾简单串讲和总结"></a>2.8.1.       知识回顾简单串讲和总结</h4><p><img src="https://image.3001.net/images/20220823/1661229276803.jpg" alt="graphic"></p><h4 id="2-8-2-进阶篇：雷丰阳老师的K8S"><a href="#2-8-2-进阶篇：雷丰阳老师的K8S" class="headerlink" title="2.8.2.       进阶篇：雷丰阳老师的K8S"></a>2.8.2.       进阶篇：雷丰阳老师的K8S</h4><!-- more -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker与微服务实战&quot;&gt;&lt;a href=&quot;#Docker与微服务实战&quot; class=&quot;headerlink&quot; title=&quot;Docker与微服务实战&quot;&gt;&lt;/a&gt;Docker与微服务实战&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Docker简介&quot;&gt;&lt;a href=&quot;#Docker简介&quot; class=&quot;headerlink&quot; title=&quot;Docker简介&quot;&gt;&lt;/a&gt;Docker简介&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://image.3001.net/images/20220823/16612291781365.jpg&quot; alt=&quot;img&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="https://yangmour.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="https://yangmour.github.io/2022/06/25/%E6%A8%A1%E6%9D%BF/"/>
    <id>https://yangmour.github.io/2022/06/25/%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-06-25T05:06:17.000Z</published>
    <updated>2022-09-08T02:17:06.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>[TOC]</p><h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1.模板"></a>1.模板</h2><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-模板&quot;&gt;&lt;a href=&quot;#1-模板&quot; class=&quot;headerlink&quot; title=&quot;1.模板&quot;&gt;&lt;/a&gt;1.模板&lt;/h2&gt;</summary>
    
    
    
    
    <category term="模板" scheme="https://yangmour.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>echarts使用步骤文档</title>
    <link href="https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%8F%AF%E8%A7%86%E5%8C%96/echarts%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/echats%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%8F%AF%E8%A7%86%E5%8C%96/echarts%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/echats%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</id>
    <published>2022-06-25T05:06:17.000Z</published>
    <updated>2022-09-08T02:17:06.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="echarts使用步骤文档"><a href="#echarts使用步骤文档" class="headerlink" title="echarts使用步骤文档"></a>echarts使用步骤文档</h1><p>[TOC]</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前我们已经采集到一定数量的用户数据，管理者希望能够查看这些用户数据。</p><p>需要将数据库中存储的原始数据进行初步的统计分析后，以可视化图表的形式加以展示。</p><p>例如：显示用户各类操作的总数量和比例。</p><span id="more"></span><h2 id="实现数据可视化的途径"><a href="#实现数据可视化的途径" class="headerlink" title="实现数据可视化的途径"></a>实现数据可视化的途径</h2><ul><li>传统软件工具：Excel，Power Point等办公软件</li><li>现代BI平台（全自动）：Power BI （商用）、Superset（开源）</li><li>可视化插件（半自动）：ECharts</li></ul><p>本例中通过ECharts实现数据可视化需求。</p><h2 id="1-echarts使用步骤"><a href="#1-echarts使用步骤" class="headerlink" title="1.echarts使用步骤"></a>1.echarts使用步骤</h2><h3 id="1-快速上手的解析"><a href="#1-快速上手的解析" class="headerlink" title="1.快速上手的解析"></a>1.快速上手的解析</h3><ol><li>在页面中引入echarts.js文件</li><li>在页面中声明div作为图表的容器</li><li>在页面中编写JS代码，初始化图表<ol><li>创建图表对象，绑定容器id</li><li>创建配置对象，对图表样式和数据进行配置</li><li>使用图表对象应用配置对象，在页面上显示图表</li></ol></li></ol><p><img src="https://image.3001.net/images/20220704/16569099924308.png" alt="2"></p><h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入echarts的js文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/echarts.minTest.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 2.在页面中声明图标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:600px;width:800px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.基于echartsapi--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.指定图表的配置项和数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> option = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">title</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">text</span>: <span class="string">&#x27;ECharts 入门示例&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">tooltip</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">legend</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">data</span>: [<span class="string">&#x27;销量&#x27;</span>,<span class="string">&quot;库存&quot;</span>]</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">xAxis</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">data</span>: [<span class="string">&#x27;衬衫&#x27;</span>, <span class="string">&#x27;羊毛衫&#x27;</span>, <span class="string">&#x27;雪纺衫&#x27;</span>, <span class="string">&#x27;裤子&#x27;</span>, <span class="string">&#x27;高跟鞋&#x27;</span>, <span class="string">&#x27;袜子&#x27;</span>]</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">yAxis</span>: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">series</span>: [</span></span><br><span class="line"><span class="javascript">                &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">name</span>: <span class="string">&#x27;销量&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">data</span>: [<span class="number">5</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>]</span></span><br><span class="line"><span class="javascript">                &#125;,&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">name</span>: <span class="string">&quot;库存&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">type</span>: <span class="string">&quot;line&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">data</span>: [<span class="number">10</span>,<span class="number">25</span>,<span class="number">40</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">22</span>]</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            ]</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3.使用刚指定的配置项和数据显示图表。</span></span></span><br><span class="line"><span class="javascript">        myChart.setOption(option);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-模板代码"><a href="#3-模板代码" class="headerlink" title="3.模板代码"></a>3.模板代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.引入echarts的js文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/echarts.minTest.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.在页面中声明图标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:600px;width:800px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.基于echartsapi--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.指定图表的配置项和数据</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3.使用刚指定的配置项和数据显示图表。</span></span></span><br><span class="line"><span class="javascript">        myChart.setOption(option);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-找到想要的配置文件"><a href="#4-找到想要的配置文件" class="headerlink" title="4.找到想要的配置文件"></a>4.找到想要的配置文件</h3><h4 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a>1.方法一</h4><p>先找功能类似的echarts图标，研究对应的标签名字</p><h5 id="1-找类似功能"><a href="#1-找类似功能" class="headerlink" title="1.找类似功能"></a>1.找类似功能</h5><p><img src="https://image.3001.net/images/20220623/16559539256422.png" alt="image-20220623111007787"></p><h5 id="2-找到代码在网页中调试一下"><a href="#2-找到代码在网页中调试一下" class="headerlink" title="2.找到代码在网页中调试一下"></a>2.找到代码在网页中调试一下</h5><p><img src="https://image.3001.net/images/20220623/16559539286886.png" alt="image-20220623111202632"></p><h5 id="3-复制到自己代码中调试测试"><a href="#3-复制到自己代码中调试测试" class="headerlink" title="3.复制到自己代码中调试测试"></a>3.复制到自己代码中调试测试</h5><p>成功的话不用去看方法二</p><h4 id="2-方法二去配置文档找配置"><a href="#2-方法二去配置文档找配置" class="headerlink" title="2.方法二去配置文档找配置"></a>2.方法二去配置文档找配置</h4><h5 id="1-根据label找配置文档去下面的方法去配置文档"><a href="#1-根据label找配置文档去下面的方法去配置文档" class="headerlink" title="1.根据label找配置文档去下面的方法去配置文档"></a>1.根据label找配置文档去下面的方法去配置文档</h5><p><img src="https://image.3001.net/images/20220704/16569100023813.png" alt="image-20220623111336416"></p><p>2.找到具体信息</p><p><img src="https://image.3001.net/images/20220704/16569100058656.png" alt="image-20220623120520900"></p><p><a href="https://echarts.apache.org/zh/option.html">echarts配置文档官网</a></p><h2 id="2-从服务器动态获取图标的数据"><a href="#2-从服务器动态获取图标的数据" class="headerlink" title="2.从服务器动态获取图标的数据"></a>2.从服务器动态获取图标的数据</h2><h3 id="1-示例图片"><a href="#1-示例图片" class="headerlink" title="1. 示例图片"></a>1. 示例图片</h3><p><img src="https://image.3001.net/images/20220704/16569100093528.png" alt="3"></p><h3 id="2-浏览器与服务器交互的数据格式"><a href="#2-浏览器与服务器交互的数据格式" class="headerlink" title="2.浏览器与服务器交互的数据格式"></a>2.浏览器与服务器交互的数据格式</h3><h4 id="1-简单数据格式"><a href="#1-简单数据格式" class="headerlink" title="1.简单数据格式"></a>1.简单数据格式</h4><p>https:\www.***.com?key1=value1&amp;key2=value2&amp;key3=value3…..</p><h4 id="2-JSON数据格式"><a href="#2-JSON数据格式" class="headerlink" title="2.JSON数据格式"></a>2.JSON数据格式</h4><p>复杂数据：一般指包含多个层级关系的数据</p><p>例如：纽约市共享单车站点的实时状态数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">站点1：</span><br><span class="line">站点id</span><br><span class="line">站点位置</span><br><span class="line">精度</span><br><span class="line">维度</span><br><span class="line">站点名称</span><br><span class="line">站点用车情况</span><br><span class="line">可用车数量</span><br><span class="line">可用桩数量</span><br><span class="line">站点保存的电动车情况</span><br><span class="line">电动车1:</span><br><span class="line">车辆id</span><br><span class="line">车辆电量</span><br><span class="line">车辆状态...</span><br></pre></td></tr></table></figure><p>Json格式的语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;stations&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;baseinfo&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;stationId&quot;</span>: <span class="string">&quot;7789&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;coordainate&quot;</span>: [<span class="number">-78.123</span>,<span class="number">40.567</span>],</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test station name&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;status&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;num_bikes_available&quot;</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="attr">&quot;num_docks_available&quot;</span>: <span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;...&#125;,</span><br><span class="line">        &#123;...&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>:<span class="number">1655951937</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-图片示例"><a href="#3-图片示例" class="headerlink" title="3.图片示例"></a>3.图片示例</h4><p>流程（把控制器层和业务层放到一起了）</p><p><img src="https://image.3001.net/images/20220704/16569100158462.png" alt="4"></p><h3 id="3-前后端数据交互代码"><a href="#3-前后端数据交互代码" class="headerlink" title="3.前后端数据交互代码"></a>3.前后端数据交互代码</h3><ul><li>ajax的post请求的代码，前端向后端发送数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sendOptData(params)&#123;</span><br><span class="line">    //后台接口给的相对路径</span><br><span class="line">    const urlPath = &quot;opt/save&quot;;</span><br><span class="line">    $.post(urlPath,params,function(result)&#123;</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-后端返回的代码spring-boot中，controller层返回的数据"><a href="#1-后端返回的代码spring-boot中，controller层返回的数据" class="headerlink" title="1.后端返回的代码spring boot中，controller层返回的数据"></a>1.后端返回的代码spring boot中，controller层返回的数据</h4><ul><li><p>JsonResult返回数据的工具类</p></li><li><p>PieItem实体类两个参数（name，value）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/findOptTypeCount&quot;)</span><br><span class="line">public JsonResult&lt;List&lt;PieItem&gt;&gt; findOptTypeCount()&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;PieItem&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(new PieItem(&quot;点击&quot;,8.0));</span><br><span class="line">    list.add(new PieItem(&quot;缩放&quot;,10.0));</span><br><span class="line">    list.add(new PieItem(&quot;拖拽&quot;,30.0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return JsonResult.getSuccessJR(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回json格式数据</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;state&quot;</span>: <span class="number">1000</span>,</span><br><span class="line"><span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line"><span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;点击&quot;</span>,</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="number">8</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;缩放&quot;</span>,</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;拖拽&quot;</span>,</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-前端请求代码"><a href="#2-前端请求代码" class="headerlink" title="2.前端请求代码"></a>2.前端请求代码</h4><ul><li>先引入jquery</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;../js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>ajax的get请求的代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">     const url = &quot;../opt/findOptTypeCount&quot;</span><br><span class="line">     $.get(url,function (result)&#123;</span><br><span class="line"></span><br><span class="line">         //function中封装的是收到服务器响应后执行的处理逻辑</span><br><span class="line">         //result是接收响应数据</span><br><span class="line">         //1.从result 中获取图标数据</span><br><span class="line">         const pieData = result.data;</span><br><span class="line"></span><br><span class="line">// 2. 基于得到的数据初始化图表</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>合起来的代码是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入echarts的js文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/echarts.minTest.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.在页面中声明图标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:600px;width:800px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.基于echartsapi--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> url = <span class="string">&quot;../opt/findOptTypeCount&quot;</span></span></span><br><span class="line"><span class="javascript">        $.get(url,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//function中封装的是收到服务器响应后执行的处理逻辑</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//result是接收响应数据</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//2.1 从result 中获取图标数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> pieData = result.data;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2.2 基于得到的数据初始化图表</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1.1基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1.2 指定图表的配置项和数据</span></span></span><br><span class="line"><span class="javascript">            option = &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">title</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">text</span>: <span class="string">&#x27;Referer of a Website&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">subtext</span>: <span class="string">&#x27;Fake Data&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">left</span>: <span class="string">&#x27;center&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">tooltip</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">trigger</span>: <span class="string">&#x27;item&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">formatter</span>: <span class="string">&#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">legend</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">orient</span>: <span class="string">&#x27;vertical&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">left</span>: <span class="string">&#x27;left&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">series</span>: [</span></span><br><span class="line"><span class="javascript">                    &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="attr">name</span>: <span class="string">&#x27;访问了&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">radius</span>: <span class="string">&#x27;50%&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">data</span>: pieData,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">emphasis</span>: &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="attr">itemStyle</span>: &#123;</span></span><br><span class="line"><span class="javascript">                                <span class="attr">shadowBlur</span>: <span class="number">10</span>,</span></span><br><span class="line"><span class="javascript">                                <span class="attr">shadowOffsetX</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">                                <span class="attr">shadowColor</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.5)&#x27;</span></span></span><br><span class="line"><span class="javascript">                            &#125;</span></span><br><span class="line"><span class="javascript">                        &#125;,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">label</span>: &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="attr">show</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                            <span class="attr">formatter</span>: <span class="string">&#x27;&#123;b&#125;: &#123;d&#125;%&#x27;</span></span></span><br><span class="line"><span class="javascript">                        &#125;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                ]</span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1.3 使用刚指定的配置项和数据显示图表。</span></span></span><br><span class="line"><span class="javascript">            myChart.setOption(option);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><ul><li><p>Web应用和B/S架构，C/S架构</p><ul><li>前端开发</li><li>后台开发</li><li>移动端开发：Android开发/IOS开发</li></ul></li><li><p>Java Web应用开发环境</p><ul><li>JDK</li><li>IDEA</li><li>Maven</li><li>数据库</li></ul></li><li><p>创建SpringBoot项目</p><ul><li>SpringBoot ：JavaWeb开发的流行框架</li></ul></li><li><p>导入地图应用静态资源</p></li><li><p>采集用户行为用例开发</p><ul><li><p>JavaEE的经典三层架构：控制器层，业务层，持久层</p></li><li><p>开发顺序：需求分析 -&gt; 设计 -&gt; 数据库表 -&gt; 实体类 -&gt; 持久层（包括测试用例） -&gt; 业务层 -&gt; 控制器层 -&gt; 前端页面</p></li><li><p>MyBatis：持久层框架</p><ul><li>声明持久层接口和抽象方法：OperationDAO</li><li>编写Mapper配置文件，绑定SQL语句：OperationMapper.xml</li></ul></li><li><p>Spring：管理整个项目中对象的生命周期的框架</p><ul><li>@Autowired 注解：不再需要new对象，由Spring框架管理和提供</li></ul></li><li><p>Spring MVC框架：控制器层框架</p><ul><li><p>@RequestMapping：建立控制器方法到路径的映射</p></li><li><p>@RestController：标记当前类是一个Controller，同时自动将方法返回值转换为JSON格式 </p></li><li><p>自动进行请求参数的封装</p><ul><li><p>控制器方法：<code>saveOperation(OperationDO optDO)</code></p></li><li><p>前端请求：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const params=&#123;</span><br><span class="line">&quot;optType&quot;:1,</span><br><span class="line">&quot;zoomStartLevel&quot;:15.0,</span><br><span class="line">&quot;zoomEndLevel&quot;:16.5</span><br><span class="line">&#125;</span><br><span class="line">$.post(url,params,funciton(result)&#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>用户行为数据可视化用例开发</p><ul><li>ECharts：基于JavaScript的数据可视化插件<ul><li>页面中引入ECharts的js文件</li><li>页面中声明一个div作为图表的容器</li><li>使用ECharts的js的API，初始化图表<ul><li>创建图表对象，绑定容器id</li><li>创建配置项对象，配置图表的样式和数据</li><li>图表对象应用配置项对象，显示图表</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;echarts使用步骤文档&quot;&gt;&lt;a href=&quot;#echarts使用步骤文档&quot; class=&quot;headerlink&quot; title=&quot;echarts使用步骤文档&quot;&gt;&lt;/a&gt;echarts使用步骤文档&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;目前我们已经采集到一定数量的用户数据，管理者希望能够查看这些用户数据。&lt;/p&gt;
&lt;p&gt;需要将数据库中存储的原始数据进行初步的统计分析后，以可视化图表的形式加以展示。&lt;/p&gt;
&lt;p&gt;例如：显示用户各类操作的总数量和比例。&lt;/p&gt;</summary>
    
    
    
    
    <category term="echarts" scheme="https://yangmour.github.io/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>购买云服务器与配置</title>
    <link href="https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/%E8%B4%AD%E4%B9%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/%E8%B4%AD%E4%B9%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/"/>
    <id>https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/%E8%B4%AD%E4%B9%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/%E8%B4%AD%E4%B9%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/</id>
    <published>2022-06-25T05:06:17.000Z</published>
    <updated>2022-09-08T02:17:06.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="购买云服务器与配置"><a href="#购买云服务器与配置" class="headerlink" title="购买云服务器与配置"></a>购买云服务器与配置</h1><p>[TOC]</p><h2 id="1-购买云服务器"><a href="#1-购买云服务器" class="headerlink" title="1.购买云服务器"></a>1.购买云服务器</h2><h3 id="1-购买成功需要自己启动"><a href="#1-购买成功需要自己启动" class="headerlink" title="1.购买成功需要自己启动"></a>1.购买成功需要自己启动</h3><h3 id="2-重置密码"><a href="#2-重置密码" class="headerlink" title="2.重置密码"></a><img src="https://image.3001.net/images/20220623/16559778215622.png" alt="image-20220623163659230">2.重置密码</h3><span id="more"></span><h3 id="3-设置安全组"><a href="#3-设置安全组" class="headerlink" title="3.设置安全组"></a>3.设置安全组</h3><p>一开始没设置3306端口就进不来，如果有需要开发端口</p><p><img src="https://image.3001.net/images/20220623/16559778245048.png" alt="9"></p><h4 id="1-点击"><a href="#1-点击" class="headerlink" title="1.点击"></a>1.点击</h4><p><img src="https://image.3001.net/images/20220623/16559778305363.png" alt="image-20220623163924482"></p><h4 id="2-点击后"><a href="#2-点击后" class="headerlink" title="2.点击后"></a>2.点击后</h4><p><img src="https://image.3001.net/images/20220623/16559778322148.png" alt="image-20220623164147437"></p><h4 id="3-开动80端口"><a href="#3-开动80端口" class="headerlink" title="3.开动80端口"></a>3.开动80端口</h4><ul><li>默认</li></ul><p><img src="https://image.3001.net/images/20220623/16559778361973.png" alt="image-20220623164534202"></p><ul><li>要设置的方式</li><li><h2 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h2></li></ul><p><img src="https://image.3001.net/images/20220623/16559778394070.png" alt="image-20220623164648796"></p><ul><li>ssh链接方式</li></ul><p><img src="https://image.3001.net/images/20220623/16559778413163.png" alt="10"></p><h2 id="2-云主机基础配置"><a href="#2-云主机基础配置" class="headerlink" title="2. 云主机基础配置"></a>2. 云主机基础配置</h2><ul><li><p>配置云主机的hostname</p><ul><li>设置hostname（设置完成后需要重启）</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname master</span><br></pre></td></tr></table></figure><p>  查询当前主机的hostname</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure><pre><code>注意：如显示master，则说明配置成功，当前xshell终端的hostname不会自动修改，重新连接一次即可。</code></pre></li><li><p>修改hosts文件</p><ul><li>编辑hosts文件</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><ul><li><p>按i进入编辑模式，新起一行，ip为当前云主机的内网ip，tab键之后，填写master</p><p>  按esc退出编辑模式，输入:wq!，保存本次修改并退出。</p></li></ul></li></ul><p><img src="https://image.3001.net/images/20220623/16559778433326.png"></p><ul><li>DNS寻址</li></ul><p><img src="https://image.3001.net/images/20220704/16569109112330.png" alt="image-20220628092805118"></p><ul><li><p>关闭云主机的防火墙</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service            #停止firewall</span><br><span class="line">systemctl disable firewalld.service        #禁止firewall开机启动</span><br><span class="line">firewall-cmd --state #查看firewall运行状态 如显示not running，则配置成功</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="云主机安装MariaDB"><a href="#云主机安装MariaDB" class="headerlink" title="云主机安装MariaDB"></a>云主机安装MariaDB</h3><p>在云主机中输入：<code>yum install mariadb-server</code>，在线安装Mariadb</p><p><img src="https://image.3001.net/images/20220704/16569095187333.png" alt="img"></p><p>进入自动安装，完毕会有如下提示：</p><p><img src="https://image.3001.net/images/20220704/16569095203743.png" alt="img"></p><p>第一次使用MariaDB之前，需要进行初始化操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">启动MariaDB</span><br><span class="line">systemctl start mariadb</span><br><span class="line"></span><br><span class="line">设置开机启动</span><br><span class="line">systemctl enable mariadb</span><br><span class="line"></span><br><span class="line">MariaDB初始化配置</span><br><span class="line">mysql_secure_installation</span><br><span class="line"></span><br><span class="line">密码验证，初次直接敲回车</span><br><span class="line">Enter current password for root (enter for none):&lt;–初次运行直接回车</span><br><span class="line"></span><br><span class="line">设置root用户密码-教学这里使用root</span><br><span class="line">Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车</span><br><span class="line">New password: &lt;– 设置root用户的密码</span><br><span class="line">Re-enter new password: &lt;– 再输入一次你设置的密码</span><br><span class="line"></span><br><span class="line">其他配置：</span><br><span class="line">Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车</span><br><span class="line">Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车,</span><br><span class="line">Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车</span><br><span class="line">Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/16569095246353.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录MariaDB:</span><br><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/16569095262416.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">退出MariaDB</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><h3 id="云主机安装JDK"><a href="#云主机安装JDK" class="headerlink" title="云主机安装JDK"></a>云主机安装JDK</h3><ul><li>进入<code>/opt/software/java</code>目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software</span><br><span class="line">mkdir java</span><br><span class="line">cd java</span><br></pre></td></tr></table></figure><ul><li><p>下载linux-jdk1.8版本压缩文件到到本地<code>/opt</code>目录下</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/java/jdk/8u152-b16/jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压缩到目录下</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u152-linux-x64.tar.gz</span><br><span class="line">mv jdk1.8.0_251 jdk1.8</span><br></pre></td></tr></table></figure></li><li><p>查看是否解压成功</p><p>  <img src="https://image.3001.net/images/20220704/1656909530134.png"></p></li><li><p>配置环境变量</p><p>  编辑<code>/etc/profile</code>文件</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>  vim会开启文档查看窗口，默认情况下不可修改文档内容，可以使用键盘的方向键浏览文档。这里使用<code>↓</code>移动到文档的最后一行，按键盘上的<code>i</code>键进入编辑模式，会看到文档下方提示<code>-- INSERT --</code>，该模式下可以对文档内容进行修改。</p><p>  在最后一行后面新起几行，添加如下内容：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/software/java/jdk1.8</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH:$HOME/bin</span><br></pre></td></tr></table></figure><p>  然后按ESC退出编辑模式，输入<code>:wq!</code>保存本次修改并退出<code>vim</code>。</p><p>  对<code>/etc/profile</code>文件的修改默认不会马上生效，可以使用命令<code>source /etc/profile</code>让本次修改在当前访问中生效。</p></li><li><p>验证是否配置成功，使用<code>java -version</code>命令</p><p>  <img src="https://image.3001.net/images/20220704/16569095331583.png"></p></li></ul><h3 id="云主机安装Tomcat"><a href="#云主机安装Tomcat" class="headerlink" title="云主机安装Tomcat"></a>云主机安装Tomcat</h3><ul><li>进入<code>/opt/software/tomcat</code>目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software</span><br><span class="line">mkdir tomcat</span><br><span class="line">cd tomcat</span><br></pre></td></tr></table></figure><ul><li>下载Tomcat8.5安装文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/apache/tomcat/tomcat-8/v8.5.63/bin/apache-tomcat-8.5.63.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/1656909554457.png"></p><ul><li>解压缩</li></ul><p>将Tomcat安装文件解压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.63.tar.gz</span><br></pre></td></tr></table></figure><p>查看并将文件夹重命名为<code>tomcat-8.5</code></p><p><img src="https://image.3001.net/images/20220704/1656909567532.png" alt="image-20220626112211752"></p><ul><li>配置环境变量</li></ul><p>编辑<code>/etc/profile</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>vim会开启文档查看窗口，默认情况下不可修改文档内容，可以使用键盘的方向键浏览文档。这里使用<code>↓</code>移动到文档的最后一行，按键盘上的<code>i</code>键进入编辑模式，会看到文档下方提示<code>-- INSERT --</code>，该模式下可以对文档内容进行修改。</p><p>在文件最后声明<code>CATALINA_HOME</code>变量，并将<code>$CATALINA_HOME/bin</code>添加到<code>PATH</code>变量中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/jdk1.8.0</span><br><span class="line">export CATALINA_HOME=/opt/tomcat-8.5</span><br><span class="line">export PATH=$CATALINA_HOME/bin:$JAVA_HOME/bin:$PATH:$HOME/bin</span><br></pre></td></tr></table></figure><p>然后按ESC退出编辑模式，输入<code>:wq!</code>保存本次修改并退出<code>vim</code>。</p><p>对<code>/etc/profile</code>文件的修改默认不会马上生效，可以使用命令<code>source /etc/profile</code>让本次修改在当前访问中生效。</p><p>配置成功后，检查环境变量是否配置成功，可以输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version.sh</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/16569095824368.png"></p><p>如果可以输出上述信息，则环境变量配置成功。如果提示<code>command not found</code>，则表示配置失败，需要重新对<code>/etc/profile</code>进行配置。</p><p>解决Centos7下Tomcat启动过慢的问题：配置JVM使用伪随机函数生成器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/software/java/jdk1.8/jre/lib/security/java.security</span><br></pre></td></tr></table></figure><p>将117行修改为<code>securerandom.source=file:/dev/urandom</code></p><p><img src="https://image.3001.net/images/20220704/16569095957146.png"></p><ul><li>启动Tomcat</li></ul><p>可以直接使用命令启动Tomcat：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.sh</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/16569096115795.png"></p><p>我们可以通过本地浏览器，远程访问云主机上的Tomcat首页。</p><p>关闭Tomcat的命令为<code>shutdown.sh</code>。</p><p>需要注意，还应该在阿里云主机控制台安全组设定中，添加一条入方向规则，开放8080端口：</p><p><img src="https://image.3001.net/images/20220704/16569096219972.png" alt="img"></p><p>开发端口后，在云主机上启动Tomcat，然后在本地浏览器中输入<code>http://云主机公网ip:8080</code>，可以访问到云主机的Tomcat首页：</p><p><img src="https://image.3001.net/images/20220704/165690963727.png" alt="12"></p><h2 id="3-将项目打包上传到云主机"><a href="#3-将项目打包上传到云主机" class="headerlink" title="3.将项目打包上传到云主机"></a>3.将项目打包上传到云主机</h2><p>传统的web项目部署war包方式和springboot内置了tomcat的基于jar的方式图解</p><p><img src="https://image.3001.net/images/20220704/16569096539943.png" alt="image-20220627105424634"></p><h3 id="1-传统的web项目部署war包方式（后续补充）"><a href="#1-传统的web项目部署war包方式（后续补充）" class="headerlink" title="1.传统的web项目部署war包方式（后续补充）"></a>1.传统的web项目部署war包方式（后续补充）</h3><h3 id="2-springboot内置了tomcat的基于jar的方式"><a href="#2-springboot内置了tomcat的基于jar的方式" class="headerlink" title="2.springboot内置了tomcat的基于jar的方式"></a>2.springboot内置了tomcat的基于jar的方式</h3><h4 id="1-修改yml配置文件或者properties文件中"><a href="#1-修改yml配置文件或者properties文件中" class="headerlink" title="1.修改yml配置文件或者properties文件中"></a>1.修改yml配置文件或者properties文件中</h4><p><strong>将server.post端口改成80</strong></p><p>1.我用的是yml文件配置两种环境生产模式和开发模式</p><p>​    我在云服务器中配置了环境变量，会切换到生产模式，如果没有配置环境变量会默认开发模式(dev).</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#环境变量名称</span><br><span class="line">PRODUCTION</span><br><span class="line">#环境变量值</span><br><span class="line">prod</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/16569096682581.png" alt="image-20220627111407536"></p><p><img src="https://image.3001.net/images/20220704/16569096859218.png" alt="image-20220627111424716"></p><h4 id="2-maven命令打包"><a href="#2-maven命令打包" class="headerlink" title="2.maven命令打包"></a>2.maven命令打包</h4><p><img src="https://image.3001.net/images/20220704/16569096979129.png" alt="image-20220627111018807"></p><h4 id="3-将jar包改名上传-如-nybike-jar"><a href="#3-将jar包改名上传-如-nybike-jar" class="headerlink" title="3.将jar包改名上传(如:nybike.jar)"></a>3.将jar包改名上传(如:nybike.jar)</h4><p>​    用<code>tabby</code>的sftp工具上传到<code>/opt/software/java/jar</code>路径下</p><p><img src="https://image.3001.net/images/20220704/16569097137335.png" alt="image-20220627111956580"></p><p>上传成功</p><h4 id="4-进入云主机的数据库"><a href="#4-进入云主机的数据库" class="headerlink" title="4.进入云主机的数据库"></a>4.进入云主机的数据库</h4><p>创建数据库、创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot</span><br><span class="line"></span><br><span class="line">-- 创建数据库</span><br><span class="line">create database nybikedb;</span><br><span class="line"></span><br><span class="line">-- 使用库</span><br><span class="line">use nybikedb;</span><br><span class="line"></span><br><span class="line">-- 创建表</span><br><span class="line">create table t_operation(</span><br><span class="line">id int primary key auto_increment comment &#x27;主键&#x27;,</span><br><span class="line">user_ip varchar(32) comment &#x27;用户IP&#x27;,</span><br><span class="line">created_time timestamp comment &#x27;创建时间&#x27;,</span><br><span class="line">opt_type int comment &#x27;操作类型，0-点击，1-缩放，2-拖拽&#x27;,</span><br><span class="line">zoom_start_level double comment &#x27;缩放开始级别&#x27;,</span><br><span class="line">zoom_end_level double comment &#x27;缩放终止级别&#x27;,</span><br><span class="line">drag_start_lat double comment &#x27;拖拽起始纬度&#x27;,</span><br><span class="line">drag_start_lng double comment &#x27;拖拽起始经度&#x27;, </span><br><span class="line">drag_end_lat double comment &#x27;拖拽终止纬度&#x27;, </span><br><span class="line">drag_end_lng double comment &#x27;拖拽终止经度&#x27;,  </span><br><span class="line">station_id varchar(20) comment &#x27;点击的站点ID&#x27;</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">-- 查看表是否创建成功</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/16569097255586.png" alt="image-20220627112908258"></p><h4 id="5-启动命令"><a href="#5-启动命令" class="headerlink" title="5.启动命令"></a>5.启动命令</h4><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行命令</span></span><br><span class="line">nohup java -jar xxx.jar &gt; catalina.out 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">停止命令</span></span><br><span class="line">kill -9 进程的号(如下面启动的1709jar包的进程)</span><br></pre></td></tr></table></figure><p>1.本次项目用到的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar /opt/software/java/jar/nybike.jar &gt; /opt/software/java/jar/nybike.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>输入成功图片</p><p><img src="https://image.3001.net/images/20220704/16569097389239.png" alt="image-20220627120404448"></p><p>2.jps查看</p><p><img src="https://image.3001.net/images/20220704/16569097513983.png" alt="image-20220627120441076"></p><p>3.通过浏览器访问网页</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://云服务的公网ip/nymap.html</span><br><span class="line"></span><br><span class="line">#地图服务</span><br><span class="line">http://123.57.135.112/nymap.html </span><br><span class="line">#可视化服务</span><br><span class="line">http://123.57.135.112/demo/opt_typy_count.html </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220704/16569097705431.png" alt="image-20220627120712016"></p><p><strong>命令参数解析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#完整的命令</span><br><span class="line">nohup java -jar xxx.jar &gt; catalina.out 2&gt;&amp;1 &amp;</span><br><span class="line">#运行命令</span><br><span class="line">nohup java -jar xxx.jar</span><br><span class="line">#日志文件输出到catalina.out文件中， 2&gt;$1的意思是运行的日志和报错的日志都放到catalina.out日志文件中</span><br><span class="line"> &gt; catalina.out 2&gt;&amp;1</span><br><span class="line">#最后面的&#x27;&amp;&#x27;是后台运行程序</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure><p><strong>项目启动失败的解决方案</strong></p><p><img src="https://image.3001.net/images/20220704/16569097835489.png" alt="8"></p><p>1.导致nybike项目启动失败的原因可能有多个，必须通过日志去识别具体的失败原因。</p><p>使用cat 命令查看<code>/opt/nybike.out</code>，从中找到异常信息，确定启动失败的实际原因。</p><p>2.本地数据库与云主机数据库密码不一致</p><ul><li><p>启动后，地图上直接各类操作时，反馈500的状态码，查看服务器上的nybike.out的内容，可以看到</p><p>  <img src="https://image.3001.net/images/20220704/16569097952544.png" alt="image-20220627164358591"></p></li><li><p>修改本地IDEA项目中 application.properties中配置的数据库密码</p></li><li><p>本地修改完成后，需要使用maven重新打包项目，打包完成后，target文件夹下的<code>nybike-0.0.1-SNAPSHOT.jar</code>会被自动更新成最新的内容，然后重新将该文件上传到云主机上</p></li><li><p>云主机上原来的<code>/opt/nybike.jar</code>文件需要删除</p><ul><li>命令<code>rm -f /opt/nybike.jar</code></li><li>也可以在Tabby中SFTP中，右键该文件，选择Delete</li></ul></li><li><p><strong>注：</strong>云主机上运行的旧的nybike项目也必须停掉</p></li><li><p><img src="images/image-20220627164419764.png" alt="image-20220627164419764"></p></li><li><p>命令：<code>kill -9 27351</code>，其中27351是进程id</p></li><li><p>之后再使用<code>nohup...</code>去启动新的项目</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;购买云服务器与配置&quot;&gt;&lt;a href=&quot;#购买云服务器与配置&quot; class=&quot;headerlink&quot; title=&quot;购买云服务器与配置&quot;&gt;&lt;/a&gt;购买云服务器与配置&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-购买云服务器&quot;&gt;&lt;a href=&quot;#1-购买云服务器&quot; class=&quot;headerlink&quot; title=&quot;1.购买云服务器&quot;&gt;&lt;/a&gt;1.购买云服务器&lt;/h2&gt;&lt;h3 id=&quot;1-购买成功需要自己启动&quot;&gt;&lt;a href=&quot;#1-购买成功需要自己启动&quot; class=&quot;headerlink&quot; title=&quot;1.购买成功需要自己启动&quot;&gt;&lt;/a&gt;1.购买成功需要自己启动&lt;/h3&gt;&lt;h3 id=&quot;2-重置密码&quot;&gt;&lt;a href=&quot;#2-重置密码&quot; class=&quot;headerlink&quot; title=&quot;2.重置密码&quot;&gt;&lt;/a&gt;&lt;img src=&quot;https://image.3001.net/images/20220623/16559778215622.png&quot; alt=&quot;image-20220623163659230&quot;&gt;2.重置密码&lt;/h3&gt;</summary>
    
    
    
    
    <category term="购买云服务器与配置" scheme="https://yangmour.github.io/tags/%E8%B4%AD%E4%B9%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot教程</title>
    <link href="https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/spring/SpringBoot%E6%95%99%E7%A8%8B/SpringBoot%E6%95%99%E7%A8%8B/"/>
    <id>https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/spring/SpringBoot%E6%95%99%E7%A8%8B/SpringBoot%E6%95%99%E7%A8%8B/</id>
    <published>2022-06-25T05:06:17.000Z</published>
    <updated>2022-09-08T02:17:06.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot教程"><a href="#Spring-Boot教程" class="headerlink" title="Spring Boot教程"></a>Spring Boot教程</h1><p>[TOC]</p><h2 id="1-idea创建Spring-boot项目"><a href="#1-idea创建Spring-boot项目" class="headerlink" title="1.idea创建Spring boot项目"></a>1.idea创建Spring boot项目</h2><p>在IDEA中创建一个Java Web项目。</p><ul><li>Spring Boot 项目（本次使用）</li></ul><p><img src="https://image.3001.net/images/20220625/16561510931991.png"></p><span id="more"></span><img src="https://image.3001.net/images/20220625/16561510912110.png" style="zoom:33%;" /><img src="https://image.3001.net/images/20220625/16561510882754.png" style="zoom:33%;" /><img src="https://image.3001.net/images/20220625/16561510862906.png" style="zoom:33%;" /><p>项目创建完成后，Maven会自动进行相关依赖jar文件的下载，首次下载需要等待的时间较长。下载完成后，右侧Maven工具栏中不再出现报错信息：</p><img src="https://image.3001.net/images/20220625/16561510831878.png" style="zoom:33%;" /><img src="https://image.3001.net/images/20220625/16561510818999.png" style="zoom:33%;" /><h2 id="2-导入地图服务的相关内容"><a href="#2-导入地图服务的相关内容" class="headerlink" title="2. 导入地图服务的相关内容"></a>2. 导入地图服务的相关内容</h2><h3 id="在IDEA中创建一个Java-Web项目。"><a href="#在IDEA中创建一个Java-Web项目。" class="headerlink" title="在IDEA中创建一个Java Web项目。"></a>在IDEA中创建一个Java Web项目。</h3><p>将<code>大数据方向实训课前资料\2.地图页面\static.zip</code>解压缩后，将static文件夹下的所有内容拷贝到项目的<code>src/main/resource/static</code>目录下。</p><img src="https://image.3001.net/images/20220625/16561510788729.png" style="zoom: 33%;" /><p>nymap.html中保存了地图服务的代码，可以打开该页面，点击右侧的浏览器按钮，使用本地浏览器访问该页面。</p><img src="https://image.3001.net/images/20220625/1656151074265.png" style="zoom:33%;" /><h3 id="地图服务背景知识"><a href="#地图服务背景知识" class="headerlink" title="地图服务背景知识"></a>地图服务背景知识</h3><p><img src="https://image.3001.net/images/20220625/16561510694200.png"></p><h2 id="3-服务器端开发"><a href="#3-服务器端开发" class="headerlink" title="3. 服务器端开发"></a>3. 服务器端开发</h2><h3 id="服务器端程序的作用："><a href="#服务器端程序的作用：" class="headerlink" title="服务器端程序的作用："></a>服务器端程序的作用：</h3><ul><li>能够接受浏览器发来的请求，获取浏览器发来的用户行为数据</li><li>将用户行为数据写入到数据库中</li></ul><p><img src="https://image.3001.net/images/20220625/16561510667753.png"></p><p>用例（Use Case）组件设计：</p><img src="https://image.3001.net/images/20220625/16561510645771.png" style="zoom:33%;" /><h3 id="首次运行持久层测试用例前的配置（选一种配置文件方法）"><a href="#首次运行持久层测试用例前的配置（选一种配置文件方法）" class="headerlink" title="首次运行持久层测试用例前的配置（选一种配置文件方法）"></a>首次运行持久层测试用例前的配置（选一种配置文件方法）</h3><p>​    有一种配置是yml文件的，properties和yml配置文件使用一种就行（两种都存在就删掉一种，两种同时存在的话应该是后面的会把前面的配置覆盖掉）</p><h4 id="1-配置文件修改"><a href="#1-配置文件修改" class="headerlink" title="1.配置文件修改"></a>1.配置文件修改</h4><p>方案一 <code>application.properties</code>修改(也可以多文档切换配置，需要看官网文档)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nybike</span></span><br><span class="line"><span class="comment">#下面这些内容是为了让MyBatis映射</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mappers/*xml</span></span><br><span class="line"><span class="comment"># 数据库驱动：</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 数据库连接地址</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/nybikedb?serverTimezone=UTC</span></span><br><span class="line"><span class="comment"># 数据库用户名&amp;密码：</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>方案二 <code>.yml</code>文件配置</p><p>​    生产环境和开发环境自动切换，默认是开发模式，如果需要使用生产模式可以创建环境变量</p><p>​    <strong>如果windows中不想写环境变量idea也可以修改某个地方即可即可切换为开发环境,就不用修改环境变量了，直接做第2小结就可以了</strong></p><p><img src="https://image.3001.net/images/20220625/16561510586635.png" alt="image-20220625174925928"></p><p><img src="https://image.3001.net/images/20220625/16561510555525.png" alt="image-20220625175434994"></p><p>1.配置环境变量</p><p><img src="https://image.3001.net/images/20220625/16561510503614.png" alt="image-20220625172840322"></p><ul><li><p>变量名</p><p>  <img src="https://image.3001.net/images/20220625/16561510444827.png" alt="image-20220625173128731"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRODUCTION</span><br></pre></td></tr></table></figure><ul><li>变量值</li></ul><p><img src="https://image.3001.net/images/20220625/16561510421304.png" alt="image-20220625173735365"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prod</span><br></pre></td></tr></table></figure><p>​    **注意：windows电脑需要重启让环境变量生效，linux中用环境变量生效命令 **</p><p>2.Spring boot默认初始会先看application.yml文件</p><p><code>application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment">#自动切换默认为dev模式</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">$&#123;PRODUCTION:dev&#125;</span></span><br></pre></td></tr></table></figure><p><code>application-dev.yml</code>   开发模式配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nybike</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 数据库驱动：</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment"># 数据库连接地址</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:33068/nybikedb?serverTimezone=UTC</span></span><br><span class="line">    <span class="comment"># 数据库用户名&amp;密码：</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xiwen123</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">dbcp2:</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span>                                <span class="comment"># 数据库连接池的最小维持连接数</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span>                            <span class="comment"># 初始化连接数</span></span><br><span class="line">      <span class="attr">max-total:</span> <span class="number">5</span>                               <span class="comment"># 最大连接数</span></span><br><span class="line">      <span class="attr">max-wait-millis:</span> <span class="number">150</span>                       <span class="comment"># 等待连接获取的最大超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面这些内容是为了让MyBatis映射</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment">#指定Mybatis的Mapper文件位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mappers/*xml</span></span><br><span class="line">  <span class="comment"># 实体类所在的位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.tedu.nybike.entity</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span>   <span class="comment">#用于控制台打印sql语句</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>application-prop.yml</code>    生产环境配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nybike</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 数据库驱动：</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment"># 数据库连接地址</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:33068/nybikedb?serverTimezone=UTC</span></span><br><span class="line">    <span class="comment"># 数据库用户名&amp;密码：</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xiwen123</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">dbcp2:</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span>                                <span class="comment"># 数据库连接池的最小维持连接数</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span>                            <span class="comment"># 初始化连接数</span></span><br><span class="line">      <span class="attr">max-total:</span> <span class="number">5</span>                               <span class="comment"># 最大连接数</span></span><br><span class="line">      <span class="attr">max-wait-millis:</span> <span class="number">150</span>                       <span class="comment"># 等待连接获取的最大超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面这些内容是为了让MyBatis映射</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment">#指定Mybatis的Mapper文件位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mappers/*xml</span></span><br><span class="line">  <span class="comment"># 实体类所在的位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.tedu.nybike.entity</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span>   <span class="comment">#用于控制台打印sql语句</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="项目中文件截图"><a href="#项目中文件截图" class="headerlink" title="项目中文件截图"></a>项目中文件截图</h4><p><img src="https://image.3001.net/images/20220625/1656151036287.png" alt="image-20220625174512236"></p><h3 id="1-开发实体类"><a href="#1-开发实体类" class="headerlink" title="1.开发实体类"></a>1.开发实体类</h3><ol><li><p>创建<code>cn.tedu.nybike.entity</code>包</p></li><li><p>在<code>entity</code>包下新建<code>OperationDO</code>类，用于封装用户的一次操作记录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class OperationDO &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String userIp;</span><br><span class="line">    private Date createdTime;</span><br><span class="line">    private Integer optType;</span><br><span class="line">    private Double zoomStartLevel;</span><br><span class="line">    private Double zoomEndLevel;</span><br><span class="line">    private Double dragStartLat;</span><br><span class="line">    private Double dragStartLng;</span><br><span class="line">    private Double dragEndLat;</span><br><span class="line">    private Double dragEndLng;</span><br><span class="line">    private String stationId;</span><br><span class="line">// 这里省略toString, get/set, 无参构造器    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>cn.tedu.nybike.util</code>包</p></li><li><p>将<code>unti.zip</code>解压缩，将其中的2个文件<code>JsonResult.java</code>和<code>IpUtils.java</code>复制到util包中</p></li></ol><h3 id="2-开发持久层"><a href="#2-开发持久层" class="headerlink" title="2.开发持久层"></a>2.<strong>开发持久层</strong></h3><ol><li><p>创建<code>cn.tedu.nybike.dao</code>包</p></li><li><p>在<code>dao</code>包下创建<code>OperationDAO</code>接口（interface）</p></li><li><p>在<code>OpeartionDAO</code>接口中声明抽象方法<code>insertOperation(OperationDO optDO)</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户操作模块的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperationDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向数据库中添加一行操作记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optDO 一行操作记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 添加成功的数据条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertOperation</span><span class="params">(OperationDO optDO)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>src/main/resources</code>下创建<code>mappers</code>文件夹</p></li><li><p>将下载的<code>OperationMapper.xml</code>拷贝到<code>mappers</code>文件夹中</p></li><li><p>在<code>OperationMapper.xml</code>中添加要执行的SQL语句</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace：当前XML文件用于配置哪个接口中抽象方法对应的SQL语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.tedu.nybiket.dao.OperationDAO&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--向数据库中添加一行操作记录--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--int insertOperation(OperationDO optDO)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertOperation&quot;</span> &gt;</span></span><br><span class="line">insert into t_operation(</span><br><span class="line">user_ip, created_time, opt_type,</span><br><span class="line">zoom_start_level, zoom_end_level,</span><br><span class="line">drag_start_lat, drag_start_lng,</span><br><span class="line">drag_end_lat, drag_end_lng, station_id</span><br><span class="line">) values (</span><br><span class="line">#&#123;userIp&#125;, now(), #&#123;optType&#125;,</span><br><span class="line">#&#123;zoomStartLevel&#125;, #&#123;zoomEndLevel&#125;,</span><br><span class="line">#&#123;dragStartLat&#125;, #&#123;dragStartLng&#125;,</span><br><span class="line">#&#123;dragEndLat&#125;, #&#123;dragEndLng&#125;, #&#123;stationId&#125;</span><br><span class="line">)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-开发持久层测试用例"><a href="#3-开发持久层测试用例" class="headerlink" title="3.开发持久层测试用例"></a>3.<strong>开发持久层测试用例</strong></h3><ol><li><p>打开<code>OperationDAO</code>接口，光标点击接口中任意一行，右键 -&gt; <code>Generate...</code> -&gt; <code>Test...</code>，打开自动生成测试用例的对话框</p></li><li><p>对话框中的内容保持默认，勾选<code>insertOperation..</code>方法前的复选框，点击OK</p></li><li><p>IDEA会在动在<code>src/test/java</code>下的对应包中生成测试类<code>OprtionDAOTest</code></p></li><li><p>在该类中编写测试用例</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationDAOTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该注解的作用是通知Spring框架查找OperationDAO类型的对象</span></span><br><span class="line">    <span class="comment">// 将该对象的引用添加到dao属性中</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    OperationDAO dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个DO对象，封装要添加到数据库中的数据</span></span><br><span class="line">        OperationDO optDO=<span class="keyword">new</span> OperationDO();</span><br><span class="line">        optDO.setUserIp(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        optDO.setStationId(<span class="string">&quot;7789&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用dao的方法，将数据写入数据库</span></span><br><span class="line">        <span class="keyword">int</span> row = dao.insertOperation(optDO);</span><br><span class="line">        <span class="comment">// 在控制台输出插入成功的数据条数</span></span><br><span class="line">        System.err.println(<span class="string">&quot;row=&quot;</span>+row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-在项目的主类（cn-tedu-nybike-NybikeApplication）前添加注解"><a href="#4-在项目的主类（cn-tedu-nybike-NybikeApplication）前添加注解" class="headerlink" title="4.在项目的主类（cn.tedu.nybike.NybikeApplication）前添加注解"></a>4.在项目的主类（cn.tedu.nybike.NybikeApplication）前添加注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这是应该是配置的base-package范围太大，导致service层的接口也被包装，将base-package的范围缩小到dao即可</span><br><span class="line">//改成@MapperScan(&quot;cn.tedu.nybike.dao&quot;)</span><br><span class="line">@MapperScan(&quot;cn.tedu.nybike.dao&quot;)</span><br><span class="line">public class NybikeApplication &#123;</span><br></pre></td></tr></table></figure><p><strong>运行测试用例</strong></p><p>点击测试方法前的绿色播放键，执行测试用例，如出现如下提示，表示测试用例运行成功。</p><p><img src="https://image.3001.net/images/20220625/16561510339271.png"></p><h3 id="5-开发业务层"><a href="#5-开发业务层" class="headerlink" title="5.开发业务层"></a>5.<strong>开发业务层</strong></h3><p>在src/main/java下新建<code>cn.tedu.nybike.service</code>包。</p><p>在该包下新建<code>OperationService</code>接口，并在类中开发对应的业务层方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.nybike.service;</span><br><span class="line"></span><br><span class="line">import cn.tedu.nybike.entity.OperationDO;</span><br><span class="line">import cn.tedu.nybike.entity.PieItem;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface OperationService &#123;</span><br><span class="line">    //保存数据</span><br><span class="line">    void saveOperation(OperationDO optDO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在src/main/java下新建<code>cn.tedu.nybike.service.Impl</code>包。</p><p>在该包下新建<code>OperationServiceImpl</code>类继承<code>OperationService</code>接口，并在类中开发对应的业务层方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.nybiket.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.tedu.nybiket.dao.OperationDAO;</span><br><span class="line"><span class="keyword">import</span> cn.tedu.nybiket.entity.OperationDO;</span><br><span class="line"><span class="keyword">import</span> cn.tedu.nybiket.util.IPUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户操作模块的业务层类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    OperationDAO dao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存一条用户操作记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optDO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOperation</span><span class="params">(OperationDO optDO)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前发请求用户的IP地址</span></span><br><span class="line">        String userIp = IPUtils.getIpAddr();</span><br><span class="line">        <span class="comment">// 将IP地址添加到optDO对象中</span></span><br><span class="line">        optDO.setUserIp(userIp);</span><br><span class="line">        <span class="comment">// 调用持久层方法，保存操作记录</span></span><br><span class="line">        dao.insertOperation(optDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-开发业务层测试用例"><a href="#6-开发业务层测试用例" class="headerlink" title="6.开发业务层测试用例"></a>6.<strong>开发业务层测试用例</strong></h3><p>光标选中<code>OperationService</code>类中任意位置，右键 -&gt;Generate… -&gt; Test… ，在里面勾选<code>saveOpeartion</code>前面的复选框，然后点OK，自动生成测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OperationService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OperationDO optDO = <span class="keyword">new</span> OperationDO();</span><br><span class="line">        service.saveOperation(optDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-开发控制器层"><a href="#7-开发控制器层" class="headerlink" title="7.开发控制器层"></a>7.<strong>开发控制器层</strong></h3><p>在src/main/java下新建<code>cn.tedu.nybike.controller</code>包。</p><p>在该包下新建<code>OperationController</code>类，并在类中开发对应的控制器层方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/opt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OperationService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title">saveOperation</span><span class="params">(OperationDO optDO)</span></span>&#123;</span><br><span class="line">        <span class="comment">// TODO 参数验证：非空验证、格式验证、逻辑验证</span></span><br><span class="line">        <span class="comment">// 调用业务层方法，保存optDO</span></span><br><span class="line">        service.saveOperation(optDO);</span><br><span class="line">        <span class="comment">// 返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> JsonResult.getSuccessJR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-测试控制器层"><a href="#8-测试控制器层" class="headerlink" title="8.测试控制器层"></a>8.<strong>测试控制器层</strong></h3><p>通过项目主类<code>NybikeApplication</code>的main方法启动项目。</p><p>在浏览器地址栏访问<code>http://localhost:8080/opt/save?optType=1&amp;stationId=1234</code>，如果页面显示如下信息，说明访问成功。</p><img src="https://image.3001.net/images/20220625/16561510282164.png" style="zoom:24%;" /><p>常见问题：</p><ul><li><p>如果显示连接被拒绝，或无法连接：项目没有正常启动</p></li><li><p>如果显示连接异常，状态码为404：请求的路径和控制器层提供的路径不对应，检查<code>OperationController</code>中两个<code>@RequestMapping</code>注解的值是否正确</p></li><li><p>如果显示连接异常，状态码为500：服务器执行程序时出现异常，在IDEA的控制台中会有具体的报错信息，根据报错信息排查对应的问题</p></li><li><p>如果提交了请求参数，但是查询数据库时发现对应的参数值没有被写进数据库：一般是提交参数的参数名和实体类中的属性名不一致导致的，核对参数名和属性名</p></li><li><p>注：对服务器代码进行修改后，需要重启项目，新的代码才会生效</p><p>  <img src="https://image.3001.net/images/20220625/16561510236459.png"></p></li></ul><h3 id="9-前端向后台发送数据-前端的代码的一部分不全主要学习springboot"><a href="#9-前端向后台发送数据-前端的代码的一部分不全主要学习springboot" class="headerlink" title="9.前端向后台发送数据(前端的代码的一部分不全主要学习springboot)"></a>9.<strong>前端向后台发送数据</strong>(前端的代码的一部分不全主要学习springboot)</h3><p>在nymap.html中添加如下代码：</p><ul><li>采集缩放行为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于记录缩放开始级别的变量</span></span><br><span class="line"><span class="keyword">var</span> zoomStartLevel = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">map.addEventListener(<span class="string">&quot;zoomstart&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;start!&quot;+map.getZoom())</span></span><br><span class="line">    zoomStartLevel = map.getZoom(); <span class="comment">// 记录缩放开始级别</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">map.addEventListener(<span class="string">&quot;zoomend&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;end!&quot;+map.getZoom())</span></span><br><span class="line">    <span class="comment">// 获取缩放开始级别和缩放终止级别</span></span><br><span class="line">    <span class="keyword">const</span> zoomEndLevel = map.getZoom();</span><br><span class="line">    <span class="comment">// 按后台接口格式封装请求参数</span></span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        <span class="attr">optType</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">zoomStartLevel</span>:zoomStartLevel,</span><br><span class="line">        <span class="attr">zoomEndLevel</span>:zoomEndLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向后台接口发送请求</span></span><br><span class="line">    sendOptData(params)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendOptData</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url=<span class="string">&quot;opt/save&quot;</span> <span class="comment">// 后台接口的相对路径</span></span><br><span class="line">    $.post(url, params, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>采集拖拽行为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存拖拽开始时地图的中心点</span></span><br><span class="line">    <span class="keyword">var</span> dragStartPoint;</span><br><span class="line">    <span class="comment">// 添加拖拽开始监听</span></span><br><span class="line">    map.addEventListener(<span class="string">&quot;dragstart&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取地图中心点的经纬度信息</span></span><br><span class="line">        <span class="keyword">const</span> point = map.getCenter()</span><br><span class="line">        dragStartPoint = point</span><br><span class="line">        <span class="comment">// 获取经纬度</span></span><br><span class="line">        <span class="comment">// console.log(point.lat+&quot;:&quot;+point.lng)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 10分钟时间 到14:51 实现该功能</span></span><br><span class="line">    map.addEventListener(<span class="string">&quot;dragend&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取拖拽终止时地图的中心点</span></span><br><span class="line">        <span class="keyword">const</span> point = map.getCenter();</span><br><span class="line">        <span class="comment">// 按后台需求封装请求参数</span></span><br><span class="line">        <span class="keyword">const</span> params = &#123;</span><br><span class="line">            <span class="attr">optType</span>:<span class="number">2</span>,</span><br><span class="line">            <span class="attr">dragStartLat</span>:dragStartPoint.lat,</span><br><span class="line">            <span class="attr">dragStartLng</span>:dragStartPoint.lng,</span><br><span class="line">            <span class="attr">dragEndLat</span>:point.lat,</span><br><span class="line">            <span class="attr">dragEndLng</span>:point.lng</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数据发送给后台</span></span><br><span class="line">        sendOptData(params)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ul><li>采集点击站点行为：在marker的点击监听中添加如下代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采集用户点击站点的数据</span></span><br><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    <span class="attr">optType</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">stationId</span>:<span class="built_in">this</span>.sid</span><br><span class="line">&#125;</span><br><span class="line">sendOptData(params)</span><br></pre></td></tr></table></figure><h3 id="10-开发业务层"><a href="#10-开发业务层" class="headerlink" title="10.开发业务层"></a>10.<strong>开发业务层</strong></h3><p>在src/main/java下新建<code>cn.tedu.nybike.service</code>包。</p><p>在该包下新建<code>OperationService</code>类，并在类中开发对应的业务层方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.nybiket.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.tedu.nybiket.dao.OperationDAO;</span><br><span class="line"><span class="keyword">import</span> cn.tedu.nybiket.entity.OperationDO;</span><br><span class="line"><span class="keyword">import</span> cn.tedu.nybiket.util.IPUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户操作模块的业务层类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    OperationDAO dao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存一条用户操作记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optDO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOperation</span><span class="params">(OperationDO optDO)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前发请求用户的IP地址</span></span><br><span class="line">        String userIp = IPUtils.getIpAddr();</span><br><span class="line">        <span class="comment">// 将IP地址添加到optDO对象中</span></span><br><span class="line">        optDO.setUserIp(userIp);</span><br><span class="line">        <span class="comment">// 调用持久层方法，保存操作记录</span></span><br><span class="line">        dao.insertOperation(optDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.<strong>开发业务层测试用例</strong></p><p>光标选中<code>OperationService</code>类中任意位置，右键 -&gt;Generate… -&gt; Test… ，在里面勾选<code>saveOpeartion</code>前面的复选框，然后点OK，自动生成测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OperationService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OperationDO optDO = <span class="keyword">new</span> OperationDO();</span><br><span class="line">        service.saveOperation(optDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12.<strong>开发控制器层</strong></p><p>在src/main/java下新建<code>cn.tedu.nybike.controller</code>包。</p><p>在该包下新建<code>OperationController</code>类，并在类中开发对应的控制器层方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/opt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OperationService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title">saveOperation</span><span class="params">(OperationDO optDO)</span></span>&#123;</span><br><span class="line">        <span class="comment">// TODO 参数验证：非空验证、格式验证、逻辑验证</span></span><br><span class="line">        <span class="comment">// 调用业务层方法，保存optDO</span></span><br><span class="line">        service.saveOperation(optDO);</span><br><span class="line">        <span class="comment">// 返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> JsonResult.getSuccessJR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.<strong>测试控制器层</strong></p><p>通过项目主类<code>NybikeApplication</code>的main方法启动项目。</p><p>在浏览器地址栏访问<code>http://localhost:8080/opt/save?optType=1&amp;stationId=1234</code>，如果页面显示如下信息，说明访问成功。</p><img src="https://image.3001.net/images/20220625/1656151015466.png" style="zoom:24%;" /><p>常见问题：</p><ul><li><p>如果显示连接被拒绝，或无法连接：项目没有正常启动</p></li><li><p>如果显示连接异常，状态码为404：请求的路径和控制器层提供的路径不对应，检查<code>OperationController</code>中两个<code>@RequestMapping</code>注解的值是否正确</p></li><li><p>如果显示连接异常，状态码为500：服务器执行程序时出现异常，在IDEA的控制台中会有具体的报错信息，根据报错信息排查对应的问题</p></li><li><p>如果提交了请求参数，但是查询数据库时发现对应的参数值没有被写进数据库：一般是提交参数的参数名和实体类中的属性名不一致导致的，核对参数名和属性名</p></li><li><p>注：对服务器代码进行修改后，需要重启项目，新的代码才会生效</p><p>  <img src="https://image.3001.net/images/20220625/16561510098236.png"></p></li></ul><p><strong>前端向后台发送数据</strong></p><p>在nymap.html中添加如下代码：</p><ul><li>采集缩放行为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于记录缩放开始级别的变量</span></span><br><span class="line"><span class="keyword">var</span> zoomStartLevel = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">map.addEventListener(<span class="string">&quot;zoomstart&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;start!&quot;+map.getZoom())</span></span><br><span class="line">    zoomStartLevel = map.getZoom(); <span class="comment">// 记录缩放开始级别</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">map.addEventListener(<span class="string">&quot;zoomend&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// alert(&quot;end!&quot;+map.getZoom())</span></span><br><span class="line">    <span class="comment">// 获取缩放开始级别和缩放终止级别</span></span><br><span class="line">    <span class="keyword">const</span> zoomEndLevel = map.getZoom();</span><br><span class="line">    <span class="comment">// 按后台接口格式封装请求参数</span></span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        <span class="attr">optType</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">zoomStartLevel</span>:zoomStartLevel,</span><br><span class="line">        <span class="attr">zoomEndLevel</span>:zoomEndLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向后台接口发送请求</span></span><br><span class="line">    sendOptData(params)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendOptData</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url=<span class="string">&quot;opt/save&quot;</span> <span class="comment">// 后台接口的相对路径</span></span><br><span class="line">    $.post(url, params, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>采集拖拽行为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存拖拽开始时地图的中心点</span></span><br><span class="line">    <span class="keyword">var</span> dragStartPoint;</span><br><span class="line">    <span class="comment">// 添加拖拽开始监听</span></span><br><span class="line">    map.addEventListener(<span class="string">&quot;dragstart&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取地图中心点的经纬度信息</span></span><br><span class="line">        <span class="keyword">const</span> point = map.getCenter()</span><br><span class="line">        dragStartPoint = point</span><br><span class="line">        <span class="comment">// 获取经纬度</span></span><br><span class="line">        <span class="comment">// console.log(point.lat+&quot;:&quot;+point.lng)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 10分钟时间 到14:51 实现该功能</span></span><br><span class="line">    map.addEventListener(<span class="string">&quot;dragend&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取拖拽终止时地图的中心点</span></span><br><span class="line">        <span class="keyword">const</span> point = map.getCenter();</span><br><span class="line">        <span class="comment">// 按后台需求封装请求参数</span></span><br><span class="line">        <span class="keyword">const</span> params = &#123;</span><br><span class="line">            <span class="attr">optType</span>:<span class="number">2</span>,</span><br><span class="line">            <span class="attr">dragStartLat</span>:dragStartPoint.lat,</span><br><span class="line">            <span class="attr">dragStartLng</span>:dragStartPoint.lng,</span><br><span class="line">            <span class="attr">dragEndLat</span>:point.lat,</span><br><span class="line">            <span class="attr">dragEndLng</span>:point.lng</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数据发送给后台</span></span><br><span class="line">        sendOptData(params)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><ul><li>采集点击站点行为：在marker的点击监听中添加如下代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采集用户点击站点的数据</span></span><br><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    <span class="attr">optType</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">stationId</span>:<span class="built_in">this</span>.sid</span><br><span class="line">&#125;</span><br><span class="line">sendOptData(params)</span><br></pre></td></tr></table></figure><h3 id="11-学习可视化插件echarts有自己学习文档"><a href="#11-学习可视化插件echarts有自己学习文档" class="headerlink" title="11.学习可视化插件echarts有自己学习文档"></a>11.学习可视化插件echarts有自己学习文档</h3><h3 id="12-数据可视化"><a href="#12-数据可视化" class="headerlink" title="12.数据可视化"></a>12.数据可视化</h3><p><strong>从服务器动态获取图表的数据</strong></p><img src="https://image.3001.net/images/20220625/16561510049362.png" style="zoom:33%;" /><p>浏览器与服务器在进行数据交互时，目前比较流行的格式有两种：</p><ul><li>针对简单数据：<code>key1=value1&amp;key2=value2&amp;key3=value3....</code></li><li>针对复杂数据：JSON</li></ul><p><img src="https://image.3001.net/images/20220625/16561510005396.png"></p><p>用例组件设计：</p><img src="https://image.3001.net/images/20220625/16561510025632.png" style="zoom:33%;" /><p>开发实体类<code>cn.tedu.nybike.entity.PieItem</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double value;</span><br><span class="line">    <span class="comment">// 笔记这里省略无参构造器，带参构造器，get/set方法，toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220625/16561509947007.png"></p><p>声明实体类<code>cn.tedu.nybike.entity.OptTypeCountDO</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptTypeCountDO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer optType; <span class="comment">// 0点击，1缩放 2拖拽</span></span><br><span class="line">    <span class="keyword">private</span> Integer count; <span class="comment">// 操作的数量</span></span><br><span class="line">    <span class="comment">// 笔记这里省略无参构造器，get/set方法，toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>cn.tedu.nybike.dao.OperationDAO</code>中添加新的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询各类操作的总数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;OptTypeCountDO&gt; <span class="title">listOptTypeCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在<code>src/main/resources/mappers/OperationMapper.xml</code>中添加绑定的SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--查询各类操作的总数量--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;OptTypeCountDO&gt; listOptTypeCount()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listOptTypeCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.tedu.nybiket.entity.OptTypeCountDO&quot;</span> &gt;</span></span><br><span class="line">    select opt_type as optType, count(*) as count</span><br><span class="line">    from t_operation</span><br><span class="line">    where opt_type is not null</span><br><span class="line">    group by opt_type</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>OperationDAOTest</code>中添加测试方法，对持久层方法进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listOptTypeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;OptTypeCountDO&gt; list = dao.listOptTypeCount();</span><br><span class="line">    list.forEach(item-&gt; System.err.println(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>OperationService</code>中添加新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PieItem&gt; <span class="title">findOptTypeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用持久层方法，查询数据</span></span><br><span class="line">    List&lt;OptTypeCountDO&gt; list = dao.listOptTypeCount();</span><br><span class="line">    <span class="comment">// 对数据进行转换</span></span><br><span class="line">    List&lt;PieItem&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(OptTypeCountDO opt:list)&#123;</span><br><span class="line">        PieItem item = <span class="keyword">new</span> PieItem();</span><br><span class="line">        <span class="comment">// 将数值型的optType转换为对应的字符串描述</span></span><br><span class="line">        <span class="keyword">switch</span> (opt.getOptType())&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: item.setName(<span class="string">&quot;点击&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: item.setName(<span class="string">&quot;缩放&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: item.setName(<span class="string">&quot;拖拽&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加value</span></span><br><span class="line">        item.setValue(opt.getCount()*<span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 将item添加到result中</span></span><br><span class="line">        result.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回转换的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>OperationController</code>中的方法，通过调用业务层方法获取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/findOptTypeCount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult&lt;List&lt;PieItem&gt;&gt; findOptTypeCount()&#123;</span><br><span class="line">    <span class="comment">// 创建模拟数据</span></span><br><span class="line">    <span class="comment">//        List&lt;PieItem&gt; list=new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//        list.add(new PieItem(&quot;点击&quot;, 8.0));</span></span><br><span class="line">    <span class="comment">//        list.add(new PieItem(&quot;缩放&quot;, 15.0));</span></span><br><span class="line">    <span class="comment">//        list.add(new PieItem(&quot;拖拽&quot;, 13.0));</span></span><br><span class="line">    <span class="comment">// 调用业务层方法，查询真实数据</span></span><br><span class="line">    List&lt;PieItem&gt; list=service.findOptTypeCount();</span><br><span class="line">    <span class="comment">// 返回封装了数据的JR对象</span></span><br><span class="line">    <span class="keyword">return</span> JsonResult.getSuccessJR(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>NybikeApplication</code>启动项目，通过浏览器访问<code>http://localhost:8080/demo/opt_type_count.html</code>，查看饼图数据是否更新成数据库中的数据：</p><img src="https://image.3001.net/images/20220625/1656150990263.png" style="zoom:33%;" /><!-- more -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-Boot教程&quot;&gt;&lt;a href=&quot;#Spring-Boot教程&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot教程&quot;&gt;&lt;/a&gt;Spring Boot教程&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-idea创建Spring-boot项目&quot;&gt;&lt;a href=&quot;#1-idea创建Spring-boot项目&quot; class=&quot;headerlink&quot; title=&quot;1.idea创建Spring boot项目&quot;&gt;&lt;/a&gt;1.idea创建Spring boot项目&lt;/h2&gt;&lt;p&gt;在IDEA中创建一个Java Web项目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot 项目（本次使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20220625/16561510931991.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="https://yangmour.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop伪分布搭建文档</title>
    <link href="https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/"/>
    <id>https://yangmour.github.io/2022/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/</id>
    <published>2022-06-25T05:06:17.000Z</published>
    <updated>2022-10-07T05:13:18.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hadoop伪分布搭建文档"><a href="#Hadoop伪分布搭建文档" class="headerlink" title="Hadoop伪分布搭建文档"></a>Hadoop伪分布搭建文档</h2><p>[TOC]</p><h3 id="1-准备1台虚拟机或云主机"><a href="#1-准备1台虚拟机或云主机" class="headerlink" title="1. 准备1台虚拟机或云主机"></a>1. 准备1台虚拟机或云主机</h3><h4 id="1-配置好主机名"><a href="#1-配置好主机名" class="headerlink" title="1) 配置好主机名"></a>1) 配置好主机名</h4><p>配置主机hostname为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname master</span><br></pre></td></tr></table></figure><h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2)准备"></a>2)准备</h4><ol><li>关闭防火墙</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld                 #查看防火墙状态</span><br><span class="line">systemctl stop firewalld.service           #停止firewall</span><br><span class="line">systemctl disable firewalld.service        #禁止firewall开机启动</span><br></pre></td></tr></table></figure><span id="more"></span><ol start="2"><li>安装JDK并配置JDK环境变量（参考云主机Web应用环境搭建文档）</li><li>配置/etc/hosts文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.56.101  master</span><br></pre></td></tr></table></figure><p>DNS寻址</p><p>主机名映射到ip地址</p><p><img src="https://image.3001.net/images/20220704/16569103383947.png" alt="image-20220628092942172"></p><h3 id="2-配置SSH免密登录"><a href="#2-配置SSH免密登录" class="headerlink" title="2. 配置SSH免密登录"></a>2. 配置SSH免密登录</h3><ol><li>master生成密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa (四个回车)</span><br><span class="line">cd /root/.ssh</span><br><span class="line">cp id_rsa.pub authorized_keys </span><br></pre></td></tr></table></figure><ol><li>测试master到本地的免密登录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@master</span><br><span class="line">ssh root@localhost</span><br></pre></td></tr></table></figure><h3 id="3-安装JDK"><a href="#3-安装JDK" class="headerlink" title="3.安装JDK"></a>3.安装JDK</h3><ul><li>进入<code>/opt/software/java</code>目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software</span><br><span class="line">mkdir java</span><br><span class="line">cd java</span><br></pre></td></tr></table></figure><ul><li>下载linux-jdk1.8版本压缩文件到到本地<code>/opt</code>目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/java/jdk/8u152-b16/jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压缩到目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u152-linux-x64.tar.gz</span><br><span class="line">mv jdk1.8.0_251 jdk1.8</span><br></pre></td></tr></table></figure><ul><li>查看是否解压成功</li></ul><p><img src="https://image.3001.net/images/20220704/1656909301416.png"></p><ul><li><p>配置环境变量</p><p>  编辑<code>/etc/profile</code>文件</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>  vim会开启文档查看窗口，默认情况下不可修改文档内容，可以使用键盘的方向键浏览文档。这里使用<code>↓</code>移动到文档的最后一行，按键盘上的<code>i</code>键进入编辑模式，会看到文档下方提示<code>-- INSERT --</code>，该模式下可以对文档内容进行修改。</p><p>  在最后一行后面新起几行，添加如下内容：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/software/java/jdk1.8</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH:$HOME/bin</span><br></pre></td></tr></table></figure><p>  然后按ESC退出编辑模式，输入<code>:wq!</code>保存本次修改并退出<code>vim</code>。</p><p>  对<code>/etc/profile</code>文件的修改默认不会马上生效，可以使用命令<code>source /etc/profile</code>让本次修改在当前访问中生效。</p></li><li><p>验证是否配置成功，使用<code>java -version</code>命令</p><p>  <img src="https://image.3001.net/images/20220704/16569093026483.png"></p></li></ul><h3 id="4-安装hadoop伪分布"><a href="#4-安装hadoop伪分布" class="headerlink" title="4. 安装hadoop伪分布"></a>4. 安装hadoop伪分布</h3><h4 id="1-下载hadoop安装包"><a href="#1-下载hadoop安装包" class="headerlink" title="1.下载hadoop安装包"></a>1.下载hadoop安装包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software/hadoop</span><br><span class="line">#华为云下载hadoop-2.7.7安装包</span><br><span class="line">https://mirrors.huaweicloud.com/apache/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz </span><br></pre></td></tr></table></figure><h4 id="2-将hadoop2-7-7-解压到-opt-software-hadoop目录下"><a href="#2-将hadoop2-7-7-解压到-opt-software-hadoop目录下" class="headerlink" title="2.将hadoop2.7.7 解压到 /opt/software/hadoop目录下"></a>2.将hadoop2.7.7 解压到 /opt/software/hadoop目录下</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.7.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3.配置环境变量"></a>3.配置环境变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0</span><br><span class="line">export HADOOP_HOME=/opt/software/hadoop/hadoop2.7.7</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$JAVA_HOME/bin:$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">使配置生效-仅当前shell有效-全部生效需要重启电脑</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="4-对Hadoop进行配置"><a href="#4-对Hadoop进行配置" class="headerlink" title="4.对Hadoop进行配置"></a>4.对Hadoop进行配置</h4><ol><li>修改hadoop-env.sh文件，添加jdk</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/software/hadoop/hadoop-2.7.7/etc/hadoop/hadoop-env.sh</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/opt/software/java/jdk1.8</span><br></pre></td></tr></table></figure><ol start="2"><li>修改core-site.xml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/software/hadoop/hadoop-2.7.7/etc/hadoop/core-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/opt/software/hadoop/hadoop-2.7.7/tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://master:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改hdfs-site.xml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/software/hadoop/hadoop-2.7.7/etc/hadoop/hdfs-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>HDFS的副本数量，伪分布下使用1，完全分布下使用3</p><ol start="4"><li>配置mapred-site.xml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">复制模板文件并配置</span><br><span class="line"></span><br><span class="line">cp /opt/software/hadoop/hadoop-2.7.7/etc/hadoop/mapred-site.xml.template /opt/software/hadoop/hadoop-2.7.7/etc/hadoop/mapred-site.xml</span><br><span class="line"></span><br><span class="line">配置文件内容</span><br><span class="line"></span><br><span class="line">vi /opt/software/hadoop/hadoop-2.7.7/etc/hadoop/mapred-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>配置yarn-site.xml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/software/hadoop/hadoop-2.7.7/etc/hadoop/yarn-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:8032&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="5-格式化hdfs"><a href="#5-格式化hdfs" class="headerlink" title="5.格式化hdfs"></a>5.格式化hdfs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br><span class="line"></span><br><span class="line">注：如果不是首次进行格式化，需要删除本地hadoop的tem目录下的所有内容，再进行格式化</span><br></pre></td></tr></table></figure><h4 id="6-启动hadoop"><a href="#6-启动hadoop" class="headerlink" title="6.启动hadoop"></a>6.启动hadoop</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure><p>查看hadoop运行情况</p><ol><li><p>每个主机使用jps命令查询</p></li><li><p>浏览器访问 <a href="http://master:50070/">http://master:50070</a></p><p> 注意：云主机需要开放50070端口才能正常访问网页</p></li></ol><h4 id="7-测试Hadoop运行"><a href="#7-测试Hadoop运行" class="headerlink" title="7.测试Hadoop运行"></a>7.测试Hadoop运行</h4><ol><li><p>创建一个临时文件hello</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi hello</span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line">hello hadoop</span><br><span class="line">hadoop</span><br></pre></td></tr></table></figure></li><li><p>将文件上传到hdfs上</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put hello /</span><br></pre></td></tr></table></figure></li><li><p>查看文件是否正确上传</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls /</span><br></pre></td></tr></table></figure></li><li><p>对文件进行词频统计</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar /opt/software/hadoop/hadoop-2.7.7/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount /hello /out</span><br></pre></td></tr></table></figure><p> 查看词频统计结果</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -cat /out/part*</span><br></pre></td></tr></table></figure></li><li><p>删除本例用的hello文件和out文件夹</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -rm /hello</span><br><span class="line">hdfs dfs -rm -r /out</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-配置hadoo中hdfs网页（hdfs网站默认端口50070端口）"><a href="#8-配置hadoo中hdfs网页（hdfs网站默认端口50070端口）" class="headerlink" title="8.配置hadoo中hdfs网页（hdfs网站默认端口50070端口）"></a>8.配置hadoo中hdfs网页（hdfs网站默认端口50070端口）</h4><p>1.在阿里云的安全组中配置入方向50070端口，授权对象0.0.0.0</p><p>2.配置完成后<a href="http://ip:50070/">http://ip:50070</a></p><img src="https://image.3001.net/images/20220704/16569093124684.png" alt="image-20220628140852600" style="zoom:33%;" /><h3 id="5-安装Hive"><a href="#5-安装Hive" class="headerlink" title="5. 安装Hive"></a>5. 安装Hive</h3><p>/opt/software/hive/hive-2.3.8</p><h4 id="1-获取安装文件"><a href="#1-获取安装文件" class="headerlink" title="1.获取安装文件"></a>1.获取安装文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/apache/hive/hive-2.3.8/apache-hive-2.3.8-bin.tar.gz</span><br></pre></td></tr></table></figure><h4 id="2-解压缩"><a href="#2-解压缩" class="headerlink" title="2.解压缩"></a>2.解压缩</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-hive-2.3.8-bin.tar.gz</span><br><span class="line"></span><br><span class="line">修改文件夹名称</span><br><span class="line">mv apache-hive-2.3.8-bin hive-2.3.8</span><br></pre></td></tr></table></figure><h4 id="3-配置环境变量-1"><a href="#3-配置环境变量-1" class="headerlink" title="3.配置环境变量"></a>3.配置环境变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">编辑/etc/profile文件</span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">声明HIVE_HOME变量，并将$HIVE_HOME/bin添加到PATH变量中</span><br><span class="line">export HIVE_HOME=/opt/software/hive/hive-2.3.8</span><br><span class="line">export PATH=$HIVE_HOME/bin:$HIVE_HOME/conf:</span><br><span class="line"></span><br><span class="line">配置完成后，按ESC -&gt; ：wq!回车</span><br><span class="line"></span><br><span class="line">让本次配置马上生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="4-配置Hive"><a href="#4-配置Hive" class="headerlink" title="4.配置Hive"></a>4.配置Hive</h4><h5 id="1-配置hive-env-sh"><a href="#1-配置hive-env-sh" class="headerlink" title="1.配置hive-env.sh"></a>1.配置hive-env.sh</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">复制模板</span><br><span class="line">cd /opt/software/hive/hive-2.3.8/conf</span><br><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line"></span><br><span class="line">编辑文件    </span><br><span class="line">vim hive-env.sh</span><br><span class="line"></span><br><span class="line">在首行添加</span><br><span class="line">export HADOOP_HOME=/opt/software/hadoop/hadoop-2.7.7</span><br><span class="line">export HIVE_HOME=/opt/software/hive/hive-2.3.8</span><br><span class="line">export HIVE_CONF_DIR=/opt/software/hive/hive-2.3.8/conf</span><br><span class="line">export JAVA_HOME=/opt/software/java/jdk1.8</span><br><span class="line">export HIVE_AUX_JARS_PATH=/opt/software/hive/hive-2.3.8/lib</span><br></pre></td></tr></table></figure><h5 id="2-配置hive-site-xml"><a href="#2-配置hive-site-xml" class="headerlink" title="2.配置hive-site.xml"></a>2.配置hive-site.xml</h5><p>正常情况下，应该通过<code>hive-default.xml.template</code>模板文件生成<code>hive-site.xml</code>文件，但是该模板文件内容过多，修改较为麻烦。因此，可以直接通过命令创建一个空白的<code>hive-site.xml</code>文件，将所有需要的配置添加进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">创建空白的hive-site.xml文件</span><br><span class="line">vim /opt/software/hive/hive-2.3.8/conf/hive-site.xml</span><br><span class="line"></span><br><span class="line">为规避粘贴缩进错位问题，可先使用 :set paste  设置vim为粘贴模式，</span><br><span class="line">再按i进入编辑模式，然后将如下内容粘贴到该文件中，需要特别注意，xml文件的第一行必须是`&lt;?xml version=&quot;1.0&quot;...`，前面不能有任何的空行：</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;com.mysql.cj.jdbc.Driver&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hivepwd&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://master:8020/hive/warehouse&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/opt/software/hive/hive-2.3.8/exec&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/hive/downloadedsource&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.querylog.location&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/hive/logs&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt; </span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">ESC-&gt; :wq!回车</span><br></pre></td></tr></table></figure><h5 id="3-配置Hive的日志目录"><a href="#3-配置Hive的日志目录" class="headerlink" title="3.配置Hive的日志目录"></a>3.配置Hive的日志目录</h5><p>Hive中使用log4j2插件进行运行日志的记录，该插件默认将Hive日志保存在本地主机的<code>$&#123;sys:java.io.tmpdir&#125;/$&#123;sys:user.name&#125;</code>路径下，对初学者来说不容易查找。因此，我们配置修改该路径，将hive的日志保存在<code>/opt/hive/log</code>目录下。后续，hive运行中产生异常时，可以查看该目录下的日志信息，找到具体的异常信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">拷贝文件</span><br><span class="line">cp hive-log4j2.properties.template hive-log4j2.properties</span><br><span class="line"></span><br><span class="line">编辑文件</span><br><span class="line">vim hive-log4j2.properties</span><br><span class="line"></span><br><span class="line">property.hive.log.dir = /opt/software/hive/hive-2.3.8/log</span><br></pre></td></tr></table></figure><h5 id="4-将mysql连接jar包添加到hive的lib文件夹下"><a href="#4-将mysql连接jar包添加到hive的lib文件夹下" class="headerlink" title="4.将mysql连接jar包添加到hive的lib文件夹下"></a>4.将mysql连接jar包添加到hive的lib文件夹下</h5><p>hive基于JDBC访问Mariadb数据库，因此，需要将mysql连接jar包添加到hive安装目录下的lib目录中，可以直接使用xftp等工具实现这一操作，也可以通过外网直接下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -P /opt/software/hive/hive-2.3.8/lib  https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar</span><br><span class="line"></span><br><span class="line">阿里云下载地址：</span><br><span class="line">wget -P /opt/software/hive/hive-2.3.8/lib/ https://archiva-maven-storage-prod.oss-cn-beijing.aliyuncs.com/repository/jcenter/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar</span><br></pre></td></tr></table></figure><h5 id="5-解决SLF4J重复问题"><a href="#5-解决SLF4J重复问题" class="headerlink" title="5.解决SLF4J重复问题"></a>5.解决SLF4J重复问题</h5><p>hive和hadoop都使用了SLF4J的jar包，但是版本不同，会造成冲突提示，可以直接删除hive中的SLF4J的jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software/hive/hive-2.3.8/lib</span><br><span class="line">rm -f log4j-slf4j-impl-2.6.2.jar</span><br></pre></td></tr></table></figure><h5 id="6-配置MariaDB、或Mysql"><a href="#6-配置MariaDB、或Mysql" class="headerlink" title="6.配置MariaDB、或Mysql"></a>6.配置MariaDB、或Mysql</h5><p>mariadb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#进入MariaDB</span><br><span class="line">mysql -uroot -proot</span><br><span class="line"></span><br><span class="line">#建库</span><br><span class="line">create database hive;</span><br><span class="line"></span><br><span class="line">#配置权限</span><br><span class="line">grant all on hive.* to hadoop@&#x27;master&#x27; identified by &#x27;hivepwd&#x27;;</span><br><span class="line"></span><br><span class="line">#使配置生效</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">#退出MariaDB</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>Mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#进入mysql</span><br><span class="line">mysql -uroot -proot</span><br><span class="line">#建库</span><br><span class="line">create database hive;</span><br><span class="line">#创建账号</span><br><span class="line">CREATE USER &#x27;hadoop&#x27;@&#x27;master&#x27; IDENTIFIED BY &#x27;hivepwd&#x27;;</span><br><span class="line">#配置权限</span><br><span class="line">grant all on nybikedb.* to hadoop@&#x27;master&#x27; identified by &#x27;hivepwd&#x27;;</span><br><span class="line"> #使配置生效</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">#退出MariaDB</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><h5 id="7-初始化Hive的元数据库"><a href="#7-初始化Hive的元数据库" class="headerlink" title="7.初始化Hive的元数据库"></a>7.初始化Hive的元数据库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在第一次使用hive前，需要用如下命令初始化hive的元数据库，该命令只能执行1次：</span><br><span class="line"></span><br><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure><h5 id="8-使用Hive"><a href="#8-使用Hive" class="headerlink" title="8.使用Hive"></a>8.使用Hive</h5><p>可以使用<code>hive</code>命令启动hive，注意，Hive启动时会直接访问HDFS，Hive的一些操作会继续MapReduce实现。因此需要保证HDFS和YARN已经处于启动状态。 hive</p><p>查询当前所有的库 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>测试Hive </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create database testdb; </span><br><span class="line"></span><br><span class="line">use testdb; </span><br><span class="line"></span><br><span class="line">create table student(id int,name string); </span><br><span class="line"></span><br><span class="line">insert into student values(1,&#x27;Tom&#x27;); </span><br><span class="line"></span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure><h3 id="6-Sqoop操作文档安装"><a href="#6-Sqoop操作文档安装" class="headerlink" title="6.Sqoop操作文档安装"></a>6.Sqoop操作文档安装</h3><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1 下载安装包"></a>1 下载安装包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.apache.org/dist/sqoop/1.4.2/sqoop-1.4.2.bin__hadoop-2.0.0-alpha.tar.gz </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h4><p>使用如下命令将sqoop解压到虚拟机的<code>/opt</code>目录下</p><pre><code>tar -zxvf sqoop-1.4.2.bin__hadoop-2.0.0-alpha.tar.gz</code></pre><p>将文件夹名称修改为sqoop-1.4.7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv sqoop-1.4.2.bin__hadoop-2.0.0-alpha sqoop-1.4.2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-配置环境变量-2"><a href="#3-配置环境变量-2" class="headerlink" title="3 配置环境变量"></a>3 配置环境变量</h4><pre><code>使用vim命令编辑文件vim /etc/profileexport SQOOP_HOME=/opt/software/sqoop/sqoop-1.4.2export PATH=$SQOOP_HOME/bin:使本次配置生效source /etc/profile检查环境变量是否配置成功sqoop version</code></pre><h4 id="4-添加数据库连接jar包"><a href="#4-添加数据库连接jar包" class="headerlink" title="4 添加数据库连接jar包"></a>4 添加数据库连接jar包</h4><pre><code>使用xftp将数据库连接jar包上传到虚拟机的/opt/sqoop-1.4.7/lib目录下也可以使用如下命令，从hive的lib目录下拷贝数据库连接jar包到sqoop对应目录下cp /opt/software/hive/hive-2.3.8/lib/mysql-connector-java-8.0.16.jar /opt/software/sqoop/sqoop-1.4.2/lib/如果未安装Hive，可以直接从官网下载jar包：wget -P /opt/sqoop-1.4.7/lib/  https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar阿里云下载地址：wget -P /opt/sqoop-1.4.7/lib/ https://archiva-maven-storage-prod.oss-cn-beijing.aliyuncs.com/repository/jcenter/mysql/mysql-connector-java/8.0.16/mysql-connector-java-8.0.16.jar</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="1-MySQL导入数据到HDFS"><a href="#1-MySQL导入数据到HDFS" class="headerlink" title="1. MySQL导入数据到HDFS"></a>1. MySQL导入数据到HDFS</h4><p>首先，在MySQL中创建测试用库和表并插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database sqoop;</span><br><span class="line"></span><br><span class="line">use sqoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> widgets(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">widget_name <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">price <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">design_date <span class="type">date</span>,</span><br><span class="line">version <span class="type">int</span>,</span><br><span class="line">design_comment <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> widgets <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;sprocket&#x27;</span>,<span class="number">0.25</span>,<span class="string">&#x27;2010-02-10&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;Connects two gizmos&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> widgets <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;gizmo&#x27;</span>, <span class="number">4.00</span>, <span class="string">&#x27;2009-11-30&#x27;</span>, <span class="number">4</span>,<span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> widgets <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;gadget&#x27;</span>, <span class="number">99.99</span>, <span class="string">&#x27;1983-08-13&#x27;</span>, <span class="number">13</span>, <span class="string">&#x27;Our flagship product&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来，使用sqoop命令将widgets表中数据导入到HDFS中：</p><p>参数说明：</p><ul><li>import ：表示导入数据至HDFS</li><li>–connect jdbc:mysql://……：定义数据库连接的URL</li><li>–username root：指定连接MySQL的用户名</li><li>–password root：指定连接MySQL的密码</li><li>–table widgets：指明待导入的MySQL表名</li><li>-m 1：指定用于导入数据的Map作业的个数ssh</li></ul><p>查看结果：</p><p><img src="https://image.3001.net/images/20220704/16569093243221.png"></p><p>查看HDFS上的数据：</p><p><img src="https://image.3001.net/images/20220704/16569093267610.png"></p><p>该命令会自动将MySQL表中的数据保存到HDFS上的<code>/user/用户名/表名</code>目录下。</p><p>也可以使用 <code>--target-dir /路径</code>来指定导入到HDFS上的路径，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqoop import \</span><br><span class="line">--connect jdbc:mysql://localhost:3306/sqoop \</span><br><span class="line">--username root \</span><br><span class="line">--password root \</span><br><span class="line">--table widgets \</span><br><span class="line">--target-dir /sqoop/widgets \</span><br><span class="line">-m 1</span><br></pre></td></tr></table></figure><p><img src="images/2-16564633849232.png"></p><h4 id="2-HDFS导出数据到MySQL"><a href="#2-HDFS导出数据到MySQL" class="headerlink" title="2. HDFS导出数据到MySQL"></a>2. HDFS导出数据到MySQL</h4><p>首先，在MySQL中创建接收数据的表格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use sqoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> widgets_from_hdfs(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">widget_name <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">price <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">design_date <span class="type">date</span>,</span><br><span class="line">version <span class="type">int</span>,</span><br><span class="line">design_comment <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来，使用sqoop命令将HDFS上的数据导出到MySQL中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop export \</span><br><span class="line">--connect jdbc:mysql://localhost:3306/sqoop \</span><br><span class="line">--username root \</span><br><span class="line">--password root \</span><br><span class="line">--table widgets_from_hdfs \</span><br><span class="line">--export-dir /user/root/widgets/part-m-00000 \</span><br><span class="line">--input-fields-terminated-by &#x27;,&#x27;  \</span><br><span class="line">-m 1</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>export：表示从HDFS导出数据</li><li>–connect jdbc:mysql://……：定义数据库连接的URL</li><li>–table widgets_from_hdfs：指定导出至MySQL的表名</li><li>–export-dir /……/widgets/part-m-00000：指定导出文件</li><li>–input-fields-terminated-by ‘,’：指明导出数据的分割符为 ,</li></ul><p>运行成功后，使用SQL语句查询widgets_from_hdfs表中数据，查看数据是否导入成功：</p><p><img src="https://image.3001.net/images/20220704/16569093305994.png"></p><h3 id="将数据从Hive导入Mariadb"><a href="#将数据从Hive导入Mariadb" class="headerlink" title="将数据从Hive导入Mariadb"></a>将数据从Hive导入Mariadb</h3><p>示例需求：将hive中的nybikedb/tb_day_gender_count表中数据导入到Mariadb中</p><h4 id="1-在云主机的Mariadb中创建用于接收数据的表"><a href="#1-在云主机的Mariadb中创建用于接收数据的表" class="headerlink" title="1. 在云主机的Mariadb中创建用于接收数据的表"></a>1. 在云主机的Mariadb中创建用于接收数据的表</h4><pre><code>登录虚拟机的Mariadbmysql -uroot -proot以下为mysql中的操作，建表时需要注意表中字段名称和个数需要与hive中的表一致，但是字段类型要调整为mysql的类型，主要就是讲string调整为char或者varcharcreate database nybikedb;use nybikedb;create table day_gender_count(day varchar(30) comment &#39;数据的日期&#39;,gender int comment &#39;用户性别，0-未知，1-男性，2-女性&#39;,count int comment &#39;日骑行总数&#39;);</code></pre><h4 id="2-使用sqoop命令将hive数据导入到Mariadb中"><a href="#2-使用sqoop命令将hive数据导入到Mariadb中" class="headerlink" title="2. 使用sqoop命令将hive数据导入到Mariadb中"></a>2. 使用sqoop命令将hive数据导入到Mariadb中</h4><pre><code>-- 以下在虚拟机的终端中操作，操作前需要启动hdfs和yarnsqoop export \--connect jdbc:mysql://localhost:3306/nybikedb \--username root \--password aliyun123Xiwen \--table day_gender_count \--fields-terminated-by &#39;,&#39; \--export-dir /hive/warehouse/nybikedb.db/day_gender_count</code></pre><p>其中：</p><ul><li><code>--connect</code>：指定连接的关系型数据库的url</li><li><code>--username</code>：关系型数据库的用户名</li><li><code>--password</code>：关系型数据库的密码</li><li><code>--table</code>：关系型数据库中的表名</li><li><code>--fields-terminated-by</code>：要导入的数据文件的分隔符，即hive中声明表时使用的字段分隔符</li><li><code>--export-dir</code>：hive表对应的数据在HDFS上的存储目录，目录的最后一级对应的是hive上的表名</li></ul><p>如果hive中的目标表使用了分区，那么sqoop导出数据时会抛出异常，因为目标文件夹下不是数据文件，而是分区的子文件夹。这里可以在hive上新建一张临时表，去掉分区信息，并保证数据的顺序，再使用sqoop导出该表的数据到Mariadb中。</p><h3 id="7-数仓分层"><a href="#7-数仓分层" class="headerlink" title="7.数仓分层"></a>7.数仓分层</h3><p>在阿里巴巴的数据体系中，我们建议将数据仓库分为三层，自下而上为：数据引入层（ODS，Operation Data Store）、数据公共层（CDM，Common Data Model）和数据应用层（ADS，Application Data Service）。</p><p>数据仓库的分层和各层级用途如下图所示。<img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/7325932951/p44631.png" alt="img"></p><ul><li><p>数据引入层ODS（Operation Data Store）：存放未经过处理的原始数据至数据仓库系统，结构上与源系统保持一致，是数据仓库的数据准备区。主要完成基础数据引入到MaxCompute的职责，同时记录基础数据的历史变化。</p></li><li><p>数据公共层CDM（Common Data Model，又称通用数据模型层），包括DIM维度表、DWD和DWS，由ODS层数据加工而成。主要完成数据加工与整合，建立一致性的维度，构建可复用的面向分析和统计的明细事实表，以及汇总公共粒度的指标。</p><ul><li><p>公共维度层（DIM）：基于维度建模理念思想，建立整个企业的一致性维度。降低数据计算口径和算法不统一风险。</p><p>  公共维度层的表通常也被称为逻辑维度表，维度和维度逻辑表通常一一对应。</p></li><li><p>公共汇总粒度事实层（DWS）：以分析的主题对象作为建模驱动，基于上层的应用和产品的指标需求，构建公共粒度的汇总指标事实表，以宽表化手段物理化模型。构建命名规范、口径一致的统计指标，为上层提供公共指标，建立汇总宽表、明细事实表。</p><p>  公共汇总粒度事实层的表通常也被称为汇总逻辑表，用于存放派生指标数据。</p></li><li><p>明细粒度事实层（DWD）：以业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细层事实表。可以结合企业的数据使用特点，将明细事实表的某些重要维度属性字段做适当冗余，即宽表化处理。</p><p>  明细粒度事实层的表通常也被称为逻辑事实表。</p></li></ul></li><li><p>数据应用层ADS（Application Data Service）：存放数据产品个性化的统计指标数据。根据CDM与ODS层加工生成。</p></li></ul><p>该数据分类架构在ODS层分为三部分：数据准备区、离线数据和准实时数据区。整体数据分类架构如下图所示。<img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/8325932951/p44636.png" alt="img">在本教程中，从交易数据系统的数据经过DataWorks数据集成，同步到数据仓库的ODS层。经过数据开发形成事实宽表后，再以商品、地域等为维度进行公共汇总。</p><p>整体的数据流向如下图所示。其中，ODS层到DIM层的ETL（萃取（Extract）、转置（Transform）及加载（Load））处理是在MaxCompute中进行的，处理完成后会同步到所有存储系统。ODS层和DWD层会放在数据中间件中，供下游订阅使用。而DWS层和ADS层的数据通常会落地到在线存储系统中，下游通过接口调用的形式使用。<img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/8325932951/p46107.png" alt="img"></p><h3 id="8-目标：利用大数据平台对共享单车历史数据进行预处理分析"><a href="#8-目标：利用大数据平台对共享单车历史数据进行预处理分析" class="headerlink" title="8.目标：利用大数据平台对共享单车历史数据进行预处理分析"></a>8.目标：利用大数据平台对共享单车历史数据进行预处理分析</h3><h4 id="1-上传共享单车历史数据"><a href="#1-上传共享单车历史数据" class="headerlink" title="1.上传共享单车历史数据"></a>1.上传共享单车历史数据</h4><p>使用tabby的sftp工具，将案例数据.zip上传到云主机<code>/opt/software/hadoop/data</code>路径下</p><p><img src="https://image.3001.net/images/20220704/16569093436964.png" alt="image-20220628143531804"></p><h4 id="2-将数据解压缩"><a href="#2-将数据解压缩" class="headerlink" title="2.将数据解压缩"></a>2.将数据解压缩</h4><p>1.如果没有unzip命令</p><p><img src="https://image.3001.net/images/20220704/16569093463180.png" alt="image-20220628144317651"></p><p>2.安装unzip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y unzip</span><br></pre></td></tr></table></figure><p>3.安装完成</p><p><img src="https://image.3001.net/images/20220704/16569093481084.png" alt="image-20220628144453731"></p><p>4.解压中文的压缩文件时乱码直接复制那个乱码的字符串然后解压</p><p><img src="https://image.3001.net/images/20220704/16569093567408.png" alt="image-20220628144847075"></p><p>上面手欠改错了，又将案例数据改成了nybikeData</p><h4 id="3-将数据进行预处理"><a href="#3-将数据进行预处理" class="headerlink" title="3.将数据进行预处理"></a>3.将数据进行预处理</h4><p>要求</p><p><img src="https://image.3001.net/images/20221007/16651196033957.png" alt="image-20220628145510536"></p><ul><li>查看两条数据进入<code>/opt/software/hadoop/data/nybikeData</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看两条数据</span><br><span class="line">cat 201906-citibike-tripdata.csv | head -n 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#出来的数据信息</span><br><span class="line">&quot;tripduration&quot;,&quot;starttime&quot;,&quot;stoptime&quot;,&quot;start station id&quot;,&quot;start station name&quot;,&quot;start station latitude&quot;,&quot;start station longitude&quot;,&quot;end station id&quot;,&quot;end station name&quot;,&quot;end station latitude&quot;,&quot;end station longitude&quot;,&quot;bikeid&quot;,&quot;usertype&quot;,&quot;birth year&quot;,&quot;gender&quot;</span><br><span class="line">330,&quot;2019-06-01 00:00:01.5000&quot;,&quot;2019-06-01 00:05:31.7600&quot;,3602,&quot;31 Ave &amp; 34 St&quot;,40.763154,-73.920827,3570,&quot;35 Ave &amp; 37 St&quot;,40.7557327,-73.9236611,20348,&quot;Subscriber&quot;,1992,1</span><br></pre></td></tr></table></figure><p>1.去掉文件文件的标头行</p><p>可以通过linux的sed命令实现上述需求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;1d&#x27; 201906-citibike-tripdata.csv </span><br></pre></td></tr></table></figure><p>​        处理完的数据去掉了第一行数据</p><p>2.-&gt; 数据后续需要使用Hive去管理-&gt; hive数据管理的数据要求去表头，去掉字段前后的双引号。</p><p>去掉文本中所有的双引号:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/&quot;//g&#x27; 201906-citibike-tripdata.csv  </span><br></pre></td></tr></table></figure><p>处理完的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">330,2019-06-01 00:00:01.5000,2019-06-01 00:05:31.7600,3602,31 Ave &amp; 34 St,40.763154,-73.920827,3570,35 Ave &amp; 37 St,40.7557327,-73.9236611,20348,Subscriber,1992,1</span><br><span class="line">830,2019-06-01 00:00:04.2400,2019-06-01 00:13:55.1470,3054,Greene Ave &amp; Throop Ave,40.6894932,-73.942061,3781,Greene Av &amp; Myrtle Av,40.698568,-73.918877,34007,Subscriber,1987,2</span><br></pre></td></tr></table></figure><p>3.将数据上传到HDFS上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put 201906-citibike-tripdata.csv  /data</span><br></pre></td></tr></table></figure><p>​    查看有没有上传成功</p><p><img src="https://image.3001.net/images/20220704/16569093661285.png" alt="image-20220628155823266"></p><h4 id="4-需求分析-对共享单车的历史数据进行分析"><a href="#4-需求分析-对共享单车的历史数据进行分析" class="headerlink" title="4.需求分析:对共享单车的历史数据进行分析"></a>4.需求分析:对共享单车的历史数据进行分析</h4><h2 id="对共享单车的历史数据进行分析"><a href="#对共享单车的历史数据进行分析" class="headerlink" title="对共享单车的历史数据进行分析"></a>对共享单车的历史数据进行分析</h2><p>背景：前面的操作中实现了将纽约市2019年6月共享单车历史数据导入到HDFS上进行存储。该数据集中包含了2125371行记录，每行15个字段，接下来可以对历史数据进行分析。</p><p>需求：2019年6月每一天不同性别的用户的骑行数量</p><img src="https://image.3001.net/images/20220704/16569093691961.png" style="zoom:33%;" /><p><img src="https://image.3001.net/images/20220704/16569093733540.png"></p><p><strong>数据仓库</strong></p><p>数据仓库，英文名称为Data Warehouse，可简写为DW或DWH。数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。</p><p><img src="https://image.3001.net/images/20220704/16569093766340.png"></p><p><strong>在云主机上安装Hive</strong></p><p><strong>使用Hive管理共享单车历史数据</strong></p><ul><li><p>在Hive中建库建表，以便管理共享单车历史数据</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建项目对应的库</span></span><br><span class="line"><span class="keyword">create</span> database nybikedb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用库 </span></span><br><span class="line">use nybikedb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在库下创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> trip_data_201906(</span><br><span class="line">tripduration <span class="type">int</span>,</span><br><span class="line">starttime string,</span><br><span class="line">stoptime string,</span><br><span class="line">start_station_id <span class="type">int</span>,</span><br><span class="line">start_station_name string,</span><br><span class="line">start_station_latitude <span class="keyword">double</span>,</span><br><span class="line">start_station_longitude <span class="keyword">double</span>,</span><br><span class="line">end_station_id <span class="type">int</span>,</span><br><span class="line">end_station_name string,</span><br><span class="line">end_station_latitude <span class="keyword">double</span>,</span><br><span class="line">end_station_longitude <span class="keyword">double</span>,</span><br><span class="line">bikeid <span class="type">int</span>,</span><br><span class="line">usertype string,</span><br><span class="line">birth_year <span class="type">int</span>,</span><br><span class="line">gender <span class="type">int</span></span><br><span class="line">)<span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>将HDFS上的数据导入到Hive的表中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 导入数据</span><br><span class="line">load data inpath &#x27;/data/201906-citibike-tripdata.csv&#x27; into table nybikedb.trip_data_201906;</span><br><span class="line"></span><br><span class="line">-- 查看表中数据行数</span><br><span class="line">select count(*) from nybikedb.trip_data_201906;</span><br><span class="line"></span><br><span class="line">-- 查看表中一行记录</span><br><span class="line">select * from nybikedb.trip_data_201906 limit 1;</span><br></pre></td></tr></table></figure></li><li><p>使用HiveQL对数据进行统计分析</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 2019年6月每一天不同性别的用户的骑行数量</span><br><span class="line">select day(starttime) as day, gender, count(*) as count</span><br><span class="line">from nybikedb.trip_data_201906 </span><br><span class="line">group by day(starttime), gender </span><br><span class="line">order by day, gender;</span><br></pre></td></tr></table></figure>  <img src="https://image.3001.net/images/20220704/16569093803815.png" style="zoom:33%;" /></li><li><p>上述查询的结果只是存在在内存中，无法持久化，无法复用，如果分析的结果被复用，应该在Hive中先创建一个结果表，再使用<code>insert into </code>语句搭配<code>select</code>语句，将统计的结果直接写入结果表</p></li><li><p>具体操作</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 在hive中创建结果表</span><br><span class="line">create table nybikedb.day_gender_count(</span><br><span class="line">day int,</span><br><span class="line">gender int,</span><br><span class="line">count int</span><br><span class="line">)row format delimited fields terminated by &#x27;,&#x27;;</span><br><span class="line"></span><br><span class="line">-- 统计数据并将结果写入结果表</span><br><span class="line">insert into nybikedb.day_gender_count</span><br><span class="line">select day(starttime) as day, gender, count(*) as count</span><br><span class="line">from nybikedb.trip_data_201906 </span><br><span class="line">group by day(starttime), gender </span><br><span class="line">order by day, gender;</span><br></pre></td></tr></table></figure></li></ul><p><strong>将数据从Hive导入Mariadb</strong></p><p>使用Sqoop完成该需求。</p><p><img src="https://image.3001.net/images/20220920/1663664291287.png" alt="image-20220920165811152"></p><h4 id="1-在云主机的MariaDB中创建用于接收数据的表"><a href="#1-在云主机的MariaDB中创建用于接收数据的表" class="headerlink" title="1. 在云主机的MariaDB中创建用于接收数据的表"></a>1. 在云主机的MariaDB中创建用于接收数据的表</h4><pre><code>-- 登录虚拟机的Mariadbmysql -uroot -proot-- 以下为mysql中的操作，建表时需要注意表中字段名称和个数需要与hive中的表一致，但是字段类型要调整为mysql的类型，主要就是讲string调整为char或者varcharuse nybikedb;create table day_gender_count(day int comment &#39;数据的日期&#39;,gender int comment &#39;用户性别，0-未知，1-男性，2-女性&#39;,count int comment &#39;日骑行总数&#39;);</code></pre><h4 id="2-使用sqoop命令将hive数据导入到MariaDB中"><a href="#2-使用sqoop命令将hive数据导入到MariaDB中" class="headerlink" title="2. 使用sqoop命令将hive数据导入到MariaDB中"></a>2. 使用sqoop命令将hive数据导入到MariaDB中</h4><pre><code>以下在虚拟机的终端中操作，操作前需要启动hdfs和yarnsqoop export \--connect jdbc:mysql://localhost:3306/nybikedb \--username root \--password root \--table day_gender_count \--fields-terminated-by &#39;,&#39; \--export-dir /hive/warehouse/nybikedb.db/day_gender_count</code></pre><p>其中：</p><ul><li><code>--connect</code>：指定连接的关系型数据库的url</li><li><code>--username</code>：关系型数据库的用户名</li><li><code>--password</code>：关系型数据库的密码</li><li><code>--table</code>：关系型数据库中的表名</li><li><code>--fields-terminated-by</code>：要导入的数据文件的分隔符，即hive中声明表时使用的字段分隔符</li><li><code>--export-dir</code>：hive表对应的数据在HDFS上的存储目录，目录的最后一级对应的是hive上的表名</li></ul><p><img src="https://image.3001.net/images/20220920/16636642785023.png" alt="image-20220920165757048"></p><p>如果hive中的目标表使用了分区，那么sqoop导出数据时会抛出异常，因为目标文件夹下不是数据文件，而是分区的子文件夹。这里可以在hive上新建一张临时表，去掉分区信息，并保证数据的顺序，再使用sqoop导出该表的数据到MariaDB中。</p><p><strong>在本地IDEA的项目中访问云主机数据库</strong></p><p><img src="https://image.3001.net/images/20220920/16636643056620.png" alt="image-20220920165823715"></p><ul><li><p>在云主机的数据库中新建账号，限定权限</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot</span><br><span class="line"></span><br><span class="line">grant all on nybikedb.* to user@&#x27;%&#x27; identified by &#x27;mysqlDWP135@&#x27;;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure></li><li><p>开放云主机的3306端口</p><p>  <img src="https://image.3001.net/images/20220704/16569093843411.png"></p></li><li><p>修改本地IDEA中nybike项目的配置文件</p><ul><li><p>修改src/main/resources/application.properties中的配置</p><p>  <img src="https://image.3001.net/images/20220704/16569093879037.png"></p></li></ul></li></ul><h3 id="DBeaver连接Hive问题"><a href="#DBeaver连接Hive问题" class="headerlink" title="DBeaver连接Hive问题"></a>DBeaver连接Hive问题</h3><p>修改hadoop的配置文件</p><p>修改 core-site.xml文件</p><p>　　vim /usr/local/hadoop/etc/hadoop/core-site.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;</span><br><span class="line">&lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;</span><br><span class="line">&lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>关闭文件权限检查：</p><p>hdfs-site.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">&lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p> 通过以下命令启动远程服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup hive --service metastore &amp;</span><br><span class="line">nohup hive --service hiveserver2 &amp;</span><br></pre></td></tr></table></figure><p>远程服务对外的端口是10000，启动成功后，使用netstat命令验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -antpl|grep 10000</span><br></pre></td></tr></table></figure><p><strong>下载cloudera版本的JDBC驱动</strong></p><p>下载地址：<a href="https://www.cloudera.com/downloads.html">https://www.cloudera.com/downloads.html</a></p><p>1.第一步</p><p><img src="https://image.3001.net/images/20220704/16569093901395.png" alt="image-20220629124404068"></p><p>2.第二步</p><p><img src="https://image.3001.net/images/20220704/16569093924246.png" alt="image-20220629124426936"></p><p>3.第三步打开添加，找到驱动类</p><p><img src="https://image.3001.net/images/20220704/16569093957216.png" alt="image-20220629143533935"></p><p>4.第四步选择无认证</p><p><img src="https://image.3001.net/images/20220704/165690939945.png" alt="image-20220629215710441"></p><p>第五步连接成功</p><img src="https://image.3001.net/images/20220704/16569094174002.png" alt="image-20220629215837577" style="zoom: 33%;" /><p>Hive远程访问操作<br><a href="https://blog.51cto.com/candon123/2048202">https://blog.51cto.com/candon123/2048202</a></p><p><a href="http://www.wjhsh.net/0xcafedaddy-p-8392029.html">http://www.wjhsh.net/0xcafedaddy-p-8392029.html</a></p><!-- more -->]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Hadoop伪分布搭建文档&quot;&gt;&lt;a href=&quot;#Hadoop伪分布搭建文档&quot; class=&quot;headerlink&quot; title=&quot;Hadoop伪分布搭建文档&quot;&gt;&lt;/a&gt;Hadoop伪分布搭建文档&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-准备1台虚拟机或云主机&quot;&gt;&lt;a href=&quot;#1-准备1台虚拟机或云主机&quot; class=&quot;headerlink&quot; title=&quot;1. 准备1台虚拟机或云主机&quot;&gt;&lt;/a&gt;1. 准备1台虚拟机或云主机&lt;/h3&gt;&lt;h4 id=&quot;1-配置好主机名&quot;&gt;&lt;a href=&quot;#1-配置好主机名&quot; class=&quot;headerlink&quot; title=&quot;1) 配置好主机名&quot;&gt;&lt;/a&gt;1) 配置好主机名&lt;/h4&gt;&lt;p&gt;配置主机hostname为master&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hostnamectl set-hostname master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-准备&quot;&gt;&lt;a href=&quot;#2-准备&quot; class=&quot;headerlink&quot; title=&quot;2)准备&quot;&gt;&lt;/a&gt;2)准备&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;关闭防火墙&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;systemctl status firewalld                 #查看防火墙状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemctl stop firewalld.service           #停止firewall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemctl disable firewalld.service        #禁止firewall开机启动&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="hadoop" scheme="https://yangmour.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Git版本流程控制基础命令</title>
    <link href="https://yangmour.github.io/2022/06/17/%E5%A4%A7%E6%95%B0%E6%8D%AE/git/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yangmour.github.io/2022/06/17/%E5%A4%A7%E6%95%B0%E6%8D%AE/git/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-06-17T09:06:17.000Z</published>
    <updated>2022-09-08T02:17:05.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git版本流程控制基础命令"><a href="#Git版本流程控制基础命令" class="headerlink" title="Git版本流程控制基础命令"></a>Git版本流程控制基础命令</h1><p>[TOC]</p><h2 id="Git整体架构"><a href="#Git整体架构" class="headerlink" title="Git整体架构"></a>Git整体架构</h2><p>整体架构</p><p><img src="https://image.3001.net/images/20220523/16532661467811.png" alt="image-20220523083544677"></p><span id="more"></span><p>工作流程</p><p><img src="https://image.3001.net/images/20220519/16529403685752.png" alt="image-20220519140535979"></p><h2 id="1-基础命令学习"><a href="#1-基础命令学习" class="headerlink" title="1.基础命令学习"></a>1.基础命令学习</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#查看git 版本号</span><br><span class="line">git --version</span><br><span class="line">#仓库初始化</span><br><span class="line">git init</span><br><span class="line">#查看仓库状态</span><br><span class="line">git status</span><br><span class="line">#把文件添加到暂存区(注意:如果你的只添加到暂存区没有提交过文件，可以使用git checkout ./(这个可以恢复所有删除的文件或文件夹)或者**文件名或者**文件夹名，用暂存中的文件恢复到本地工作目录中。如果恢复了一个文件其他文件没有恢复，并且又把文件添加到暂存没法找回)</span><br><span class="line">git add 文件名或者./</span><br><span class="line">#配置用户名</span><br><span class="line">git config user.name &quot;**&quot;</span><br><span class="line">#配置邮箱</span><br><span class="line">git config user.emil &quot;**&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#克隆仓库</span><br><span class="line">git clone &quot;gitee地址&quot;</span><br><span class="line">#提交到仓库</span><br><span class="line">git commit -m &quot;一句话&quot;</span><br><span class="line">#提交先添加到暂存区在提交到仓库</span><br><span class="line">git commit -a -m &quot;一句话&quot;</span><br><span class="line">#修改提交信息</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">#查看远程仓库地址</span><br><span class="line">git remote</span><br><span class="line">#先有本地仓库上传到远程仓库</span><br><span class="line"> git remote add origin ***.git</span><br><span class="line">#查看上传拉取仓库</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">#下拉到本地(git pull=git fetch+git merge)</span><br><span class="line">git pull</span><br><span class="line">#上传到远程仓库</span><br><span class="line">git push</span><br><span class="line">#1.拉取远程仓库的文件</span><br><span class="line">git fetch </span><br><span class="line">#2.拉取完成之后要在本地合并提交才可以</span><br><span class="line">git merge</span><br><span class="line"></span><br><span class="line">#查看提交了几次</span><br><span class="line">git log</span><br><span class="line">#查看简略信息</span><br><span class="line">git log --oneline</span><br><span class="line">#把所有的次数提交都显示出来</span><br><span class="line">git reflog --oneline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#回滚到之前的某个版本(就不是主分支了)</span><br><span class="line">git checkout 哈希值</span><br><span class="line">#如果需要回到之前最新的版本继续回滚到主分支</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">#创建标签(v0.1是版本号)</span><br><span class="line">git tag -a v0.1 -m &quot;一句信息&quot;</span><br><span class="line">#创建标签给某个版本，根据提交的某个版本的哈希值来创建</span><br><span class="line">git tag -a v0.0 哈希值</span><br><span class="line">#查看标签</span><br><span class="line">git tag</span><br><span class="line">#查看最新标签具体信息</span><br><span class="line">git show</span><br><span class="line">#查看某个版本的信息</span><br><span class="line">git show v0.1 g</span><br><span class="line">#删除标签</span><br><span class="line">git tag -d v0.1版本号</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">#上传到远程仓库某个具体标签</span><br><span class="line">git push origin v0.1</span><br><span class="line">#上传到远程仓库全部的标签</span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看当前文件和暂存区的区别</span><br><span class="line">git diff </span><br><span class="line">#查看暂存区与最后一个次提交</span><br><span class="line">git diff --staged</span><br><span class="line"></span><br><span class="line">#从暂存区中删除，工作区保留文件</span><br><span class="line">git rm --cached &quot;file&quot;</span><br><span class="line">#强制删除文件，加工作区都删除(得先添加到暂存区才行)</span><br><span class="line">git rm -f &quot;file&quot;</span><br></pre></td></tr></table></figure><h2 id="2-撤销命令-危险"><a href="#2-撤销命令-危险" class="headerlink" title="2.撤销命令(危险)"></a>2.撤销命令(危险)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#git reset是一个危险的命令，加上--hard也是如此</span><br><span class="line">git reset --hard 哈希值</span><br></pre></td></tr></table></figure><h2 id="3-本地仓库上传到gitee仓库上"><a href="#3-本地仓库上传到gitee仓库上" class="headerlink" title="3.本地仓库上传到gitee仓库上"></a>3.本地仓库上传到gitee仓库上</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.初始化</span><br><span class="line">git init</span><br><span class="line">#2.添加到暂存区</span><br><span class="line">git add ./</span><br><span class="line">#只添加到暂存区恢复误删的本地文件 (注意:git checkout ./输入后没添加到暂存区的也会撤销删除没有添加做好备份(这个可以恢复所有删除的文件或文件夹)或者**文件名或者**文件夹名，用暂存中的文件恢复到本地工作目录中。如果文件没有恢复，并且又把文件添加到暂存没法找回)</span><br><span class="line">git checkout -- fileName  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.提交仓库</span><br><span class="line">git commit -m &quot;初始化&quot;</span><br><span class="line"></span><br><span class="line">#绑定远程仓库</span><br><span class="line">git remote add origin http:****.git</span><br><span class="line">#上传到哪个仓库</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><h2 id="4-gitee仓库上下载项目"><a href="#4-gitee仓库上下载项目" class="headerlink" title="4.gitee仓库上下载项目"></a>4.gitee仓库上下载项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#下载仓库的命令</span><br><span class="line">git clone https:****.git</span><br></pre></td></tr></table></figure><h2 id="5-git分支"><a href="#5-git分支" class="headerlink" title="5.git分支"></a>5.git分支</h2><p><img src="https://image.3001.net/images/20220602/16541545846894.png" alt="image-20220526134915005"></p><h3 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1.创建分支"></a>1.创建分支</h3><p><img src="https://image.3001.net/images/20220526/16535441137064.png" alt="image-20220526134833406"></p><h3 id="2-切换分支"><a href="#2-切换分支" class="headerlink" title="2.切换分支"></a>2.切换分支</h3><p><img src="https://image.3001.net/images/20220526/16535442281581.png" alt="image-20220526135028437"></p><h3 id="3-切换到master分支"><a href="#3-切换到master分支" class="headerlink" title="3.切换到master分支"></a>3.切换到master分支</h3><p><img src="https://image.3001.net/images/20220526/16535444045671.png" alt="image-20220526135321328"></p><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p><img src="https://image.3001.net/images/20220526/16535444349214.png" alt="image-20220526135352174"></p><h4 id="2-分叉历史"><a href="#2-分叉历史" class="headerlink" title="2.分叉历史"></a>2.分叉历史</h4><p><img src="https://image.3001.net/images/20220526/16535444749484.png" alt="image-20220526135432413"></p><h4 id="3-手画图"><a href="#3-手画图" class="headerlink" title="3.手画图"></a>3.手画图</h4><ul><li><p>每一个圆圈都是一次提交的版本</p></li><li><p>第三次提交的时候有别的工作需要或者发现有点提交不好，从新创建分支做新的需求继续工作。</p></li><li><p>发现第二次提交有bug但是暂时没有报错。创建新分支需要修改提交了几个版本修复bug以后合并到主分支master上</p></li></ul><p><img src="https://image.3001.net/images/20220526/16535456515622.png" alt="image-20220526140203072"></p><p>4.查看你的提交历史，各分支的指向以及项目的分叉情况</p><p>testing分支有红色箭头向下指到某次提交上就是在那次提交分支出来的</p><p>master主分支有星号向下指到某次提交上就是在那次提交分支出来的</p><p><img src="https://image.3001.net/images/20220526/16535465355746.png" alt="image-20220526142453745"></p><h4 id="5-分支命令"><a href="#5-分支命令" class="headerlink" title="5.分支命令"></a>5.分支命令</h4><h5 id="1-创建切换"><a href="#1-创建切换" class="headerlink" title="1.创建切换"></a>1.创建切换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建分支</span><br><span class="line">git branch testing</span><br><span class="line">#切换分支</span><br><span class="line">git checkout testing</span><br><span class="line"></span><br><span class="line">#查看你的提交历史，各分支的指向以及项目的分叉情况（上面有介绍）</span><br><span class="line">git log --oneline --decorate --graph --all</span><br><span class="line"></span><br><span class="line">#删除分支</span><br><span class="line">git branch -d testing</span><br></pre></td></tr></table></figure><p>2.合并分支命令（还有一种形式是变基，放到第8个标题）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#要有一个其他分支</span><br><span class="line">#回到主分支或者某个分支输入合并命令git merge *分支,需要手动解决冲突</span><br><span class="line">git merge &quot;分支名字&quot;</span><br><span class="line">#提交合并</span><br><span class="line">git commit -m &quot;master或者其他 merge 分支&quot;</span><br><span class="line">#删掉不用的分支</span><br><span class="line">git branch -d 分支名字</span><br></pre></td></tr></table></figure><p>3.直接剪出分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#-b直接剪出分支并切换上去</span><br><span class="line">git checkout -b 分支名字 某次提交的哈希值</span><br></pre></td></tr></table></figure><h2 id="6-分支模型"><a href="#6-分支模型" class="headerlink" title="6.分支模型"></a>6.分支模型</h2><h3 id="1-远程分支可以同时进行更新"><a href="#1-远程分支可以同时进行更新" class="headerlink" title="1.远程分支可以同时进行更新"></a>1.远程分支可以同时进行更新</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://image.3001.net/images/20220602/1654150263138.png" alt="image-20220602141016854"></h4><h3 id="2-把远程的master分支拉取下来，然后本地合并merge"><a href="#2-把远程的master分支拉取下来，然后本地合并merge" class="headerlink" title="2.把远程的master分支拉取下来，然后本地合并merge"></a>2.把远程的master分支拉取下来，然后本地合并merge</h3><p><img src="https://image.3001.net/images/20220602/16541503237375.png" alt="image-20220602141139390"></p><h3 id="3-可以跟踪远程不同的分支"><a href="#3-可以跟踪远程不同的分支" class="headerlink" title="3.可以跟踪远程不同的分支"></a>3.可以跟踪远程不同的分支</h3><p><img src="https://image.3001.net/images/20220602/16541504801347.png" alt="image-20220602141359040"></p><h3 id="4-推送"><a href="#4-推送" class="headerlink" title="4.推送"></a>4.推送</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><img src="https://image.3001.net/images/20220602/16541511923615.png" alt="image-20220602141618117"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><img src="https://image.3001.net/images/20220602/16541535515301.png" alt="image-20220602150548995"></p><h4 id="远程仓库的样子"><a href="#远程仓库的样子" class="headerlink" title="远程仓库的样子"></a>远程仓库的样子</h4><p><img src="https://image.3001.net/images/20220602/16541536724322.png" alt="image-20220602150751060"></p><h3 id="5-分支模型命令"><a href="#5-分支模型命令" class="headerlink" title="5.分支模型命令"></a>5.分支模型命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#从远程仓库克隆一个下来</span><br><span class="line">git clone http:***.git</span><br><span class="line">#查看分支</span><br><span class="line">git branch</span><br><span class="line">#剪出分支并切换test是新分支，master是源分支</span><br><span class="line">git checkout -b test master</span><br><span class="line">#推送到远程仓库(test:test)</span><br><span class="line">git push origin test:test</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-分支模型的功能"><a href="#6-分支模型的功能" class="headerlink" title="6.分支模型的功能"></a>6.分支模型的功能</h3><h4 id="1-分支权限讲解"><a href="#1-分支权限讲解" class="headerlink" title="1.分支权限讲解"></a>1.分支权限讲解</h4><p><img src="https://image.3001.net/images/20220609/16547539959720.png" alt="image-20220609135311678"></p><h4 id="2-本地剪出了多个分支上传到远程"><a href="#2-本地剪出了多个分支上传到远程" class="headerlink" title="2.本地剪出了多个分支上传到远程"></a>2.本地剪出了多个分支上传到远程</h4><h5 id="1-本地"><a href="#1-本地" class="headerlink" title="1.本地"></a>1.本地</h5><p><img src="https://image.3001.net/images/20220609/16547549326418.png" alt="image-20220609140751868"></p><h5 id="2-远程"><a href="#2-远程" class="headerlink" title="2.远程"></a>2.远程</h5><p><img src="https://image.3001.net/images/20220609/16547549297694.png" alt="image-20220609140838373"></p><h5 id="3-本地上传到远程分支"><a href="#3-本地上传到远程分支" class="headerlink" title="3.本地上传到远程分支"></a>3.本地上传到远程分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#如果本地剪出了分支远程仓库没有当前分支需要使用的命令</span><br><span class="line">git push upstram origin 当前分支名</span><br><span class="line">#如果本地分支和远程仓库都有当前分支需要使用的命令</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h5 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4.合并分支"></a>4.合并分支</h5><h6 id="1-命令版"><a href="#1-命令版" class="headerlink" title="1.命令版"></a>1.命令版</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#回到主分支master</span><br><span class="line">git checkout master</span><br><span class="line">#合并分支(需要提交一次)，如果被合并的分支没有删除可以继续开发</span><br><span class="line">git merge 其他分支名字</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2-网页版"><a href="#2-网页版" class="headerlink" title="2.网页版"></a>2.网页版</h6><ol><li><p>去点击</p><p> gitee-&gt;Pull Requests-&gt;创建Pull Requests</p><p> <img src="https://image.3001.net/images/20220609/16547581811666.png" alt="image-20220609150259610"></p></li></ol><p>​    2.查看详情</p><p><img src="https://image.3001.net/images/20220609/16547582881172.png" alt="image-20220609150446758"></p><p>​    3.解决冲突</p><p><img src="https://image.3001.net/images/20220609/165475868590.png" alt="image-20220609151123936"></p><p>​    4.测试通过</p><p>​    5.审查通过</p><p>​    6.合并</p><p>​    7.接受Pull Requests（合并成功）</p><p><img src="https://image.3001.net/images/20220609/16547588534456.png" alt="image-20220609151411700"></p><h2 id="7-git工具-重置"><a href="#7-git工具-重置" class="headerlink" title="7.git工具-重置"></a>7.git工具-重置</h2><h3 id="工作流程图解"><a href="#工作流程图解" class="headerlink" title="工作流程图解"></a>工作流程图解</h3><h4 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1.工作流程"></a>1.工作流程</h4><p><img src="https://image.3001.net/images/20220606/16544760293989.png" alt="image-20220606084025327"></p><h4 id="2-git-init"><a href="#2-git-init" class="headerlink" title="2.git init"></a>2.git init</h4><p><img src="https://image.3001.net/images/20220606/1654476148460.png" alt="image-20220606084226959"></p><h4 id="3-git-add"><a href="#3-git-add" class="headerlink" title="3.git add"></a>3.git add</h4><p><img src="https://image.3001.net/images/20220606/16544762182028.png" alt="image-20220606084337560"></p><h4 id="4-git-commit"><a href="#4-git-commit" class="headerlink" title="4.git commit"></a>4.git commit</h4><p><img src="https://image.3001.net/images/20220606/16544762612593.png" alt="image-20220606084414704"></p><h4 id="5-修改文件"><a href="#5-修改文件" class="headerlink" title="5.修改文件"></a>5.修改文件</h4><p><img src="https://image.3001.net/images/20220606/16544769125884.png" alt="image-20220606085511027"></p><p>在提交就变成v2版本</p><p>git add</p><p>git commit</p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2.命令"></a>2.命令</h3><h4 id="6-重置的作用"><a href="#6-重置的作用" class="headerlink" title="6.重置的作用"></a>6.重置的作用</h4><p><img src="https://image.3001.net/images/20220606/16544770059691.png" alt="image-20220606085644229"></p><h5 id="1-移动head（指向）"><a href="#1-移动head（指向）" class="headerlink" title="1.移动head（指向）"></a>1.移动head（指向）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#移动到父提交，就是移动到指向的那次提交，并且撤销那次提交信息，会发现git diff --staged看到暂存区和最后一次提交看到区别</span><br><span class="line">git reset --soft head~</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220613/16550978609298.png" alt="image-20220606085721854"></p><h5 id="2-更新所以-–mixed"><a href="#2-更新所以-–mixed" class="headerlink" title="2.更新所以(–mixed)"></a>2.更新所以(–mixed)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#移动到父提交，就是移动到指向的那次提交，并且撤销那次提交信息，会发现git diff看到本地和暂存区的区别(--mixed可有可无一般加上)</span><br><span class="line">git reset --mixed head~</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220606/16544787052452.png" alt="image-20220606092500185"></p><h5 id="3-更新工作目录-–hard-危险"><a href="#3-更新工作目录-–hard-危险" class="headerlink" title="3.更新工作目录(–hard)    危险"></a>3.更新工作目录(–hard)    危险</h5><p>#！注意：危险</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#会用暂存区的文件覆盖掉本地工作区的文件，被覆盖掉的数据无法恢复</span><br><span class="line">git reset --hard HEAD~</span><br><span class="line"></span><br><span class="line">git reset --hard 哈希值</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220606/1654479055651.png" alt="image-20220606093054648"></p><h2 id="8-变基-注意团队协作时候慎用"><a href="#8-变基-注意团队协作时候慎用" class="headerlink" title="8.变基(注意团队协作时候慎用)"></a>8.变基(注意团队协作时候慎用)</h2><h3 id="注意事项-变基的风险在官网看到的-："><a href="#注意事项-变基的风险在官网看到的-：" class="headerlink" title="注意事项(变基的风险在官网看到的)："></a>注意事项(变基的风险在官网看到的)：</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>​        呃，角色变的并非完美无缺，它必须遵循规范：</p><p>​        <strong>如果提交存在于你的这些仓库之外，而其他人可能基于提交进行开发，那么就不要执行更改基。</strong></p><p>​        否则，人民群众会冤枉你，你的朋友和家人也会欢迎你，唾弃。</p><p>​        改变基操作的实质是丢弃了一些现有的新建地，但如果你已经提交了一些实际不同的内容，而其他人已经提交了一些至仓库。如果你进行了工作，如果此时，如果你<code>git rebase</code>提交并使用命令工作，那么你的同胞将再次组织他们与你的工作人员一起工作，并与你的工作人员进行合作，将他们与你的工作进行整合。他们修改过的提交，会发生一团糟。</p><p>​        如果你只是不会离开你的电脑提交的执行变基，那就不会有事了。那个你已经开发到仓库的提交上执行了更改的库命令，并因此遗弃了别人所基于的提交，你的大麻烦，因此有一些人鄙视你。</p><p>​        如果你或你的同事在某些情况下要执行此<code>git pull --rebase</code>命令，请一定通知每个人，这样尽管伤痛，但不能缓和执行。</p><h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a>变基 vs. 合并</h3><p>​        至此，你已经在实战中学习了，并打算在实战中学习的时候讨论一下，最终你一定要改变什么后退的方式。 。</p><p>​        从这个角度看，提交历史亵渎，你利用<em>谎言本身就是</em><strong>记录</strong>历史的一种说法。如果是由它产生的约定是这样发生的事情。</p><p>​        没有人会出版一本书的第一版，软件维护手册也是需要方便使用<strong>的</strong>。会使用<code>rebase</code>及<code>filter-branch</code>等工具来写故事，怎么方便后来的读者就怎么写。</p><p>​        现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的允许。分别是学习了其中的用处，相信你根据情况已经做出了明智的选择。</p><p>​        总的是，只对广泛使用或使用方便操作的方式进行操作，方便大家的修改执行操作，从没有给你的能力改变到合适的地方，让你可以改变操作的习惯，带来方便，这样可以方便地使用。</p><h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><h3 id="1-有两个分支"><a href="#1-有两个分支" class="headerlink" title="1.有两个分支"></a>1.有两个分支</h3><p><img src="https://image.3001.net/images/20220617/16554697682417.png" alt="basic-rebase-1"></p><h3 id="2-分叉的提交历史（用git-merge-）"><a href="#2-分叉的提交历史（用git-merge-）" class="headerlink" title="2.分叉的提交历史（用git merge **）"></a>2.分叉的提交历史（用git merge **）</h3><p>它通过两个最新分支的方法是最容易进行的<code>merge</code>。它与两个最新的分支（以及最新的命令<code>C3</code>）<code>C4</code>的共同（以及最近的三个命令<code>C2</code>）的结果是同时生成一个新的预告（并提交）。 ）。</p><p><img src="https://image.3001.net/images/20220617/16554698407298.png" alt="basic-rebase-2"></p><h3 id="3-通过合并操作来整合分叉的历史（git-rebase-）"><a href="#3-通过合并操作来整合分叉的历史（git-rebase-）" class="headerlink" title="3.通过合并操作来整合分叉的历史（git rebase **）"></a>3.通过合并操作来整合分叉的历史（git rebase **）</h3><p>你可以在<code>C4</code>中提取<code>C3</code>基础的基础和修改，然后在 Git 中，这种操作就<strong>习惯</strong><code>rebase</code>了。至分支上的所有修改都移到分支上，就好像“重新播放”一样。（<strong>源分支指的是你所在分支，指定分支就是你要合并到的分支。前面的话的意思是：就是你把源分支修改的部分都移到你指定的分支上去，然后再回到指定分支进行合并</strong>)</p><p>在这个中，你可以检测出<code>experiment</code>分支，然后将它变到基<code>master</code>分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#切换分支</span><br><span class="line">git checkout experiment</span><br><span class="line">#将当前分支修改的部分临时文件放到master分支，并没有合并</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p><strong>git rebase命令之后的方式</strong></p><p>官网的介绍：</p><p>然后它的原理是先找到这两个分支（当前分支<code>experiment</code>、改变基操作的目标即为基础并为<code>master</code>最近的共同祖先）<code>C2</code>，然后当前分支提交给该祖先的历次，相应的存储临时文件，修改将当前指定的目标明确目标顺序<code>C3</code>，最后将在另存为临时文件的依序应用之前将其另存为临时文件。</p><p><img src="https://image.3001.net/images/20220617/16554704203460.png" alt="basic-rebase-3"></p><h3 id="4-将C4中的修改变基到C3上（就相当于c4修改的部分移到c3上去）"><a href="#4-将C4中的修改变基到C3上（就相当于c4修改的部分移到c3上去）" class="headerlink" title="4.将C4中的修改变基到C3上（就相当于c4修改的部分移到c3上去）"></a>4.将<code>C4</code>中的修改变基到<code>C3</code>上（就相当于c4修改的部分移到c3上去）</h3><p>现在回到<code>master</code>分支，进行一次快进合并,合并完成后两个分支都指到当前分支。</p><p>此时，<code>C4</code>指向的分支就改变了合并示例，虽然实际上的开发工作是并行的，但似乎发现是历史上没有记录的，他们是直接分叉的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#切换回master</span><br><span class="line">git checkout master</span><br><span class="line">#合并分支</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220617/16554707944763.png" alt="basic-rebase-4"></p><p>后面一部分没写看官网吧</p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">git官网地址</a></p><p>第五个部分对应到 （<strong>更有趣的变基例子</strong>）</p><!-- more -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git版本流程控制基础命令&quot;&gt;&lt;a href=&quot;#Git版本流程控制基础命令&quot; class=&quot;headerlink&quot; title=&quot;Git版本流程控制基础命令&quot;&gt;&lt;/a&gt;Git版本流程控制基础命令&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Git整体架构&quot;&gt;&lt;a href=&quot;#Git整体架构&quot; class=&quot;headerlink&quot; title=&quot;Git整体架构&quot;&gt;&lt;/a&gt;Git整体架构&lt;/h2&gt;&lt;p&gt;整体架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.3001.net/images/20220523/16532661467811.png&quot; alt=&quot;image-20220523083544677&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://yangmour.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>10-java9&amp;10&amp;11新特性</title>
    <link href="https://yangmour.github.io/2022/01/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/%E9%AB%98%E7%BA%A7/10-java9&amp;10&amp;11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://yangmour.github.io/2022/01/05/%E5%A4%A7%E6%95%B0%E6%8D%AE/java/%E9%AB%98%E7%BA%A7/10-java9&amp;10&amp;11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-01-05T15:30:37.000Z</published>
    <updated>2022-09-08T02:17:05.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java9-amp-10-amp-11新特性"><a href="#java9-amp-10-amp-11新特性" class="headerlink" title="java9&amp;10&amp;11新特性"></a>java9&amp;10&amp;11新特性</h1><p>[TOC]</p><h2 id="Java9-amp-10-amp-11新特性概述（看视频或者查资料文档）"><a href="#Java9-amp-10-amp-11新特性概述（看视频或者查资料文档）" class="headerlink" title="Java9&amp;10&amp;11新特性概述（看视频或者查资料文档）"></a>Java9&amp;10&amp;11新特性概述（看视频或者查资料文档）</h2><p>具体特性可直接查看第17章ppt即可。</p><p>去github的blog仓库中查看有pdf文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java9-amp-10-amp-11新特性&quot;&gt;&lt;a href=&quot;#java9-amp-10-amp-11新特性&quot; class=&quot;headerlink&quot; title=&quot;java9&amp;amp;10&amp;amp;11新特性&quot;&gt;&lt;/a&gt;java9&amp;amp;10&amp;amp;11新</summary>
      
    
    
    
    
    <category term="java基础-高级" scheme="https://yangmour.github.io/tags/java%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
</feed>
